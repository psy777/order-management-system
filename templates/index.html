<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Order Management System</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="icon" href="../assets/favicon.ico" sizes="any">
    <link rel="icon" type="image/png" sizes="16x16" href="../assets/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../assets/favicon-32x32.png">
    <link rel="apple-touch-icon" href="../assets/apple-touch-icon.png">
    <link rel="manifest" href="../assets/site.webmanifest">
    <link rel="stylesheet" href="../assets/css/styles.css">
</head>
<body>
    <div id="root"></div>
    {% raw %}
    <script type="text/babel">
// --- SHARED HELPER COMPONENTS & ICONS ---
const Card = ({ title, value, icon }) => (
    <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200 flex items-center">
        <div className="bg-orange-100 text-orange-600 p-3 rounded-full mr-4">{icon}</div>
        <div><p className="text-sm font-medium text-slate-500">{title}</p><p className="text-2xl font-bold text-slate-800">{value}</p></div>
    </div>
);
const Input = ({ label, placeholder, value, onChange, type = "text", disabled = false, onFocus, onBlur }) => (
    <div><label className="block text-sm font-medium text-slate-600">{label}</label><input type={type} placeholder={placeholder} value={value} onChange={onChange} disabled={disabled} onFocus={onFocus} onBlur={onBlur} className="mt-1 block w-full px-3 py-2 bg-white border border-slate-300 rounded-md shadow-sm placeholder-slate-400 focus:outline-none focus:ring-orange-500 focus:border-orange-500 sm:text-sm disabled:bg-slate-100 disabled:text-slate-500" /></div>
);
const Select = ({ value, onChange, disabled = false, children }) => (
    <select value={value} onChange={onChange} disabled={disabled} className="w-full px-3 py-2 bg-white border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500 sm:text-sm disabled:bg-slate-100 disabled:text-slate-500">{children}</select>
);
const Textarea = ({ label, placeholder, value, onChange, disabled = false, rows = 3, onFocus, onBlur }) => (
    <div><label className="block text-sm font-medium text-slate-600">{label}</label><textarea rows={rows} placeholder={placeholder} value={value} onChange={onChange} disabled={disabled} onFocus={onFocus} onBlur={onBlur} className="mt-1 block w-full text-sm px-3 py-2 bg-white border border-slate-300 rounded-md shadow-sm placeholder-slate-400 focus:outline-none focus:ring-orange-500 focus:border-orange-500 disabled:bg-slate-100 disabled:text-slate-500"></textarea></div>
);
const TrashIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" /></svg>);
const DollarSignIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8v1m0 8v1m-4-4h8m-4-4a8 8 0 100 16 8 8 0 000-16z" /></svg>);
const DocumentTextIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>);
const ChartBarIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" /></svg>);
const ViewIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>);
const PdfIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>);
const EmailIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" /></svg>);
const TrendingUpIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6" /></svg>);

const CogIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
    </svg>
);

const PriceInput = ({ value, onChange, disabled = false }) => {
    const handleChange = (e) => { const digits = e.target.value.replace(/\D/g, ''); onChange(Number(digits)); };
    const formattedValue = (value / 100).toFixed(2);
    return (<input type="text" value={`$${formattedValue}`} onChange={handleChange} disabled={disabled} className="w-24 sm:w-28 text-right bg-white border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500 sm:text-sm p-2 disabled:bg-slate-100 disabled:text-slate-500" />);
};

const ScentToggle = ({ value, onChange, disabled = false }) => {
    const options = ["Scented", "Unscented", "Mixed"];
    return (<div><label className="block text-sm font-medium text-slate-600 mb-2">Scent Option</label><div className="flex w-full bg-slate-200 p-1 rounded-full">{options.map(option => (<button key={option} onClick={() => !disabled && onChange(option)} disabled={disabled} className={`w-full text-center px-3 py-1.5 text-sm font-semibold rounded-full transition-all duration-300 ease-in-out ${value === option ? 'bg-white text-orange-600 shadow-sm' : 'text-slate-600 hover:bg-slate-300/50'} ${disabled ? 'cursor-not-allowed' : ''}`}>{option}</button>))}</div></div>);
};

const NameDropToggle = ({ value, onChange, disabled = false }) => {
    return (
        <div>
            <label className="block text-sm font-medium text-slate-600 mb-1">Name Drop Surcharge</label>
            <button
                onClick={() => !disabled && onChange(!value)}
                disabled={disabled}
                className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors duration-200 ease-in-out focus:outline-none ${disabled ? 'cursor-not-allowed opacity-50' : 'focus:ring-2 focus:ring-orange-500 focus:ring-opacity-50'} ${value ? 'bg-orange-600' : 'bg-slate-300'}`}
            >
                <span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform duration-200 ease-in-out ${value ? 'translate-x-6' : 'translate-x-1'}`} />
            </button>
            {value && <p className="text-xs text-slate-500 mt-1">$1.00 surcharge per cross item.</p>}
        </div>
    );
};

const StatusBar = ({ status, statusHistory }) => {
    const statuses = ['Draft', 'Sent', 'Paid', 'Shipped'];
    const currentStatusIndex = statuses.indexOf(status);
    return (<div className="w-full my-6"><div className="flex items-center">{statuses.map((s, index) => (<React.Fragment key={s}><div className="relative group flex flex-col items-center"><div className={`w-8 h-8 rounded-full flex items-center justify-center text-white font-bold ${index <= currentStatusIndex ? 'bg-orange-600' : 'bg-slate-300'}`}>{index <= currentStatusIndex ? '✓' : '●'}</div><p className={`mt-2 text-xs text-center ${index <= currentStatusIndex ? 'text-orange-600 font-semibold' : 'text-slate-500'}`}>{s}</p>{statusHistory.find(h => h.status === s) && (<div className="absolute bottom-full mb-2 w-max px-2 py-1 bg-slate-800 text-white text-xs rounded-md opacity-0 group-hover:opacity-100 transition-opacity duration-300">{new Date(statusHistory.find(h => h.status === s).date).toLocaleString()}</div>)}</div>{index < statuses.length - 1 && (<div className={`flex-auto border-t-4 mx-2 ${index < currentStatusIndex ? 'border-orange-600' : 'border-slate-300'}`}></div>)}</React.Fragment>))}</div></div>);
};

const generatePdf = (order, allItems, action = 'save') => {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    const { vendorInfo, lineItems, notes, total, id, date, scentOption, estimatedShippingDate, estimatedShipping, nameDrop, signatureDataUrl } = order; // Added signatureDataUrl and estimatedShipping
    doc.setFontSize(20); doc.text("Purchase Order", 14, 22);
    doc.setFontSize(12); doc.text(`PO #: ${id}`, 14, 30); doc.text(`Date: ${new Date(date).toLocaleDateString()}`, 14, 36);
    
    let leftColumnY = 50;
    let rightColumnY = 50;
    const leftColumnX = 14;
    const rightColumnX = 105; // Start addresses further to the right

    // Vendor Info - Left Column
    doc.setFontSize(12); doc.text("Vendor Information", leftColumnX, leftColumnY); 
    leftColumnY += 6;
    doc.setFontSize(10);
    doc.text(`${vendorInfo.companyName}`, leftColumnX, leftColumnY); leftColumnY += 5;
    doc.text(`${vendorInfo.contactName}`, leftColumnX, leftColumnY); leftColumnY += 5;
    doc.text(`${vendorInfo.email}`, leftColumnX, leftColumnY); leftColumnY += 5;
    doc.text(`${vendorInfo.phone}`, leftColumnX, leftColumnY); leftColumnY += 5;

    // Billing Address - Right Column
    if (vendorInfo.billingAddress || vendorInfo.billingCity) {
        doc.setFontSize(10);
        doc.text("Billing Address:", rightColumnX, rightColumnY); rightColumnY += 5;
        const ba = `${vendorInfo.billingAddress || ''}\n${vendorInfo.billingCity || ''}, ${vendorInfo.billingState || ''} ${vendorInfo.billingZipCode || ''}`;
        const billingAddressLines = doc.splitTextToSize(ba, 90);
        doc.text(billingAddressLines, rightColumnX, rightColumnY);
        rightColumnY += (billingAddressLines.length * 4) + 2;
    }

    // Shipping Address - Right Column, below Billing
    if (vendorInfo.shippingAddress || vendorInfo.shippingCity) {
        if (vendorInfo.billingAddress || vendorInfo.billingCity) rightColumnY += 3;
        doc.setFontSize(10);
        doc.text("Shipping Address:", rightColumnX, rightColumnY); rightColumnY += 5;
        const sa = `${vendorInfo.shippingAddress || ''}\n${vendorInfo.shippingCity || ''}, ${vendorInfo.shippingState || ''} ${vendorInfo.shippingZipCode || ''}`;
        const shippingAddressLines = doc.splitTextToSize(sa, 90);
        doc.text(shippingAddressLines, rightColumnX, rightColumnY);
        rightColumnY += (shippingAddressLines.length * 4) + 2;
    }
    
    // Determine the starting Y for the table, ensuring it's below both columns
    let tableStartY = Math.max(leftColumnY, rightColumnY, 70); // Ensure table starts at least at Y=70 or below the longest column
    tableStartY += 5; // Add a small buffer

    const tableColumn = ["Item", "Style", "Quantity", "Unit Price", "Total"];
    const tableRows = lineItems.map(item => [allItems[item.item]?.name || item.item, item.style, item.quantity, `$${(item.price / 100).toFixed(2)}`, `$${((item.quantity * item.price) / 100).toFixed(2)}`]);
    doc.autoTable({ head: [tableColumn], body: tableRows, startY: tableStartY });

    // Calculate subtotal and name drop surcharge
    let calculatedSubtotal = 0;
    lineItems.forEach(item => {
        calculatedSubtotal += item.quantity * item.price;
    });

    let calculatedNameDropSurcharge = 0;
    if (nameDrop) {
        lineItems.forEach(item => {
            if (item.type === 'cross') { // Assuming item.type is reliably populated
                calculatedNameDropSurcharge += item.quantity * 100; // $1.00 per cross item
            }
        });
    }

    let finalY = doc.lastAutoTable.finalY + 10;
    doc.setFontSize(10); // Smaller font for sub-lines
    doc.text(`Subtotal: $${(calculatedSubtotal / 100).toFixed(2)}`, 14, finalY);
    finalY += 7;

    if (calculatedNameDropSurcharge > 0) {
        doc.text(`Name Drop Surcharge: $${(calculatedNameDropSurcharge / 100).toFixed(2)}`, 14, finalY);
        finalY += 7;
    }

    // Add Estimated Shipping Cost here
    // estimatedShipping is destructured from order, expected to be a string like "12.34"
    const estShippingValue = parseFloat(estimatedShipping) || 0; // Default to 0 if NaN
    if (estShippingValue > 0) { // Display only if positive value
        doc.setFontSize(10); // Ensure font size is consistent for this item
        doc.text(`Est. Shipping Cost: $${estShippingValue.toFixed(2)}`, 14, finalY);
        finalY += 7; // Increment Y for the next line
    }

    // Calculate the grand total for PDF display based on components shown on PDF
    const estimatedShippingInCentsForPdfTotal = Math.round(estShippingValue * 100);
    const grandTotalForPdfDisplay = calculatedSubtotal + calculatedNameDropSurcharge + estimatedShippingInCentsForPdfTotal;

    doc.setFontSize(12); // Larger font for the grand total
    doc.text(`Total: $${(grandTotalForPdfDisplay / 100).toFixed(2)}`, 14, finalY); // Use the self-calculated total for PDF
    
    finalY += 10; 
    doc.setFontSize(10); 
    doc.text(`Scent Option: ${scentOption}`, 14, finalY);

    let currentLineY = finalY + 5; // Y position for the next line of text

    if(estimatedShippingDate) {
        doc.text(`Est. Ship Date: ${new Date(estimatedShippingDate + 'T00:00:00').toLocaleDateString()}`, 14, currentLineY);
        currentLineY += 5; // Increment Y for the next line
    }
    
    finalY = currentLineY - 5; // Update finalY to the Y position of the last line written (if any date was written)
                               // If no date, finalY remains as it was after Scent Option.
                               // This needs to be robust: if currentLineY didn't change, finalY should be the Y of Scent Option.
    if (currentLineY === finalY + 10) { // This means neither date nor shipping cost (from previous logic) was added after Scent Option
        // If only Scent Option was printed, and then we moved to notes, finalY should be where Scent Option was.
        // However, the new logic places shipping cost before total, so this specific adjustment might need review.
        // Let's simplify: finalY is now the Y after Total. The lines after Total start from there.
        // The `finalY = currentLineY - 5;` was for the block that printed date/shipping *after* total.
        // Now that block is split, we need to ensure `finalY` correctly reflects the Y position *after* the Total.
        // The `finalY += 10;` after Total already correctly sets up for Scent Option.
        // The `currentLineY` logic for Est. Ship Date is fine as it starts from `finalY` (which is after Scent Option).
    }
    
    let notesStartY = finalY + 10; // This should be based on the Y position after Est. Ship Date (if present)
                                   // or after Scent Option if no Est. Ship Date.
                                   // The `finalY = currentLineY - 5;` correctly sets this up if currentLineY was updated.
                                   // If currentLineY was NOT updated (no ship date), then finalY is still the Y of Scent Option.
                                   // So, notesStartY will be 10 below Scent Option or 10 below Est. Ship Date. This seems correct.
    if (notes) { 
        doc.text("Notes:", 14, notesStartY); 
        const splitNotes = doc.splitTextToSize(notes, 180); 
        doc.text(splitNotes, 14, notesStartY + 5);
        finalY = notesStartY + 5 + (splitNotes.length * 4); // Adjust finalY based on notes length
    } else {
        finalY = notesStartY; // If no notes, finalY is just after shipping date
    }

    // Signature Block
    finalY += 15; // Add some space before signature
    if (finalY > 260) { // Check if new page is needed for signature
        doc.addPage();
        finalY = 20; // Reset Y position for new page
    }
    doc.setFontSize(10);
    doc.text("Authorized Signature:", 14, finalY);

    if (signatureDataUrl) {
        try {
            if (signatureDataUrl.startsWith('data:image/png;base64,')) {
                const base64ImageData = signatureDataUrl.substring(signatureDataUrl.indexOf(',') + 1);
                // A very short base64 string might indicate an empty or problematic signature.
                // A 1x1 transparent PNG's base64 data is ~88 chars.
                // We require a bit more to consider it a valid signature image.
                if (base64ImageData.length > 150) { 
                    const signatureImgWidth = 70; // mm
                    const signatureImgHeight = 20; // mm, adjust as needed
                    doc.addImage(signatureDataUrl, 'PNG', 50, finalY - (signatureImgHeight/2) + 2 , signatureImgWidth, signatureImgHeight);
                } else {
                    console.warn("Signature data is too short (length: " + base64ImageData.length + "), possibly empty or corrupted. Drawing a line instead.");
                    doc.line(50, finalY, 120, finalY); // Fallback line
                }
            } else {
                console.error("Signature data URL is not a valid PNG image. Drawing a line instead.");
                doc.line(50, finalY, 120, finalY); // Fallback line
            }
        } catch (e) {
            console.error("Error adding signature image to PDF:", e);
            doc.line(50, finalY, 120, finalY); // Fallback line in case of error
        }
    } else {
        doc.line(50, finalY, 120, finalY); // Draw a line if no signature data
    }
    
    if (action === 'save') { doc.save(`PO_${id}.pdf`); } 
    else if (action === 'preview') { doc.output('dataurlnewwindow'); }
    else if (action === 'datauristring') { return doc.output('datauristring'); }
}

const SalesChart = ({ data }) => {
    const { useRef, useEffect } = React;
    const chartRef = useRef(null);
    const chartInstance = useRef(null);
    useEffect(() => { if (chartRef.current) { if (chartInstance.current) { chartInstance.current.destroy(); } const ctx = chartRef.current.getContext('2d'); chartInstance.current = new Chart(ctx, { type: 'bar', data, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true } }, plugins: { legend: { display: false } } } }); } return () => { if (chartInstance.current) { chartInstance.current.destroy(); } }; }, [data]);
    return <canvas ref={chartRef} />;
};

const SignaturePad = ({ onSave, initialDataUrl, disabled = false }) => {
    const { useRef, useEffect, useState } = React;
    const canvasRef = useRef(null);
    const [isDrawing, setIsDrawing] = useState(false);
    const [signatureData, setSignatureData] = useState(initialDataUrl || null);

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        
        // Set canvas dimensions based on its CSS-defined size
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;

        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        if (signatureData) {
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear before drawing existing
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            };
            img.src = signatureData;
        } else {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

    }, [signatureData, disabled]); // Redraw if signatureData changes or disabled state changes

    const getMousePos = (canvas, evt) => {
        const rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    };
    
    const getTouchPos = (canvas, touch) => {
        const rect = canvas.getBoundingClientRect();
        return {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top
        };
    };

    const startDrawing = (e) => {
        if (disabled) return;
        setIsDrawing(true);
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const pos = e.type.startsWith('touch') ? getTouchPos(canvas, e.touches[0]) : getMousePos(canvas, e);
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        e.preventDefault(); // Prevent scrolling on touch
    };

    const draw = (e) => {
        if (!isDrawing || disabled) return;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const pos = e.type.startsWith('touch') ? getTouchPos(canvas, e.touches[0]) : getMousePos(canvas, e);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        e.preventDefault(); // Prevent scrolling on touch
    };

    const stopDrawing = () => {
        if (!isDrawing || disabled) return;
        setIsDrawing(false);
        const canvas = canvasRef.current;
        const dataUrl = canvas.toDataURL('image/png');
        setSignatureData(dataUrl); // Update local state for display
        if (onSave) {
            onSave(dataUrl); // Propagate to parent
        }
    };

    const clearSignature = () => {
        if (disabled) return;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        setSignatureData(null);
        if (onSave) {
            onSave(null); // Propagate null to parent
        }
    };
    
    // Add event listeners for touch events
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || disabled) return;

        // Ensure canvas has dimensions before adding listeners if it might be initially hidden or 0-sized
        // if (canvas.offsetWidth === 0 || canvas.offsetHeight === 0) { // Removed this check as it might prevent listeners if canvas is initially 0px then resized by CSS
            // Optionally, wait for dimensions or log a warning
            // console.warn("SignaturePad canvas has no dimensions yet.");
            // return; // Or handle resize observer
        // }


        canvas.addEventListener('touchstart', startDrawing, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);

        return () => {
            canvas.removeEventListener('touchstart', startDrawing);
            canvas.removeEventListener('touchmove', draw);
            canvas.removeEventListener('touchend', stopDrawing);
            canvas.removeEventListener('touchcancel', stopDrawing);
        };
    }, [isDrawing, disabled, onSave, canvasRef.current?.offsetWidth, canvasRef.current?.offsetHeight]); // Re-run if canvas dimensions change

    const canvasStyle = {
        touchAction: 'none'
    };

    return (
        <div className="space-y-2">
            <canvas
                ref={canvasRef}
                onMouseDown={startDrawing}
                onMouseMove={draw}
                onMouseUp={stopDrawing}
                onMouseLeave={stopDrawing} // Stop drawing if mouse leaves canvas
                className={`w-full h-40 bg-slate-100 border border-slate-300 rounded-md cursor-crosshair ${disabled ? 'cursor-not-allowed opacity-70' : ''}`}
                style={canvasStyle} // Use the style object here
            ></canvas>
            {!disabled && (
                <button
                    onClick={clearSignature}
                    className="w-full text-center px-4 py-2 bg-slate-200 text-slate-700 font-semibold rounded-md hover:bg-slate-300 transition-colors text-sm"
                >
                    Clear Signature
                </button>
            )}
        </div>
    );
};


const EmailModal = ({ order, onClose, allItems, onEmailClientOpened, appSettings, saveOrder, onOrderUpdatedAfterEmail }) => {
    const { useState, useEffect, useRef } = React;
    const fileInputRef = useRef(null);
    const [attachments, setAttachments] = useState([]); // Handles multiple attachments
    const [isSending, setIsSending] = useState(false);
    const [emailSent, setEmailSent] = useState(false);
    const [isUploading, setIsUploading] = useState(false); // For upload progress
    const [editableBody, setEditableBody] = useState('');

    const hiddenFileInputStyle = { display: 'none' };

    const handleFileSelected = async (event) => {
        const files = Array.from(event.target.files);
        if (files.length === 0) return;

        setIsUploading(true);
        const uploadPromises = files.map(file => {
            const formData = new FormData();
            formData.append('file', file);
            return fetch('/api/upload-attachment', {
                method: 'POST',
                body: formData,
            }).then(response => response.json());
        });

        try {
            const results = await Promise.all(uploadPromises);
            const newAttachments = results.map((result, index) => {
                if (result.status === 'success') {
                    const expectedPoName = `PO_${order.id}.pdf`;
                    return {
                        original: result.originalFilename,
                        unique: result.uniqueFilename,
                        isMatch: result.originalFilename === expectedPoName,
                    };
                } else {
                    alert(`Failed to upload ${files[index].name}: ${result.message}`);
                    return null;
                }
            }).filter(Boolean); // Filter out nulls from failed uploads

            setAttachments(prev => [...prev, ...newAttachments]);
        } catch (error) {
            alert(`Error during file upload: ${error.message}`);
        } finally {
            setIsUploading(false);
            // Reset file input to allow re-selecting the same file(s)
            if(fileInputRef.current) {
                fileInputRef.current.value = "";
            }
        }
    };

    // useEffect for generating pdfDataUri is removed.

    useEffect(() => {
        const handleOutsideClick = (event) => {
            // Check if the click is outside the modal content
            if (event.target.id === "email-modal-backdrop") {
                onClose();
            }
        };

        // Add event listener when the modal is shown
        document.addEventListener('mousedown', handleOutsideClick);

        // Clean up event listener when the modal is hidden or component unmounts
        return () => {
            document.removeEventListener('mousedown', handleOutsideClick);
        };
    }, [onClose]);

    useEffect(() => {
        if (order && appSettings && appSettings.default_email_body) {
            let body = appSettings.default_email_body;
            // Replace placeholders
            // For [customerName], prefer contact name, fallback to company name.
            body = body.replace(/\[customerName\]/g, order.vendorInfo.contactName || order.vendorInfo.companyName || '');
            // For [vendorCompanyName], use company name.
            body = body.replace(/\[vendorCompanyName\]/g, order.vendorInfo.companyName || '');
            body = body.replace(/\[orderID\]/g, order.id || '');
            body = body.replace(/\[yourCompany\]/g, appSettings.company_name || 'Your Company');
            setEditableBody(body);
        } else if (order) {
            // Fallback if settings are not loaded or default_email_body is missing
            const fallbackYourCompanyName = appSettings?.company_name || "Your Company";
            setEditableBody(
`Dear ${order.vendorInfo.contactName || order.vendorInfo.companyName},

Please find attached the purchase order ${order.id} for your records.

Thank you,
${fallbackYourCompanyName}`
            );
        }
    }, [order, appSettings]);

    if (!order) return null;

    const recipient = order.vendorInfo.email;
    const subjectText = `${appSettings?.company_name || "Your Company"} - Order Confirmation ${order.id}`;
    
    // mailtoHref will be constructed on click or when rendering the link to use the latest editableBody
    const getMailtoHref = () => `mailto:${recipient}?subject=${encodeURIComponent(subjectText)}&body=${encodeURIComponent(editableBody)}`;

    return (
    <div id="email-modal-backdrop" className="fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center p-4">
        <div className="bg-white rounded-lg shadow-xl p-8 w-full max-w-2xl max-h-[90vh] overflow-y-auto modal-content">
                <h2 className="text-2xl font-bold text-slate-800 mb-4">Send Order Confirmation</h2>
                <div className="space-y-4">
                    <Input label="To" value={order.vendorInfo.email} disabled />
                    <Input label="Subject" value={subjectText} disabled />
                    <Textarea label="Email Body" value={editableBody} onChange={e => setEditableBody(e.target.value)} rows={8} disabled={false} />
                    <div className="bg-orange-50 p-4 rounded-md border border-orange-200">
                        <p className="text-sm font-medium text-orange-700 mb-2">Order PDF:</p>
                        {/* Button to trigger client-side PDF generation for download */}
                        <button
                            onClick={() => {
                                if (order && allItems) {
                                    try {
                                        generatePdf(order, allItems, 'save'); // 'save' action directly downloads
                                    } catch (e) {
                                        console.error("Error generating PDF for download:", e);
                                        alert("Failed to generate PDF for download.");
                                    }
                                } else {
                                    alert("Order data or item data is missing, cannot generate PDF.");
                                }
                            }}
                            className="w-full flex items-center justify-center bg-blue-600 hover:bg-blue-700 text-white font-semibold px-4 py-3 rounded-md shadow-sm transition-colors"
                        >
                            <PdfIcon />
                            <span className="ml-2">Download PO_{order.id}.pdf</span>
                        </button>
                        <p className="mt-2 text-xs text-orange-700">Click to download the PO. Then, use the 'Upload Custom Attachment' button below if you wish to attach it to the email.</p>
                    </div>

                    {/* File Upload Section */}
                    <div className="pt-2"> {/* Added some top padding */}
                        <input
                            type="file"
                            ref={fileInputRef}
                            style={hiddenFileInputStyle}
                            onChange={handleFileSelected}
                            multiple // Allow multiple files
                        />
                        <button
                            onClick={() => fileInputRef.current && fileInputRef.current.click()}
                            className={`w-full flex items-center justify-center bg-slate-200 hover:bg-slate-300 text-slate-700 font-semibold px-4 py-3 rounded-md shadow-sm transition-colors text-sm ${isUploading ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isUploading}
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clipRule="evenodd" />
                            </svg>
                            {isUploading ? 'Uploading...' : 'Upload Attachments'}
                        </button>
                        {attachments.length > 0 && (
                            <div className="mt-3 space-y-2">
                                <p className="text-sm font-medium text-slate-700">Attached Files:</p>
                                <ul className="list-disc list-inside bg-slate-50 p-3 rounded-md border border-slate-200">
                                    {attachments.map((att, index) => (
                                        <li key={index} className="text-xs flex justify-between items-center">
                                            <span className={att.isMatch ? 'text-green-600 font-semibold' : 'text-slate-600'}>
                                                {att.original}
                                                {att.isMatch && <span className="ml-1">✔ Matches Order</span>}
                                            </span>
                                            <button onClick={() => setAttachments(attachments.filter((_, i) => i !== index))} className="text-red-500 hover:text-red-700 p-1">
                                                <TrashIcon />
                                            </button>
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        )}
                    </div>
                </div>
                <div className="mt-6 flex items-center justify-between">
                    <button 
                        onClick={onClose} 
                        className="px-4 py-2 bg-slate-200 text-slate-700 font-semibold rounded-md hover:bg-slate-300 transition-colors"
                    >
                        Cancel
                    </button>
                    <button
                        onClick={async () => {
                            if (isSending || isUploading) return;

                            const hasMismatchedPo = attachments.some(att => !att.isMatch);
                            if (attachments.length === 0) {
                                // popup
                                if (!window.confirm("No files are attached. Send email without attachments?")) return;
                            } else if (hasMismatchedPo) {
                                const expectedPoName = `PO_${order.id}.pdf`;
                                if (!window.confirm(`Warning: At least one attachment does not match the expected PO name "${expectedPoName}". Proceed anyway?`)) return;
                            }
                            
                            setIsSending(true);
                            const emailPayload = {
                                order: order,
                                recipientEmail: order.vendorInfo.email,
                                subject: subjectText,
                                body: editableBody,
                                attachments: attachments.map(a => ({ original: a.original, unique: a.unique })),
                            };

                            try {
                                const response = await fetch('/api/send-order-email', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify(emailPayload)
                                });
                                const result = await response.json();
                                if (response.ok) {
                                    setEmailSent(true);
                                    
                                    // New logic: After email sends, update the order status to 'Sent' and save it.
                                    const newStatusHistory = [...order.statusHistory, { status: 'Sent', date: new Date().toISOString() }];
                                    const updatedOrderForStatusChange = { ...order, status: 'Sent', statusHistory: newStatusHistory };

                                    try {
                                        // saveOrder is passed from App, it handles the API call and global state update.
                                        await saveOrder(updatedOrderForStatusChange);
                                    } catch (saveError) {
                                        // If saving the status fails, the user should be notified.
                                        alert(`Email was sent successfully, but there was an error updating the order status: ${saveError.message}`);
                                    }

                                    setTimeout(() => {
                                        if (onEmailClientOpened) {
                                            onEmailClientOpened();
                                        }
                                    }, 1000);
                                } else {
                                    alert(`Failed to send email: ${result.message || 'Server error'}`);
                                }
                            } catch (error) {
                                alert(`Error sending email: ${error.message}`);
                            } finally {
                                setIsSending(false);
                            }
                        }}
                        className={`px-6 py-2 bg-green-600 text-white font-semibold rounded-md hover:bg-green-700 transition-colors ${isSending || isUploading || emailSent ? 'opacity-50 cursor-not-allowed' : ''}`}
                        disabled={isSending || isUploading || emailSent}
                    >
                        {emailSent ? 'Sent!' : isSending ? 'Sending...' : 'Send via Server'}
                    </button>
                </div>
            </div>
        </div>
    );
};

const ShippedStatusBadge = ({ statusText }) => {
    const { useState, useRef, useEffect } = React;
    const [glintStyle, setGlintStyle] = useState({});
    const badgeRef = useRef(null);
    const proximityThreshold = 75; // Pixels around the badge to trigger the effect

    const baseStyle = {
        background: `linear-gradient(135deg, #FDE047, #FBBF24, #F59E0B)`, // amber-300, amber-400, amber-500
    };

    useEffect(() => {
        setGlintStyle(baseStyle); // Set initial background

        const handleGlobalMouseMove = (e) => {
            if (!badgeRef.current) return;

            const rect = badgeRef.current.getBoundingClientRect();
            const badgeCenterX = rect.left + rect.width / 2;
            const badgeCenterY = rect.top + rect.height / 2;

            const cursorX = e.clientX;
            const cursorY = e.clientY;

            const distanceX = cursorX - badgeCenterX;
            const distanceY = cursorY - badgeCenterY;
            const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

            if (distance < proximityThreshold + rect.width / 2) { // Add half width/height for smoother edge detection
                // Calculate glare position relative to the badge, even if cursor is outside
                // Normalize cursor position relative to the badge's top-left corner
                const xInBadge = cursorX - rect.left;
                const yInBadge = cursorY - rect.top;

                const glareX = (xInBadge / rect.width) * 100;
                const glareY = (yInBadge / rect.height) * 100;
                
                // Clamp glareX and glareY to prevent extreme gradients if cursor is far but within threshold
                const clampedGlareX = Math.max(-50, Math.min(150, glareX)); // Allow some overflow for effect
                const clampedGlareY = Math.max(-50, Math.min(150, glareY));


                setGlintStyle({
                    background: `radial-gradient(circle at ${clampedGlareX}% ${clampedGlareY}%, rgba(255,255,255,0.75) 0%, rgba(255,255,255,0) 50%), linear-gradient(135deg, #FDE047, #FBBF24, #F59E0B)`,
                    transition: 'background 0.05s linear' // Faster transition for responsiveness
                });
            } else {
                setGlintStyle({...baseStyle, transition: 'background 0.3s ease-out'}); // Slower transition when resetting
            }
        };

        document.addEventListener('mousemove', handleGlobalMouseMove);
        return () => {
            document.removeEventListener('mousemove', handleGlobalMouseMove);
        };
    }, []); // Empty dependency array means this effect runs once on mount and cleans up on unmount

    return (
        <span
            ref={badgeRef}
            className="px-2 py-1 text-xs font-semibold rounded-full text-amber-800 border-2 border-amber-500 shadow-md"
            style={{...glintStyle, display: 'inline-block', position: 'relative', overflow: 'hidden' }} // Added overflow hidden for cleaner gradient edges
        >
            {statusText}
        </span>
    );
};

// --- COMPONENTS ---
const Dashboard = ({ orders, navigateTo, viewOrder, allVendors, allSelectableItems, setOrderForEmailModal }) => { // Added setOrderForEmailModal
    const { useState, useEffect, useMemo } = React;
    const [filteredOrders, setFilteredOrders] = useState(orders);
    // orderForEmail state is removed from Dashboard, as EmailModal is now triggered from OrderForm or globally via setOrderForEmailModal
    const [dashboardStats, setDashboardStats] = useState({ totalRevenue: 0, averageOrderRevenue: 0, totalOrders: 0 });

    useEffect(() => {
        setFilteredOrders(orders);
        const fetchDashboardStats = async () => {
            try {
                const response = await fetch('/api/dashboard-stats');
                const data = await response.json();
                setDashboardStats(data);
            } catch (error) {
                console.error("Failed to fetch dashboard stats:", error);
                // Set default or error values if needed
                setDashboardStats({ totalRevenue: 0, averageOrderRevenue: 0, totalOrders: orders.length });
            }
        };
        fetchDashboardStats();
    }, [orders]);

    // This function now expects amountInDollars
    const formatCurrency = (amountInDollars) => { 
        // Ensure amountInDollars is a number, default to 0 if not
        const numericAmount = typeof amountInDollars === 'number' ? amountInDollars : parseFloat(amountInDollars) || 0;
        return numericAmount.toLocaleString('en-US', {
            style: 'currency',
            currency: 'USD',
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
    };

    return (
        <React.Fragment>
            {/* EmailModal is now handled globally or by OrderForm, so removed from here directly */}
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-3xl font-bold text-slate-800">Dashboard</h1>
                <div className="flex space-x-2">
                    <button onClick={() => navigateTo('createOrder')} className="px-4 py-2 bg-orange-600 text-white font-semibold rounded-md hover:bg-orange-700 transition-colors shadow">+ Create New Order</button>
                </div>
            </div>
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
                <Card title="Total Revenue" value={formatCurrency(dashboardStats.totalRevenue)} icon={<TrendingUpIcon />} />
                <Card title="Total Orders" value={dashboardStats.totalOrders} icon={<DocumentTextIcon />} />
                <Card title="Avg. Order Value" value={formatCurrency(dashboardStats.averageOrderRevenue)} icon={<ChartBarIcon />} />
            </div>
            <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                <h2 className="text-xl font-semibold text-slate-700 mb-4">All Orders</h2>
                <div className="overflow-x-auto"><table className="w-full text-sm text-left text-slate-500"><thead className="text-xs text-slate-700 uppercase bg-slate-100"><tr><th className="px-4 py-3">Order ID</th><th className="px-4 py-3">Customer</th><th className="px-4 py-3">Date</th><th className="px-4 py-3">Total</th><th className="px-4 py-3">Status</th><th className="px-4 py-3 text-center">Actions</th></tr></thead>
                    <tbody>{filteredOrders.map(order => (<tr key={order.id} className="bg-white border-b hover:bg-slate-50">
                        <td className="px-4 py-3 font-medium text-slate-800">{order.id}</td><td className="px-4 py-3">{order.vendorInfo.companyName}</td>
                        <td className="px-4 py-3">{new Date(order.date).toLocaleDateString()}</td><td className="px-4 py-3">${parseFloat(order.total || 0).toFixed(2)}</td>
                        <td className="px-4 py-3">
                            {order.status === 'Shipped' ? (
                                <ShippedStatusBadge statusText={order.status} />
                            ) : (
                                <span className={`px-2 py-1 text-xs font-semibold rounded-full ${
                                    order.status === 'Paid' ? 'bg-green-100 text-green-800' :
                                    order.status === 'Sent' ? 'bg-blue-100 text-blue-800' :
                                    'bg-slate-100 text-slate-800' // Draft or other
                                }`}>{order.status}</span>
                            )}
                        </td>
                        <td className="px-4 py-3 text-center">
                            <div className="flex items-center justify-center space-x-2">
                                <button onClick={() => viewOrder(order)} className="p-1 text-slate-500 hover:text-orange-600"><ViewIcon /></button>
                                <button onClick={() => generatePdf(order, allSelectableItems, 'preview')} className="p-1 text-slate-500 hover:text-orange-600"><PdfIcon /></button>
                                <button onClick={() => setOrderForEmailModal(order)} className="p-1 text-slate-500 hover:text-orange-600"><EmailIcon /></button>
                                <a href={`/order-logs/${order.id}`} className="p-1 text-slate-500 hover:text-orange-600" title="Order History">
                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" />
                                    </svg>
                                </a>
                            </div>
                        </td>
                    </tr>))}</tbody>
                </table></div>
            </div>
        </React.Fragment>
    );
};

const UnsavedChangesModal = ({ onCancel, onDelete, onSaveAndClose }) => {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center p-4">
            <div className="bg-white rounded-lg shadow-xl p-8 w-full max-w-md">
                <h2 className="text-xl font-bold text-slate-800 mb-4">You have unsaved changes.</h2>
                <p className="text-slate-600 mb-6">What would you like to do?</p>
                <div className="flex justify-end space-x-4">
                    <button onClick={onCancel} className="px-4 py-2 bg-slate-200 text-slate-700 font-semibold rounded-md hover:bg-slate-300 transition-colors">Cancel</button>
                    <button onClick={onDelete} className="px-4 py-2 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700 transition-colors">Delete</button>
                    <button onClick={onSaveAndClose} className="px-4 py-2 bg-orange-600 text-white font-semibold rounded-md hover:bg-orange-700 transition-colors">Save and Close</button>
                </div>
            </div>
        </div>
    );
};

const OrderForm = ({ order, navigateTo, saveOrder, deleteOrder, allVendors, allSelectableItems, itemData, packageData, fetchAndUpdateVendors, setOrderForEmailModal }) => { // Added setOrderForEmailModal
    const { useState, useMemo, useEffect, useRef } = React;
    const [isEditing, setIsEditing] = useState(!order || order.status === 'Draft');
    const [formData, setFormData] = useState(order ? {...order, estimatedShipping: order.estimatedShipping || '', scentOption: order.scentOption || 'Scented'} : { vendorInfo: { companyName: '', contactName: '', email: '', phone: '', billingAddress: '', billingCity: '', billingState: '', billingZipCode: '', shippingAddress: '', shippingCity: '', shippingState: '', shippingZipCode: '' }, lineItems: [], notes: "", estimatedShippingDate: '', estimatedShipping: '', scentOption: 'Scented', nameDrop: false, signatureDataUrl: null, statusHistory: [{ status: 'Draft', date: new Date().toISOString() }], status: 'Draft' });
    const [vendorSuggestions, setVendorSuggestions] = useState([]);
    const [showUnsavedChangesModal, setShowUnsavedChangesModal] = useState(false);
    // orderToEmail state is removed, setOrderForEmailModal prop will be used directly
    const [scanInput, setScanInput] = useState('');
    const scanInputRef = React.useRef(null);
    const [sameAsShipping, setSameAsShipping] = useState(true);
    const [isAutofilledVendorActive, setIsAutofilledVendorActive] = useState(false); // Renamed
    const [initialVendorInfoAfterAutofill, setInitialVendorInfoAfterAutofill] = useState(null); // New state
    const [isEditingAutofilledVendor, setIsEditingAutofilledVendor] = useState(false);
    const [isVendorInputActive, setIsVendorInputActive] = useState(false);
    const hideSuggestionsTimeoutRef = React.useRef(null);
    // fetchAndUpdateVendors is now directly available from props destructuring

    const handleReturnToDashboard = () => {
        const isNewUnsavedDraft = !order && (formData.lineItems.length > 0 || (formData.vendorInfo && formData.vendorInfo.companyName));

        if (isNewUnsavedDraft) {
            setShowUnsavedChangesModal(true);
        } else {
            navigateTo('dashboard');
        }
    };

    useEffect(() => {
        // Debounce function
        const debounce = (func, delay) => {
            let timeoutId;
            return (...args) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        };

        const debouncedFetchShipping = debounce(fetchEstimatedShipping, 750); // 750ms debounce

        if (formData.vendorInfo.shippingZipCode && formData.lineItems) {
             // Only call if zip is 5 digits and there are items
            if (formData.vendorInfo.shippingZipCode.length === 5 && /^\d{5}$/.test(formData.vendorInfo.shippingZipCode) && formData.lineItems.length > 0) {
                debouncedFetchShipping(formData.vendorInfo.shippingZipCode, formData.lineItems);
            } else if (formData.vendorInfo.shippingZipCode.length === 5 && /^\d{5}$/.test(formData.vendorInfo.shippingZipCode) && formData.lineItems.length === 0) {
                // If valid zip but no items, set shipping to 0
                setFormData(prev => ({ ...prev, estimatedShipping: '0.00' }));
            }
        }
    }, [formData.vendorInfo.shippingZipCode, formData.lineItems]);





    const fetchEstimatedShipping = async (zipCode, items) => {
        if (!zipCode || zipCode.length !== 5 || !/^\d{5}$/.test(zipCode)) {
            // console.log("Skipping shipping calculation: Invalid ZIP code format.");
            // Optionally set shipping to 0 or a specific state if ZIP is invalid
            // setFormData(prev => ({ ...prev, estimatedShipping: '' })); // Clear if zip is invalid
            return;
        }
        if (!items || items.length === 0) {
            // console.log("Skipping shipping calculation: No items.");
            setFormData(prev => ({ ...prev, estimatedShipping: '0.00' })); // No items, no shipping cost
            return;
        }

        try {
            const response = await fetch('/api/calculate-shipping-estimate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ shippingZipCode: zipCode, lineItems: items })
            });
            const data = await response.json();
            if (response.ok) {
                setFormData(prev => ({ ...prev, estimatedShipping: data.estimatedShipping.toString() }));
            } else {
                console.error("Failed to fetch shipping estimate:", data.message);
                // setFormData(prev => ({ ...prev, estimatedShipping: '' })); // Clear or set to error state
            }
        } catch (error) {
            console.error("Error fetching shipping estimate:", error);
            // setFormData(prev => ({ ...prev, estimatedShipping: '' })); // Clear or set to error state
        }
    };
    
    useEffect(() => {
        // Debounce function
        const debounce = (func, delay) => {
            let timeoutId;
            return (...args) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        };

        const debouncedFetchShipping = debounce(fetchEstimatedShipping, 750); // 750ms debounce

        if (formData.vendorInfo.shippingZipCode && formData.lineItems) {
             // Only call if zip is 5 digits and there are items
            if (formData.vendorInfo.shippingZipCode.length === 5 && /^\d{5}$/.test(formData.vendorInfo.shippingZipCode) && formData.lineItems.length > 0) {
                debouncedFetchShipping(formData.vendorInfo.shippingZipCode, formData.lineItems);
            } else if (formData.vendorInfo.shippingZipCode.length === 5 && /^\d{5}$/.test(formData.vendorInfo.shippingZipCode) && formData.lineItems.length === 0) {
                // If valid zip but no items, set shipping to 0
                setFormData(prev => ({ ...prev, estimatedShipping: '0.00' }));
            }
        }
    }, [formData.vendorInfo.shippingZipCode, formData.lineItems]);


    const formatPhoneNumber = (value) => {
        if (!value) return value;
        const phoneNumber = value.replace(/[^\d]/g, '');
        const phoneNumberLength = phoneNumber.length;
        if (phoneNumberLength < 4) return phoneNumber;
        if (phoneNumberLength < 7) {
            return `(${phoneNumber.slice(0, 3)}) ${phoneNumber.slice(3)}`;
        }
        return `(${phoneNumber.slice(0, 3)}) ${phoneNumber.slice(3, 6)}-${phoneNumber.slice(6, 10)}`;
    };

    let nextId = useMemo(() => formData.lineItems.length > 0 ? Math.max(...formData.lineItems.map(i => i.id)) + 1 : 1, [formData.lineItems]);

    const handleVendorInputFocus = () => {
        clearTimeout(hideSuggestionsTimeoutRef.current);
        setIsVendorInputActive(true);
    };

    const handleVendorInputBlur = () => {
        // Use a timeout to allow click on suggestion list before it disappears
        hideSuggestionsTimeoutRef.current = setTimeout(() => {
            setIsVendorInputActive(false);
        }, 150); 
    };
    
const unpackPackage = (id, pkgCode) => {
 
  const pkg = packageData[pkgCode] || { contents: [] };

  const newItems = pkg.contents.map(({ itemCode, quantity }) => {
    const info = itemData[itemCode] || {};
    const selectableInfo = allSelectableItems[itemCode] || {};
    return {
      id:       nextId++,
      item:     itemCode,
      style:    (info.styles && info.styles[0]) || '',
      type:     selectableInfo.type || 'cross',
      quantity: quantity,
      price:    (info.price || 0),
      packageCode: pkgCode,
    };
  });

  setFormData(prev => ({
    ...prev,
    lineItems: [
      ...prev.lineItems.filter(item => item.id !== id),
      ...newItems
    ]
  }));
};

    const handleLineItemChange = (id, field, value) => {
        if (field === 'item' && allSelectableItems[value]?.type === 'package') {
            unpackPackage(id, value);
        } else {
             setFormData(prev => ({...prev, lineItems: prev.lineItems.map(item => {
                 if (item.id !== id) return item;
                 const updatedItem = {...item, [field]: value};
                 if (field === 'item' && itemData[value]) {
                     updatedItem.style = itemData[value].styles?.[0] || '';
                     updatedItem.price = (itemData[value].price || 0);
                     updatedItem.type = allSelectableItems[value]?.type || 'cross';
                 }
                 return updatedItem;
             })}));
        }
    };
    
    const handleScanAddItem = (event) => {
        if (event) event.preventDefault();

        const itemCode = scanInput.trim().toUpperCase();
        if (allSelectableItems[itemCode]) {
            if (allSelectableItems[itemCode].type === 'package') {
                unpackPackage(nextId++, itemCode);
            } else {
                setFormData(prev => ({ ...prev, lineItems: [...prev.lineItems, { id: nextId++, item: itemCode, style: itemData[itemCode]?.styles[0] || '', type: allSelectableItems[itemCode]?.type || 'cross', quantity: 1, price: (itemData[itemCode]?.price || 0), packageCode: null }] })); 
            }
            setScanInput('');
        } else { 
            console.log("Item code not found:", itemCode); 
        }
        if (scanInputRef.current) {
            scanInputRef.current.focus();
        }
    };
    
    const addEmptyLineItem = () => { setFormData(prev => ({ ...prev, lineItems: [...prev.lineItems, { id: nextId++, item: '-- Select Item --', style: '', type: '', quantity: 1, price: 0 }] })); };
    const removeLineItem = (id) => { setFormData(prev => ({ ...prev, lineItems: prev.lineItems.filter(item => item.id !== id) })); };

    const handleVendorInfoChange = (field, value) => {
        let processedValue = value;
        if (field === 'phone') {
            processedValue = formatPhoneNumber(value);
        }
        const newVendorInfo = {...formData.vendorInfo, [field]: processedValue};
        if (field === 'billingAddress' && sameAsBilling) {
            newVendorInfo.shippingAddress = processedValue; // if billing address is phone, this would be an issue, but it's not
        }
        // Special handling if 'billingAddress' is being updated and 'sameAsBilling' is true
        if (field === 'billingAddress' && sameAsBilling) {
            newVendorInfo.shippingAddress = newVendorInfo.billingAddress;
        }

        setFormData(prev => ({ ...prev, vendorInfo: newVendorInfo }));

        if (isAutofilledVendorActive) {
            // Compare current form vendor info with the initial info after autofill
            const currentVendorString = JSON.stringify(newVendorInfo);
            const initialVendorString = JSON.stringify(initialVendorInfoAfterAutofill);
            if (currentVendorString !== initialVendorString) {
                setIsEditingAutofilledVendor(true);
            } else {
                setIsEditingAutofilledVendor(false);
            }
        } else {
            setIsEditingAutofilledVendor(false); // If not an active autofilled vendor, not editing one
        }

        if (value.length > 1 && (field === 'companyName' || field === 'contactName' || field === 'email')) { // Only suggest for certain fields
            const searchResults = allVendors.filter(vendor => {
                const searchLower = value.toLowerCase();
                return (vendor.companyName && vendor.companyName.toLowerCase().includes(searchLower)) ||
                       (vendor.contactName && vendor.contactName.toLowerCase().includes(searchLower)) ||
                       (vendor.email && vendor.email.toLowerCase().includes(searchLower));
            });
            setVendorSuggestions(searchResults);
        } else { setVendorSuggestions([]); }
    };

    const handleSameAsShippingChange = (e) => {
        const isChecked = e.target.checked;
        setSameAsShipping(isChecked);
        setFormData(prev => ({
            ...prev,
            vendorInfo: {
                ...prev.vendorInfo,
                billingAddress: isChecked ? prev.vendorInfo.shippingAddress : '',
                billingCity: isChecked ? prev.vendorInfo.shippingCity : '',
                billingState: isChecked ? prev.vendorInfo.shippingState : '',
                billingZipCode: isChecked ? prev.vendorInfo.shippingZipCode : ''
            }
        }));
    };
    
    useEffect(() => {
        // Initialize sameAsShipping based on whether shipping and billing addresses are identical when an order is loaded
        if (order && order.vendorInfo) {
            if (order.vendorInfo.shippingAddress && order.vendorInfo.shippingAddress === order.vendorInfo.billingAddress) {
                setSameAsShipping(true);
            } else if (order.vendorInfo.shippingAddress && !order.vendorInfo.billingAddress) {
                 // If billing is empty but shipping is not, assume sameAsShipping should be true initially
                setSameAsShipping(true);
                setFormData(prev => ({
                    ...prev,
                    vendorInfo: {
                        ...prev.vendorInfo,
                        billingAddress: prev.vendorInfo.shippingAddress,
                        billingCity: prev.vendorInfo.shippingCity,
                        billingState: prev.vendorInfo.shippingState,
                        billingZipCode: prev.vendorInfo.shippingZipCode
                    }
                }));
            }
            else {
                setSameAsShipping(false);
            }
        } else {
            // For new orders, default to true
            setSameAsShipping(true);
             setFormData(prev => ({ // ensure billing address is copied if shipping has a default
                ...prev,
                vendorInfo: {
                    ...prev.vendorInfo,
                    billingAddress: prev.vendorInfo.shippingAddress,
                    billingCity: prev.vendorInfo.shippingCity,
                    billingState: prev.vendorInfo.shippingState,
                    billingZipCode: prev.vendorInfo.shippingZipCode
                }
            }));
        }
    }, [order]);


    const selectVendor = (vendor) => {
        clearTimeout(hideSuggestionsTimeoutRef.current); // Clear any pending hide
        setFormData(prev => {
            const newVendorInfo = {...vendor};
            if (sameAsShipping) {
                newVendorInfo.billingAddress = newVendorInfo.shippingAddress;
                newVendorInfo.billingCity = newVendorInfo.shippingCity;
                newVendorInfo.billingState = newVendorInfo.shippingState;
                newVendorInfo.billingZipCode = newVendorInfo.shippingZipCode;
            } else {
                // If not sameAsShipping, retain existing billingAddress from form or set to empty if vendor doesn't have one
                newVendorInfo.billingAddress = prev.vendorInfo.billingAddress || vendor.billingAddress || '';
                newVendorInfo.billingCity = prev.vendorInfo.billingCity || vendor.billingCity || '';
                newVendorInfo.billingState = prev.vendorInfo.billingState || vendor.billingState || '';
                newVendorInfo.billingZipCode = prev.vendorInfo.billingZipCode || vendor.billingZipCode || '';
            }
            return {...prev, vendorInfo: newVendorInfo};
        }); 
        setVendorSuggestions([]);
        setInitialVendorInfoAfterAutofill(JSON.parse(JSON.stringify(vendor))); // Store a deep copy
        setIsAutofilledVendorActive(true);
        setIsEditingAutofilledVendor(false);
        setIsVendorInputActive(false); // Hide suggestions immediately after selection
    }
    
    const orderTotals = useMemo(() => {
        const subtotal = formData.lineItems.reduce((acc, item) => acc + (item.quantity * item.price), 0);
        let nameDropSurcharge = 0;
        let crossItemCount = 0;
        if (formData.nameDrop) {
            formData.lineItems.forEach(item => {
                if (item.type === 'cross') {
                    nameDropSurcharge += item.quantity * 100; // $1 per item quantity
                    crossItemCount += item.quantity;
                }
            });
        }
        // formData.estimatedShipping is expected to be in dollars (float)
        const estimatedShipping = parseFloat(formData.estimatedShipping) || 0; // in dollars
        const estimatedShippingInCents = Math.round(estimatedShipping * 100);

        // Always calculate the total based on current form data components.
        const liveCalculatedTotal = subtotal + nameDropSurcharge + estimatedShippingInCents;

        return { 
            subtotal, // in cents
            nameDropSurcharge, // in cents
            estimatedShipping, // in dollars (for display in summary)
            total: liveCalculatedTotal, // always use the live calculation, in cents
            crossItemCount 
        };
    }, [formData.lineItems, formData.nameDrop, formData.estimatedShipping]);

    const isDraft = formData.status === 'Draft';
    const canEdit = isEditing || isDraft;
    
    const handleStatusChange = (newStatus) => {
        const newStatusHistory = [...formData.statusHistory, { status: newStatus, date: new Date().toISOString() }];
        const updatedOrder = { ...formData, status: newStatus, statusHistory: newStatusHistory };
        setFormData(updatedOrder);
        saveOrder(updatedOrder);
    };
    
    const createOrderObject = (status) => {
        const finalStatus = status || formData.status;
        const newStatusHistory = formData.statusHistory.find(h => h.status === finalStatus) ? formData.statusHistory : [...formData.statusHistory, { status: finalStatus, date: new Date().toISOString() }];
        // Ensure signatureDataUrl is included from formData
        return { ...formData, id: formData.id || `PO-${Date.now()}`, date: formData.date || new Date().toISOString(), status: finalStatus, statusHistory: newStatusHistory, total: orderTotals.total, signatureDataUrl: formData.signatureDataUrl };
    };

    const handleSaveDraft = async () => {
        if (!formData.vendorInfo.companyName) {
            console.log("Order save failed: Please select a vendor.");
            return;
        }
        const newOrder = createOrderObject('Draft');
        try {
            await saveOrder(newOrder);
            navigateTo('dashboard');
        } catch (error) {
            // Error is already logged by saveOrder, just log to console here
            console.log(`Failed to save draft: ${error.message}`);
        }
    };
    
    const handleSaveAndSend = async () => {
        if (!formData.vendorInfo.companyName || !formData.vendorInfo.email) { console.log("Order save failed: Please select a vendor with a valid email address."); return; }
        const newOrder = createOrderObject('Sent'); // Order status is 'Sent'
        await saveOrder(newOrder); // Save the order
        
        // Instead of direct mailto and navigate, trigger the EmailModal
        // The EmailModal's onEmailClientOpened callback (passed from App component) will handle navigation.
        setOrderForEmailModal(newOrder); 
    };

    const handlePreviewPdf = () => { const tempOrder = createOrderObject(); generatePdf(tempOrder, allSelectableItems, 'preview'); };
    
    const handleDelete = async () => {
        if (!formData || !formData.id) {
            console.log("Cannot delete: Order data is missing.");
            return;
        }

        const orderId = formData.id;
        const orderStatus = formData.status;
        const companyName = formData.vendorInfo?.companyName || "";
        const cleanedOrderId = orderId.replace("PO-", "");
        let orderIdDigitsForConfirmation = "";

        if (cleanedOrderId.length >= 4) {
            orderIdDigitsForConfirmation = cleanedOrderId.slice(-4); // Get last 4 digits
        } else if (cleanedOrderId.length > 0) {
            orderIdDigitsForConfirmation = cleanedOrderId; // Use all available if less than 4
        }


        let confirmationMessage = "Are you sure you want to delete this order? This action cannot be undone.";
        let requiresSpecialConfirmation = false;
        let expectedConfirmationPhrase = "";

        if (orderStatus !== 'Draft') {
            requiresSpecialConfirmation = true;
            if (!companyName || !orderIdDigitsForConfirmation) {
                 console.log("Cannot proceed with deletion: Company name or Order ID is missing/invalid for confirmation string generation.");
                 return;
            }
            expectedConfirmationPhrase = `delete ${companyName} order ${orderIdDigitsForConfirmation}`;
            confirmationMessage = `To delete this order, please type the following exactly:\n\n"${expectedConfirmationPhrase}"`; // Added \n\n for a new line and some spacing
        }

        const userInput = window.prompt(confirmationMessage);

        if (userInput === null) { // User cancelled the prompt
            return;
        }

        let deletePayload = { ...formData, status: "Deleted" };

        if (requiresSpecialConfirmation) {
            if (userInput === expectedConfirmationPhrase) {
                deletePayload.deleteConfirmation = userInput; // Pass to backend
            } else {
                console.log("Deletion cancelled: The confirmation phrase was incorrect.");
                return;
            }
        } else { // For Draft orders, simple confirm is enough (prompt acts as confirm)
            if (userInput === "" && orderStatus === 'Draft' && window.confirm("Are you sure you want to delete this draft? This action cannot be undone.")) {
                 // This path is if prompt was empty but they confirm a second time.
                 // However, the prompt itself serves as the main confirmation for draft.
                 // If prompt is empty for draft, we can assume they don't want to type anything.
            } else if (userInput !== "" && orderStatus === 'Draft') {
                // If they typed something for a draft order, it's not the special confirmation,
                // but we can treat it as a "yes" to the prompt.
            } else if (orderStatus !== 'Draft') { 
                // This case should not be reached if requiresSpecialConfirmation logic is correct.
                console.log("Deletion cancelled.");
                return;
            }
            // For draft, no special deleteConfirmation field needed unless backend strictly requires it (which it doesn't for drafts)
        }
        
        // Proceed with deletion
        try {
            await deleteOrder(orderId, deletePayload); // Pass the full payload for deletion
            navigateTo('dashboard');
        } catch (error) {
            // Error should be handled by saveOrder/deleteOrder and displayed by them or here
            console.error("Error during delete operation:", error);
            console.log(`Failed to delete order: ${error.message || 'Unknown error'}`);
        }
    };

    const handleCancelVendorEdit = () => {
        if (initialVendorInfoAfterAutofill) {
            setFormData(prev => ({ ...prev, vendorInfo: JSON.parse(JSON.stringify(initialVendorInfoAfterAutofill)) }));
        }
        setIsEditingAutofilledVendor(false);
        // isAutofilledVendorActive remains true because we reverted to the autofilled state
    };

    const handleSaveVendorEdits = async () => {
        if (!initialVendorInfoAfterAutofill || !initialVendorInfoAfterAutofill.id) {
            console.log("Cannot save edits: Original vendor ID is missing.");
            return;
        }
        const vendorIdToUpdate = initialVendorInfoAfterAutofill.id;
        const payload = { ...formData.vendorInfo }; // Current form data for vendor
        // Ensure ID in payload matches, or remove it if backend prefers ID only in URL
        payload.id = vendorIdToUpdate; 

        try {
            const response = await fetch(`/api/vendors/${vendorIdToUpdate}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();
            if (response.ok && result.status === 'success') {
                setInitialVendorInfoAfterAutofill(JSON.parse(JSON.stringify(result.vendor))); // Update with data from server
                setFormData(prev => ({ ...prev, vendorInfo: JSON.parse(JSON.stringify(result.vendor)) }));
                setIsEditingAutofilledVendor(false);
                if (fetchAndUpdateVendors) fetchAndUpdateVendors(); // Refresh global vendor list
                console.log("Vendor edits saved successfully.");
            } else {
                console.log(`Failed to save vendor edits: ${result.message || 'Unknown error'}`);
            }
        } catch (error) {
            console.error("Error saving vendor edits:", error);
            console.log(`Error saving vendor edits: ${error.message}`);
        }
    };

    const handleCreateNewVendorRecord = async () => {
        const currentVendorData = { ...formData.vendorInfo };
        // Remove 'id' to ensure a new record is created by the backend
        delete currentVendorData.id; 

        if (!currentVendorData.companyName) {
            console.log("Company name is required to create a new vendor record.");
            return;
        }

        try {
            const response = await fetch('/api/vendors', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(currentVendorData)
            });
            const result = await response.json();
            if (response.ok && result.status === 'success' && result.vendor) {
                const newVendorFromServer = result.vendor;
                setFormData(prev => ({ ...prev, vendorInfo: JSON.parse(JSON.stringify(newVendorFromServer)) }));
                setInitialVendorInfoAfterAutofill(JSON.parse(JSON.stringify(newVendorFromServer)));
                setIsAutofilledVendorActive(true); // Now it's an "autofilled" (newly created) record
                setIsEditingAutofilledVendor(false);
                if (fetchAndUpdateVendors) fetchAndUpdateVendors(); // Refresh global vendor list
                console.log(`New vendor "${newVendorFromServer.companyName}" created successfully with ID: ${newVendorFromServer.id}`);
            } else {
                console.log(`Failed to create new vendor record: ${result.message || 'Unknown error'}`);
            }
        } catch (error) {
            console.error("Error creating new vendor record:", error);
            console.log(`Error creating new vendor record: ${error.message}`);
        }
    };

    const handleClearAllVendorInputs = () => { // Renamed
        setFormData(prev => ({
            ...prev,
            vendorInfo: { companyName: '', contactName: '', email: '', phone: '', billingAddress: '', shippingAddress: '' }
        }));
        // If clearing inputs, it's no longer an "autofilled" scenario in its original sense for editing purposes.
        // However, if the user *then* types something identical to a known vendor, suggestions should still work.
        // The key is that `isEditingAutofilledVendor` should be false.
        setInitialVendorInfoAfterAutofill(null); // No specific "initial" state to compare against after clearing.
        setIsAutofilledVendorActive(false); // It's effectively a new entry or cleared state.
        setIsEditingAutofilledVendor(false);
    };

    return (
        <>
            {showUnsavedChangesModal && (
                <UnsavedChangesModal
                    onCancel={() => setShowUnsavedChangesModal(false)}
                    onDelete={() => {
                        setShowUnsavedChangesModal(false);
                        navigateTo('dashboard');
                    }}
                    onSaveAndClose={() => {
                        setShowUnsavedChangesModal(false);
                        handleSaveDraft();
                    }}
                />
            )}
            {/* EmailModal is now handled at the App level, triggered by setOrderForEmailModal prop */}
            <div className="mb-6"><button onClick={handleReturnToDashboard} className="text-orange-600 hover:text-orange-800 font-semibold">&larr; Back to Dashboard</button><h1 className="text-3xl font-bold text-slate-800 mt-2">{order ? `Order Details: ${order.id}` : 'New Purchase Order'}</h1>{order && <StatusBar status={formData.status} statusHistory={formData.statusHistory} />}</div>
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <div className="lg:col-span-2 space-y-6">
                    <div className="relative">
                        <div className={`bg-white p-6 rounded-lg shadow-sm border ${isEditingAutofilledVendor ? 'border-red-500 shadow-red-300/50 ring-2 ring-red-500' : 'border-slate-200'}`}>
                            <h2 className="text-xl font-semibold text-slate-700 border-b pb-3 mb-4">Vendor Information</h2>
                            {isEditingAutofilledVendor && (
                                <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md text-center">
                                    <p className="text-sm font-medium text-red-700">You are editing a vendor record.</p>
                                    <div className="mt-3 flex flex-wrap justify-center gap-2">
                                        <button onClick={handleCancelVendorEdit} className="px-3 py-1.5 text-xs bg-gray-500 text-white font-semibold rounded-md hover:bg-gray-600">Cancel</button>
                                        <button onClick={handleSaveVendorEdits} className="px-3 py-1.5 text-xs bg-green-600 text-white font-semibold rounded-md hover:bg-green-700">Save Edits</button>
                                        <button onClick={handleClearAllVendorInputs} className="px-3 py-1.5 text-xs bg-slate-500 text-white font-semibold rounded-md hover:bg-slate-600">Clear All Inputs</button>
                                        <button onClick={handleCreateNewVendorRecord} className="px-3 py-1.5 text-xs bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700">Create New Record</button>
                                    </div>
                                </div>
                            )}
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div className="space-y-4">
                                    <Input label="Company Name" value={formData.vendorInfo.companyName} onChange={e => handleVendorInfoChange('companyName', e.target.value)} disabled={!canEdit} onFocus={handleVendorInputFocus} onBlur={handleVendorInputBlur} />
                                    <Input label="Contact Name" value={formData.vendorInfo.contactName} onChange={e => handleVendorInfoChange('contactName', e.target.value)} disabled={!canEdit} onFocus={handleVendorInputFocus} onBlur={handleVendorInputBlur} />
                                    <Input label="Email" value={formData.vendorInfo.email} onChange={e => handleVendorInfoChange('email', e.target.value)} disabled={!canEdit} onFocus={handleVendorInputFocus} onBlur={handleVendorInputBlur} />
                                    <Input label="Phone" value={formData.vendorInfo.phone} onChange={e => handleVendorInfoChange('phone', e.target.value)} disabled={!canEdit} onFocus={handleVendorInputFocus} onBlur={handleVendorInputBlur} />
                                </div>
                                <div className="space-y-4">
                                    <Input label="Shipping Address" value={formData.vendorInfo.shippingAddress} onChange={e => handleVendorInfoChange('shippingAddress', e.target.value)} disabled={!canEdit} onFocus={handleVendorInputFocus} onBlur={handleVendorInputBlur} />
                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                        <Input label="City" value={formData.vendorInfo.shippingCity} onChange={e => handleVendorInfoChange('shippingCity', e.target.value)} disabled={!canEdit} onFocus={handleVendorInputFocus} onBlur={handleVendorInputBlur} />
                                        <Input label="State" value={formData.vendorInfo.shippingState} onChange={e => handleVendorInfoChange('shippingState', e.target.value)} disabled={!canEdit} onFocus={handleVendorInputFocus} onBlur={handleVendorInputBlur} />
                                        <Input label="Zip Code" value={formData.vendorInfo.shippingZipCode} onChange={e => handleVendorInfoChange('shippingZipCode', e.target.value)} disabled={!canEdit} onFocus={handleVendorInputFocus} onBlur={handleVendorInputBlur} />
                                    </div>
                                    <label className="block text-sm font-medium text-slate-600 pt-4">Billing Address</label>
                                    <div className="flex items-center">
                                        <input id="sameAsShipping" type="checkbox" checked={sameAsShipping} onChange={handleSameAsShippingChange} disabled={!canEdit} className="h-4 w-4 text-orange-600 border-slate-300 rounded focus:ring-orange-500 disabled:opacity-50" />
                                        <label htmlFor="sameAsShipping" className="ml-2 block text-sm text-slate-700">Same as Shipping Address</label>
                                    </div>
                                    {!sameAsShipping && (
                                        <div className="space-y-4">
                                            <Input label="Billing Address" value={formData.vendorInfo.billingAddress} onChange={e => handleVendorInfoChange('billingAddress', e.target.value)} disabled={!canEdit} onFocus={handleVendorInputFocus} onBlur={handleVendorInputBlur} />
                                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                                <Input label="City" value={formData.vendorInfo.billingCity} onChange={e => handleVendorInfoChange('billingCity', e.target.value)} disabled={!canEdit} onFocus={handleVendorInputFocus} onBlur={handleVendorInputBlur} />
                                                <Input label="State" value={formData.vendorInfo.billingState} onChange={e => handleVendorInfoChange('billingState', e.target.value)} disabled={!canEdit} onFocus={handleVendorInputFocus} onBlur={handleVendorInputBlur} />
                                                <Input label="Zip Code" value={formData.vendorInfo.billingZipCode} onChange={e => handleVendorInfoChange('billingZipCode', e.target.value)} disabled={!canEdit} onFocus={handleVendorInputFocus} onBlur={handleVendorInputBlur} />
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                        {vendorSuggestions.length > 0 && canEdit && isVendorInputActive && (
                            <div className="absolute z-10 w-full mt-1 bg-white border border-slate-300 rounded-lg shadow-lg">
                                <ul className="py-1 max-h-60 overflow-y-auto">
                                    {vendorSuggestions.map(vendor => (
                                        <li key={vendor.id} onClick={() => selectVendor(vendor)} className="px-4 py-2 hover:bg-orange-100 cursor-pointer">
                                            <p className="font-semibold text-slate-800">{vendor.companyName}</p>
                                            <p className="text-sm text-slate-500">{vendor.contactName} - {vendor.email}</p>
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        )}
                    </div>
                    <div className="bg-white rounded-lg shadow-sm border border-slate-200"><div className="p-6 border-b"><h2 className="text-xl font-semibold text-slate-700 mb-4">Line Items</h2>{canEdit && (<div className="flex gap-2"><input ref={scanInputRef} type="text" value={scanInput} onChange={e => setScanInput(e.target.value)} onKeyDown={e => { if (e.key === 'Enter') { handleScanAddItem(e); } }} placeholder="Scan or Enter Item Code" className="flex-grow block w-full px-3 py-2 bg-white border border-slate-300 rounded-md shadow-sm placeholder-slate-400 focus:outline-none focus:ring-orange-500 focus:border-orange-500 sm:text-sm" /><button onClick={handleScanAddItem} className="px-4 py-2 bg-orange-600 text-white font-semibold rounded-md hover:bg-orange-700 transition-colors">Add</button></div>)}</div><div className="overflow-x-auto"><table className="w-full text-sm text-left text-slate-500"><thead className="text-xs text-slate-700 uppercase bg-slate-100"><tr><th scope="col" className="px-4 py-3">Item</th><th scope="col" className="px-4 py-3">Style</th><th scope="col" className="px-4 py-3 text-center">Qty</th><th scope="col" className="px-4 py-3 text-right">Unit Price</th><th scope="col" className="px-4 py-3 text-right">Total</th>{canEdit && <th scope="col" className="px-2 py-3"></th>}</tr></thead><tbody>{formData.lineItems.map(item => (<tr key={item.id} className="border-b align-middle"><td className="px-4 py-2"><Select value={item.item} onChange={e => handleLineItemChange(item.id, 'item', e.target.value)} disabled={!canEdit}><option value="-- Select Item --">-- Select Item --</option>{Object.entries(allSelectableItems).map(([id, details]) => (<option key={id} value={id}>{details.name}</option>))}</Select></td><td className="px-4 py-2"><Select value={item.style} onChange={e => handleLineItemChange(item.id, 'style', e.target.value)} disabled={!canEdit}>{(allSelectableItems[item.item]?.styles || []).map(name => (<option key={name} value={name}>{name}</option>))}</Select></td><td className="px-4 py-2"><input type="number" min="0" value={item.quantity} onChange={e => handleLineItemChange(item.id, 'quantity', Number(e.target.value))} className="w-16 sm:w-20 text-center bg-white border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500 sm:text-sm p-2" disabled={!canEdit} /></td><td className="px-4 py-2 text-right"><PriceInput value={item.price} onChange={newPrice => handleLineItemChange(item.id, 'price', newPrice)} disabled={!canEdit}/></td><td className="px-4 py-2 text-right font-medium text-slate-800">${((item.quantity * item.price) / 100).toFixed(2)}</td>{canEdit && <td className="px-2 py-2 text-center"><button onClick={() => removeLineItem(item.id)} className="text-slate-400 hover:text-red-600 p-1 rounded-full hover:bg-red-100 transition-colors"><TrashIcon /></button></td>}</tr>))}</tbody></table></div>{canEdit && <div className="p-6 border-t"><button onClick={addEmptyLineItem} className="w-full text-center px-4 py-2 bg-orange-100 text-orange-700 font-semibold rounded-md hover:bg-orange-200 transition-colors">+ Add Line Item</button></div>}</div>
                </div>
                <div className="lg:col-span-1 space-y-6">
                    <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200"><h2 className="text-xl font-semibold text-slate-700 border-b pb-3 mb-4">Order Metadata</h2><div className="space-y-4"><Input label="Estimated Shipping Date" type="date" value={formData.estimatedShippingDate} onChange={e => setFormData(p=>({...p, estimatedShippingDate: e.target.value}))} disabled={!canEdit} /><ScentToggle value={formData.scentOption} onChange={val => setFormData(p=>({...p, scentOption: val}))} disabled={!canEdit} /><NameDropToggle value={formData.nameDrop} onChange={val => setFormData(p=>({...p, nameDrop: val}))} disabled={!canEdit} /></div></div>
                    {!isDraft && (<div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200"><h2 className="text-xl font-semibold text-slate-700 mb-4">Update Status</h2><div className="space-y-2"><button onClick={() => handleStatusChange('Paid')} disabled={formData.status !== 'Sent'} className="w-full text-center px-4 py-2 bg-blue-500 text-white font-semibold rounded-md hover:bg-blue-600 disabled:bg-slate-300 disabled:cursor-not-allowed">Mark as Paid</button><button onClick={() => handleStatusChange('Shipped')} disabled={formData.status !== 'Paid'} className="w-full text-center px-4 py-2 bg-green-500 text-white font-semibold rounded-md hover:bg-green-600 disabled:bg-slate-300 disabled:cursor-not-allowed">Mark as Shipped</button></div></div>)}
                    <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h2 className="text-xl font-semibold text-slate-700 mb-3 border-b pb-3">Signature</h2>
                        <SignaturePad 
                            initialDataUrl={formData.signatureDataUrl}
                            onSave={(dataUrl) => setFormData(prev => ({...prev, signatureDataUrl: dataUrl}))}
                            disabled={!canEdit}
                        />
                    </div>
                    <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200"><h2 className="text-xl font-semibold text-slate-700 mb-3">Notes</h2><Textarea value={formData.notes} onChange={e => setFormData(p => ({...p, notes: e.target.value}))} rows={4} disabled={!canEdit} /></div>
                    <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h2 className="text-xl font-semibold text-slate-700 mb-4">Order Summary</h2>
                        <div className="space-y-3">
                            <div className="flex justify-between items-center text-slate-600"><span>Subtotal</span><span className="font-medium">${(orderTotals.subtotal / 100).toFixed(2)}</span></div>
                            {orderTotals.nameDropSurcharge > 0 && (
                                <div className="flex justify-between items-center text-slate-600">
                                    <span>Name Drop Surcharge ({orderTotals.crossItemCount} crosses)</span>
                                    <span className="font-medium">${(orderTotals.nameDropSurcharge / 100).toFixed(2)}</span>
                                </div>
                            )}
                            {orderTotals.estimatedShipping > 0 && (
                                <div className="flex justify-between items-center text-slate-600">
                                    <span>Est. Shipping</span>
                                    <span className="font-medium">${orderTotals.estimatedShipping.toFixed(2)}</span>
                                </div>
                            )}
                            <div className="flex justify-between items-center font-bold text-xl text-slate-800"><span>Total</span><span>${(orderTotals.total / 100).toFixed(2)}</span></div>
                        </div>
                    </div>
                    <div className="space-y-3">
                        {isDraft && <button onClick={handleSaveAndSend} className="w-full text-center px-6 py-3 bg-orange-600 text-white font-bold rounded-md hover:bg-orange-700">Save and Send</button>}
                        {!isDraft && !isEditing && <button onClick={() => setOrderForEmailModal(formData)} className="w-full text-center px-6 py-3 bg-orange-600 text-white font-bold rounded-md hover:bg-orange-700">Resend Email</button>}
                        {isDraft && <button onClick={handleSaveDraft} className="w-full text-center px-6 py-3 bg-slate-600 text-white font-bold rounded-md hover:bg-slate-700">Save as Draft</button>}
                        {isEditing && !isDraft && <button onClick={() => {saveOrder(createOrderObject()); setIsEditing(false);}} className="w-full text-center px-6 py-3 bg-slate-600 text-white font-bold rounded-md hover:bg-slate-700">Save Changes</button>}
                        <button onClick={handlePreviewPdf} className="w-full text-center px-6 py-3 bg-white text-slate-700 font-bold rounded-md hover:bg-slate-100 border border-slate-300">Preview PDF</button>
                        {!isDraft && !isEditing && <button onClick={() => setIsEditing(true)} className="w-full text-center px-6 py-3 bg-blue-100 text-blue-700 font-bold rounded-md hover:bg-blue-200">Edit Order</button>}
                        {/* Always show delete button if order exists (formData.id) */}
                        {formData.id && (
                            <button 
                                onClick={handleDelete} 
                                className="w-full text-center px-6 py-3 bg-red-100 text-red-700 font-bold rounded-md hover:bg-red-200"
                            >
                                {isDraft ? "Delete Draft" : "Delete Order"}
                            </button>
                        )}
                    </div>
                </div>
            </div>
        </>
    );
};

// --- MAIN APP COMPONENT (Router) ---
const App = () => {
    const { useState, useEffect } = React;
    const [page, setPage] = useState('dashboard');
    const [orders, setOrders] = useState([]);
    const [activeOrder, setActiveOrder] = useState(null);
    const [isLoading, setIsLoading] = useState(true);
    const [allVendors, setAllVendors] = useState([]);
    const [allSelectableItems, setAllSelectableItems] = useState({});
    const [itemData, setItemData] = useState({});
    const [packageData, setPackageData] = useState({});
    const [orderForEmailModal, setOrderForEmailModal] = useState(null); // State to control EmailModal
    const [showSettingsMenu, setShowSettingsMenu] = useState(false);
    const [appSettings, setAppSettings] = useState({ company_name: "Your Company", default_email_body: "" }); // Added appSettings

    const handleOrderUpdate = (updatedOrderFromServer) => { // Added this function
        setOrders(prevOrders => {
            const index = prevOrders.findIndex(o => o.id === updatedOrderFromServer.id);
            if (index !== -1) {
                const updatedOrders = [...prevOrders];
                updatedOrders[index] = updatedOrderFromServer;
                return updatedOrders;
            }
            // Fallback for safety, though email update should always find the order
            console.warn("Order to update from email not found in existing orders list.");
            return [...prevOrders.filter(o => o.id !== updatedOrderFromServer.id), updatedOrderFromServer];
        });
    };

    const fetchAndUpdateVendors = async () => {
        try {
            const vendorsRes = await fetch('/api/vendors');
            const vendorsData = await vendorsRes.json();
            setAllVendors(vendorsData);
        } catch (error) {
            console.error("Failed to re-fetch vendors:", error);
        }
    };

    useEffect(() => {
        const fetchData = async () => {
            setIsLoading(true);
            try {
            const [ordersRes, vendorsRes, itemsRes, packagesRes, settingsRes] = await Promise.all([
                fetch('/api/orders'),
                fetch('/api/vendors'),
                fetch('/api/items'),
                fetch('/api/packages'),
                fetch('/api/settings') // Fetch settings
            ]);

            const ordersData   = await ordersRes.json();
            const settingsData = await settingsRes.json(); // Get settings data
            setAppSettings(settingsData); // Set app settings
            const vendorsData  = await vendorsRes.json();
            const itemsDataArray    = await itemsRes.json(); // Renamed to itemsDataArray
            const packagesData = await packagesRes.json();

            // Transform itemsDataArray to an object keyed by item_code
            const itemsDataById = itemsDataArray.reduce((acc, item) => {
                acc[item.item_code] = item; // Use item_code as the key
                return acc;
            }, {});

            setOrders(ordersData);
            setAllVendors(vendorsData);
            // Combine items (now itemsDataById) and packages for the dropdown
            const combinedSelectableItems = { ...itemsDataById }; // Spread the object
            for (const pkgId in packagesData) {
                combinedSelectableItems[pkgId] = { 
                    name: packagesData[pkgId].name, 
                    type: packagesData[pkgId].type, 
                    styles: [] // Packages don't have styles in the same way items do
                };
            }
            setAllSelectableItems(combinedSelectableItems);
            setItemData(itemsDataById); // Store the object version
            setPackageData(packagesData); // Store raw packages data
            } catch (error) {
            console.error("Failed to fetch data:", error);
            } finally {
            setIsLoading(false);
            }
        };
        fetchData();
    }, []);

    
    const navigateTo = (pageName) => { setPage(pageName); };
    
    const saveOrder = async (orderToSave) => {
        try {
            const response = await fetch('/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderToSave)
            });
            const result = await response.json();
            if (result.status === 'success' && result.order) {
                const savedOrderFromServer = result.order;
                setOrders(prevOrders => {
                    const index = prevOrders.findIndex(o => o.id === savedOrderFromServer.id);
                    if (index !== -1) {
                        // Update existing order
                        const updatedOrders = [...prevOrders];
                        updatedOrders[index] = savedOrderFromServer;
                        return updatedOrders;
                    } else {
                        // Add new order
                        return [savedOrderFromServer, ...prevOrders.filter(o => o.id !== savedOrderFromServer.id)];
                    }
                });
            } else {
                console.error("Failed to save order - server response:", result.message || "Unknown server error");
                throw new Error(result.message || "Failed to save order on server.");
            }
        } catch (error) {
            console.error("Failed to save order - network/fetch error:", error);
            throw error; // Re-throw to be caught by caller
        }
    };
    
    const deleteOrder = async (orderId, deletePayload) => { // deletePayload now comes from handleDelete
        const orderToDelete = orders.find(o => o.id === orderId);
        if (!orderToDelete) {
            console.warn("Order not found for deletion:", orderId);
            throw new Error("Order not found locally. Cannot proceed with deletion.");
        }

        // The deletePayload already has status: "Deleted" and potentially deleteConfirmation
        // It also includes the latest statusHistory from the form's state.
        // We just need to ensure the statusHistory is correctly updated if not already done by createOrderObject logic
        const finalPayload = {
            ...deletePayload, // This comes from handleDelete, based on formData
            status: "Deleted", // Ensure it's set
            statusHistory: [
                ...(deletePayload.statusHistory || orderToDelete.statusHistory || []), // Use payload's history, fallback to existing
                { status: "Deleted", date: new Date().toISOString() }
            ].filter((item, index, self) => // Deduplicate status history just in case
                index === self.findIndex((t) => (
                    t.status === item.status && new Date(t.date).getTime() === new Date(item.date).getTime()
                )) || item.status !== "Deleted" // Keep all non-deleted, allow multiple "Deleted" if dates differ (though unlikely here)
            )
        };
         // Ensure the last entry for "Deleted" is the most recent one if multiple somehow exist
        const deletedEntries = finalPayload.statusHistory.filter(h => h.status === "Deleted");
        if (deletedEntries.length > 1) {
            const latestDeletedEntry = deletedEntries.reduce((latest, current) => 
                new Date(current.date) > new Date(latest.date) ? current : latest
            );
            finalPayload.statusHistory = [
                ...finalPayload.statusHistory.filter(h => h.status !== "Deleted"),
                latestDeletedEntry
            ];
        }


        // saveOrder will handle the API call and local state update
        // It expects the full order object to save/update.
        await saveOrder(finalPayload); 
    };
    
    const viewOrder = (order) => { setActiveOrder(order); navigateTo('viewOrder'); };
    
    if (isLoading) {
        return <div className="text-center p-8">Loading...</div>;
    }

    const renderPage = () => {
        switch(page) {
            case 'createOrder': return <OrderForm navigateTo={navigateTo} saveOrder={saveOrder} allVendors={allVendors} allSelectableItems={allSelectableItems} itemData={itemData} packageData={packageData} fetchAndUpdateVendors={fetchAndUpdateVendors} setOrderForEmailModal={setOrderForEmailModal} />;
            case 'viewOrder': return <OrderForm order={activeOrder} navigateTo={navigateTo} saveOrder={saveOrder} deleteOrder={deleteOrder} allVendors={allVendors} allSelectableItems={allSelectableItems} itemData={itemData} packageData={packageData} fetchAndUpdateVendors={fetchAndUpdateVendors} setOrderForEmailModal={setOrderForEmailModal} />;
            case 'settings': return <iframe src="/settings" style={{ width: '100%', height: 'calc(100vh - 100px)', border: 'none' }}></iframe>;
            case 'dashboard': default: return <Dashboard orders={orders} navigateTo={navigateTo} viewOrder={viewOrder} allVendors={allVendors} allSelectableItems={allSelectableItems} setOrderForEmailModal={setOrderForEmailModal} />;
        }
    }

    const handleLogout = async () => {
        try {
            const response = await fetch('/shutdown', { method: 'POST' });
            if (response.ok) {
                // Server acknowledged shutdown, update page content
                document.body.innerHTML = '<div style="text-align: center; padding: 50px; font-family: sans-serif; font-size: 1.2em; color: #333;">Application has been shut down. You can now close this tab.</div>';
                // No automatic window.close() as it's unreliable and can be blocked.
            } else {
                // Server responded, but not with success (e.g., 500 error if shutdown endpoint failed before responding)
                alert('Failed to send shutdown signal to the server (server responded with an error). Please close the tab manually.');
            }
        } catch (error) {
            // Network error or server completely unreachable (possibly already shut down)
            console.error('Error during shutdown attempt:', error);
            alert('Error attempting to shut down the server. Please use Task Manager to stop the task.');
        }
    };

    return (
        <div className="bg-slate-50 min-h-screen font-sans">
            {orderForEmailModal && (
                <EmailModal
                    order={orderForEmailModal}
                    allItems={allSelectableItems}
                    appSettings={appSettings} // Pass appSettings
                    saveOrder={saveOrder}
                    onClose={() => setOrderForEmailModal(null)}
                    onOrderUpdatedAfterEmail={handleOrderUpdate} // Pass the new handler
                    onEmailClientOpened={() => {
                        setOrderForEmailModal(null);
                        navigateTo('dashboard'); 
                    }}
                />
            )}
            <div className="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
                {renderPage()}
            </div>
            {/* New Settings/Logout Button - Conditionally render based on page */}
            {page !== 'settings' && (
            <div className="fixed bottom-4 left-4 z-50">
                <button
                    onClick={() => setShowSettingsMenu(!showSettingsMenu)}
                    className="p-3 bg-slate-600 text-white rounded-full shadow-lg hover:bg-slate-700 transition-colors focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-75"
                    aria-label="Settings"
                >
                    <CogIcon />
                </button>
                {showSettingsMenu && (
                    <div 
                        className="absolute bottom-full left-0 mb-2 w-48 bg-white rounded-md shadow-lg py-1 ring-1 ring-black ring-opacity-5 focus:outline-none"
                        role="menu"
                        aria-orientation="vertical"
                        aria-labelledby="options-menu"
                    >
                        <a
                            href="#"
                            onClick={(e) => {
                                e.preventDefault();
                                navigateTo('settings');
                                setShowSettingsMenu(false);
                            }}
                            className="block px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 hover:text-slate-900"
                            role="menuitem"
                        >
                            Settings
                        </a>
                        <button
                            onClick={() => {
                                handleLogout();
                                setShowSettingsMenu(false);
                            }}
                            className="block w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 hover:text-slate-900"
                            role="menuitem"
                        >
                            Log Out
                        </button>
                    </div>
                )}
            </div>
            )}
        </div>
    );
};

const container = document.getElementById('root');
const root = ReactDOM.createRoot(container);
root.render(<App />);
</script>
    {% endraw %}
</body>
</html>
