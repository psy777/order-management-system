<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FireNotes DM</title>
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="/assets/css/styles.css">
    <link rel="stylesheet" href="/assets/css/firenotes_chat.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel" src="/assets/js/record_mentions.jsx"></script>
</head>
<body class="bg-slate-50 min-h-screen font-sans firenotes-chat">
    <a class="fc-screen-reader-only" href="#fc-chat-log">Skip to chat</a>
    <nav class="bg-slate-900 text-white shadow">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex h-16 items-center justify-between">
                <div class="flex items-center space-x-10">
                    <a id="nav-home-link" href="/dashboard" class="text-lg font-semibold tracking-wide" aria-label="Return to dashboard">FireNotes OMS</a>
                    <div class="hidden md:flex items-center space-x-6 text-sm font-medium">
                        <a href="/orders" class="hover:text-orange-300 transition">Orders</a>
                        <a href="/contacts" class="hover:text-orange-300 transition">Contacts</a>
                        <a href="/analytics" class="hover:text-orange-300 transition">Analytics</a>
                        <a href="/reminders" class="hover:text-orange-300 transition">Reminders</a>
                        <a href="/calendar" class="hover:text-orange-300 transition">Calendar</a>
                        <a href="/passwords" class="hover:text-orange-300 transition">Password Manager</a>
                        <a href="/firenotes" class="text-orange-300">FireNotes Chat</a>
                    </div>
                </div>
                <div class="flex items-center space-x-3 text-sm font-medium">
                    <a href="/settings" class="hover:text-orange-300 transition">Settings</a>
                    <a id="nav-log-out" href="#" class="hover:text-orange-300 transition">Log Out</a>
                </div>
            </div>
        </div>
    </nav>

    <main class="py-8">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div class="fc-chat-layout">
            <aside class="fc-notes" aria-label="Notes">
                <div class="fc-notes__search">
                    <label class="fc-screen-reader-only" for="fc-note-search">Search or create note</label>
                    <div class="fc-notes__search-row">
                        <input id="fc-note-search" class="fc-notes__search-input" type="search" placeholder="Search or create note" autocomplete="off">
                        <button type="button" id="fc-create-note" class="fc-notes__create-button" aria-label="Create a new note">
                            <span class="fc-notes__create-icon" aria-hidden="true">＋</span>
                            <span class="fc-notes__create-label">New</span>
                        </button>
                    </div>
                </div>
                <div id="fc-note-list" class="fc-notes__list" role="listbox" aria-label="Saved notes"></div>
                <p id="fc-no-notes" class="fc-notes__empty" hidden></p>
            </aside>
            <section class="fc-chat-panel" aria-label="Note conversation">
                <header class="fc-chat-panel__header">
                    <div class="fc-chat-panel__title-group">
                        <h1 id="fc-note-title" class="fc-chat-panel__title">Untitled note</h1>
                        <button type="button" id="fc-note-handle" class="fc-note-handle" hidden></button>
                    </div>
                    <div class="fc-chat-panel__actions">
                        <label class="fc-screen-reader-only" for="fc-message-search">Search this note</label>
                        <input id="fc-message-search" class="fc-chat-search" type="search" placeholder="Search this note" autocomplete="off">
                        <button type="button" id="fc-refresh" class="fc-icon-button" aria-label="Refresh note">
                            <span aria-hidden="true">↺</span>
                        </button>
                        <button type="button" id="fc-delete-note" class="fc-icon-button fc-icon-button--danger" aria-label="Delete note">
                            <span aria-hidden="true">🗑</span>
                        </button>
                    </div>
                </header>
                <div class="fc-chat-panel__body">
                    <div id="fc-chat-log" class="fc-chat-log" role="log" aria-live="polite" aria-busy="false"></div>
                </div>
                <footer class="fc-chat-panel__footer">
                    <p id="fc-error" class="fc-chat-error" role="status" aria-live="assertive" hidden></p>
                    <div class="fc-composer" data-disabled="true">
                        <div id="fc-attachment-chips" class="fc-composer__attachments" aria-live="polite"></div>
                        <label class="fc-screen-reader-only" for="fc-input">Write a message</label>
                        <div class="fc-composer__input-wrapper">
                            <textarea id="fc-input" class="fc-composer__input" placeholder="Write a message" rows="1" disabled></textarea>
                            <div id="fc-mention-root" class="fc-composer__mention-root" hidden></div>
                        </div>
                        <div class="fc-composer__actions">
                            <input type="file" id="fc-attachment-input" class="fc-composer__file-input" multiple hidden>
                            <button type="button" id="fc-attach-button" class="fc-icon-button" aria-label="Add files" disabled>
                                <span aria-hidden="true">＋</span>
                            </button>
                        </div>
                    </div>
                </footer>
            </section>
        </div>
        </div>
    </main>

    <script>
        (function () {
            const logoutLink = document.getElementById('nav-log-out');
            const brandLink = document.getElementById('nav-home-link');
            if (brandLink) {
                brandLink.addEventListener('click', (event) => {
                    event.preventDefault();
                    window.location.href = '/dashboard';
                });
            }
            if (logoutLink) {
                logoutLink.addEventListener('click', async (event) => {
                    event.preventDefault();
                    if (window.fireCoastLogout) {
                        window.fireCoastLogout();
                        return;
                    }
                    try {
                        const response = await fetch('/shutdown', { method: 'POST' });
                        if (response.ok) {
                            document.body.innerHTML = '<div class="min-h-screen flex items-center justify-center text-slate-700 text-lg">Application has been shut down. You can now close this tab.</div>';
                        } else {
                            alert('Failed to log out.');
                        }
                    } catch (error) {
                        console.error('Error logging out:', error);
                        alert('Error attempting to log out.');
                    }
                });
            }
        })();
    </script>

    <script>
        (function () {
            const notesListEl = document.getElementById('fc-note-list');
            const noteSearchEl = document.getElementById('fc-note-search');
            const createNoteButton = document.getElementById('fc-create-note');
            const noteEmptyEl = document.getElementById('fc-no-notes');
            const noteTitleEl = document.getElementById('fc-note-title');
            const noteHandleButton = document.getElementById('fc-note-handle');
            const chatLogEl = document.getElementById('fc-chat-log');
            const messageSearchEl = document.getElementById('fc-message-search');
            const refreshButton = document.getElementById('fc-refresh');
            const deleteButton = document.getElementById('fc-delete-note');
            const inputEl = document.getElementById('fc-input');
            const attachmentInputEl = document.getElementById('fc-attachment-input');
            const attachmentButtonEl = document.getElementById('fc-attach-button');
            const attachmentChipsEl = document.getElementById('fc-attachment-chips');
            const composerEl = document.querySelector('.fc-composer');
            const mentionRootEl = document.getElementById('fc-mention-root');
            const errorEl = document.getElementById('fc-error');

            const state = {
                notes: [],
                messages: [],
                activeNoteId: '',
                activeNote: null,
                noteSearch: '',
                messageSearch: '',
                isLoadingNotes: false,
                isLoadingMessages: false,
                isSending: false,
                pendingFiles: [],
                error: null,
                composerValue: '',
                composerDisabled: true,
                recentReactions: REACTION_OPTIONS.slice(0, QUICK_REACTIONS_LIMIT),
                activeMessageEdit: null,
                pendingMessageAction: null,
            };
            const pendingReactions = new Set();
            let activePopover = null;

            const handlePopoverDocumentClick = (event) => {
                if (!activePopover) {
                    return;
                }
                const { element, anchor } = activePopover;
                if (element && element.contains(event.target)) {
                    return;
                }
                if (anchor && anchor.contains(event.target)) {
                    return;
                }
                closeActivePopover();
            };

            const closeActivePopover = () => {
                if (!activePopover) {
                    return;
                }
                const { element, cleanup } = activePopover;
                if (typeof cleanup === 'function') {
                    try {
                        cleanup();
                    } catch (error) {
                        console.debug('Popover cleanup failed', error);
                    }
                }
                if (element && element.parentNode) {
                    element.parentNode.removeChild(element);
                }
                document.removeEventListener('mousedown', handlePopoverDocumentClick, true);
                window.removeEventListener('resize', closeActivePopover);
                window.removeEventListener('scroll', closeActivePopover, true);
                activePopover = null;
            };

            const openPopover = (anchor, buildContent, options = {}) => {
                if (typeof buildContent !== 'function') {
                    return null;
                }
                closeActivePopover();
                const popover = document.createElement('div');
                popover.className = 'fc-popover';
                popover.style.visibility = 'hidden';
                const content = buildContent(popover);
                if (content instanceof Node) {
                    popover.appendChild(content);
                }
                document.body.appendChild(popover);
                const rect = anchor.getBoundingClientRect();
                const offsetY = Number.isFinite(options.offsetY) ? options.offsetY : 8;
                const offsetX = Number.isFinite(options.offsetX) ? options.offsetX : 0;
                const width = popover.offsetWidth;
                const height = popover.offsetHeight;
                let top = rect.bottom + offsetY + window.scrollY;
                let left = rect.right - width + offsetX + window.scrollX;
                if (left < 8) {
                    left = rect.left + window.scrollX;
                }
                const viewportBottom = window.scrollY + window.innerHeight;
                if (top + height > viewportBottom && rect.top - height - offsetY > 0) {
                    top = rect.top - height - offsetY + window.scrollY;
                }
                popover.style.top = `${Math.max(0, top)}px`;
                popover.style.left = `${Math.max(8, left)}px`;
                popover.style.visibility = 'visible';
                activePopover = {
                    element: popover,
                    anchor,
                    cleanup: options.onClose,
                };
                setTimeout(() => {
                    document.addEventListener('mousedown', handlePopoverDocumentClick, true);
                    window.addEventListener('resize', closeActivePopover);
                    window.addEventListener('scroll', closeActivePopover, true);
                }, 0);
                return popover;
            };
            const API_BASE = '/api/firenotes';
            const REACTION_ENDPOINT = `${API_BASE}/chat/reactions`;
            const MESSAGE_ENDPOINT = `${API_BASE}/chat/messages`;
            const FORWARD_ENDPOINT = `${API_BASE}/chat/forward`;
            const REACTION_OPTIONS = ['👍', '✅', '🔥', '🎉', '❗'];
            const QUICK_REACTIONS_LIMIT = 3;

            const MAX_COMPOSER_HEIGHT = 220;
            let autoCreatingNote = false;
            const mentionEntityTypes = null;

            let handleCopyResetTimer = null;
            const activeMentionTextRoots = [];

            const scheduleFrame = (callback) => {
                if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
                    window.requestAnimationFrame(callback);
                } else {
                    window.setTimeout(callback, 16);
                }
            };

            const mentionComposer = {
                useMentionComponent: false,
                root: null,
                textareaComponent: null,
                textComponent: null,
                renderScheduled: false,
            };

            const cleanupMentionTextRoots = () => {
                while (activeMentionTextRoots.length) {
                    const root = activeMentionTextRoots.pop();
                    try {
                        root.unmount();
                    } catch (error) {
                        console.debug('Failed to unmount mention renderer', error);
                    }
                }
            };

            const getActiveTextarea = () => {
                if (mentionComposer.useMentionComponent && mentionRootEl) {
                    return mentionRootEl.querySelector('textarea');
                }
                return inputEl;
            };

            const renderMentionComposer = () => {
                if (!mentionComposer.useMentionComponent || !mentionComposer.root || !mentionComposer.textareaComponent) {
                    return;
                }
                mentionComposer.renderScheduled = false;
                mentionComposer.root.render(
                    window.React.createElement(mentionComposer.textareaComponent, {
                        value: state.composerValue,
                        onChange: (value) => {
                            setComposerValue(value);
                        },
                        onSubmit: (value) => {
                            sendMessage(value);
                        },
                        disabled: state.composerDisabled,
                        rows: 1,
                        placeholder: 'Write a message',
                        entityTypes: mentionEntityTypes,
                        className: 'fc-composer__mention',
                        textareaClassName: 'fc-composer__mention-input',
                    })
                );
                scheduleFrame(() => {
                    autoResizeInput();
                });
            };

            const scheduleMentionComposerRender = (options = {}) => {
                if (!mentionComposer.useMentionComponent || !mentionComposer.root) {
                    return;
                }
                const immediate = Boolean(options.immediate);
                if (immediate) {
                    mentionComposer.renderScheduled = false;
                    renderMentionComposer();
                    return;
                }
                if (mentionComposer.renderScheduled) {
                    return;
                }
                mentionComposer.renderScheduled = true;
                scheduleFrame(() => {
                    renderMentionComposer();
                });
            };

            const ensureMentionComposer = (attempt = 0) => {
                if (!mentionRootEl || mentionComposer.useMentionComponent) {
                    return;
                }
                const components = window.RecordMentionComponents || {};
                if (
                    components.RecordMentionTextarea &&
                    components.RecordMentionText &&
                    window.React &&
                    window.ReactDOM &&
                    typeof window.ReactDOM.createRoot === 'function'
                ) {
                    mentionComposer.useMentionComponent = true;
                    mentionComposer.textareaComponent = components.RecordMentionTextarea;
                    mentionComposer.textComponent = components.RecordMentionText;
                    mentionComposer.root = window.ReactDOM.createRoot(mentionRootEl);
                    mentionRootEl.hidden = false;
                    mentionRootEl.setAttribute('data-ready', 'true');
                    if (inputEl) {
                        inputEl.hidden = true;
                    }
                    renderMentionComposer();
                    renderMessages();
                    return;
                }
                if (attempt < 40) {
                    window.setTimeout(() => ensureMentionComposer(attempt + 1), 150);
                }
            };

            const refreshMentionHandles = () => {
                if (!mentionComposer.useMentionComponent || !mentionComposer.root || !mentionRootEl) {
                    return;
                }
                try {
                    mentionComposer.root.unmount();
                } catch (error) {
                    console.debug('Failed to refresh mention composer', error);
                }
                mentionComposer.root = window.ReactDOM.createRoot(mentionRootEl);
                renderMentionComposer();
            };

            const getComposerValue = () => {
                if (mentionComposer.useMentionComponent) {
                    return state.composerValue || '';
                }
                return inputEl ? inputEl.value || '' : '';
            };

            function setComposerValue(value, options = {}) {
                const next = value === null || value === undefined ? '' : String(value);
                const forceRender = Boolean(options.forceRender);
                const immediate = Boolean(options.immediate);
                const previous = state.composerValue;
                const hasChanged = previous !== next;
                state.composerValue = next;
                if (mentionComposer.useMentionComponent) {
                    if (mentionComposer.root && (hasChanged || forceRender)) {
                        scheduleMentionComposerRender({ immediate });
                    } else if (forceRender) {
                        scheduleMentionComposerRender({ immediate });
                    }
                } else if (inputEl) {
                    inputEl.value = next;
                }
                if (!options.skipResize) {
                    scheduleFrame(() => {
                        autoResizeInput();
                    });
                }
            }

            const normalizePreview = (value) => {
                if (value === null || value === undefined) {
                    return '';
                }
                return String(value).replace(/\s+/g, ' ').trim();
            };

            const formatTimestamp = (value, withTime = true) => {
                if (!value) {
                    return '';
                }
                const date = new Date(value);
                if (Number.isNaN(date.getTime())) {
                    return '';
                }
                const options = withTime
                    ? { year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' }
                    : { year: 'numeric', month: 'short', day: 'numeric' };
                return new Intl.DateTimeFormat(undefined, options).format(date);
            };

            const formatEventWindow = (event) => {
                if (!event || !event.start_at) {
                    return '';
                }
                const start = new Date(event.start_at);
                const end = new Date(event.end_at || event.start_at);
                if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
                    return formatTimestamp(event.start_at, !event.all_day);
                }
                const sameDay = start.toDateString() === end.toDateString();
                if (event.all_day || (start.getHours() === 0 && start.getMinutes() === 0 && sameDay)) {
                    return sameDay
                        ? formatTimestamp(start.toISOString(), false)
                        : `${formatTimestamp(start.toISOString(), false)} – ${formatTimestamp(end.toISOString(), false)}`;
                }
                if (sameDay) {
                    const timeFormatter = new Intl.DateTimeFormat(undefined, {
                        hour: 'numeric',
                        minute: '2-digit',
                    });
                    return `${formatTimestamp(start.toISOString(), true)} – ${timeFormatter.format(end)}`;
                }
                return `${formatTimestamp(start.toISOString(), true)} – ${formatTimestamp(end.toISOString(), true)}`;
            };

            const setBusy = (value) => {
                if (!chatLogEl) {
                    return;
                }
                chatLogEl.setAttribute('aria-busy', value ? 'true' : 'false');
            };

            const showError = (message) => {
                state.error = message;
                if (!errorEl) {
                    return;
                }
                if (message) {
                    errorEl.hidden = false;
                    errorEl.textContent = message;
                } else {
                    errorEl.hidden = true;
                    errorEl.textContent = '';
                }
            };

            const clearError = () => showError('');

            const updateNoteHandleButton = (handle) => {
                if (!noteHandleButton) {
                    return;
                }
                window.clearTimeout(handleCopyResetTimer);
                handleCopyResetTimer = null;
                if (!handle) {
                    noteHandleButton.hidden = true;
                    noteHandleButton.dataset.handle = '';
                    noteHandleButton.textContent = '';
                    noteHandleButton.classList.remove('is-copied');
                    noteHandleButton.disabled = true;
                    noteHandleButton.title = '';
                    return;
                }
                noteHandleButton.hidden = false;
                noteHandleButton.disabled = false;
                noteHandleButton.dataset.handle = handle;
                noteHandleButton.textContent = handle;
                noteHandleButton.classList.remove('is-copied');
                noteHandleButton.title = 'Copy note handle';
            };

            const renderNoteTitle = (note) => {
                if (!noteTitleEl) {
                    return;
                }
                if (!note) {
                    noteTitleEl.textContent = 'Untitled note';
                    noteTitleEl.title = 'Select a note to view messages';
                    noteTitleEl.removeAttribute('data-handle');
                    updateNoteHandleButton('');
                    return;
                }
                const label = normalizePreview(note.title || '') || 'Untitled note';
                const handle = note.handle ? `@${note.handle}` : '';
                noteTitleEl.textContent = label;
                noteTitleEl.title = handle ? `${label} (${handle})` : label;
                if (handle) {
                    noteTitleEl.setAttribute('data-handle', handle);
                } else {
                    noteTitleEl.removeAttribute('data-handle');
                }
                updateNoteHandleButton(handle);
            };

            const sortNotes = () => {
                state.notes.sort((a, b) => {
                    const left = new Date(a.updated_at || a.last_message_at || a.created_at || 0).getTime();
                    const right = new Date(b.updated_at || b.last_message_at || b.created_at || 0).getTime();
                    return right - left;
                });
            };

            const matchesNoteSearch = (note, query) => {
                if (!query) {
                    return true;
                }
                const lowered = query.toLowerCase();
                const fields = [note.title, note.handle, note.last_message_preview];
                return fields.some((field) => normalizePreview(field || '').toLowerCase().includes(lowered));
            };

            const renderNotes = () => {
                if (!notesListEl) {
                    return;
                }
                const trimmedQuery = normalizePreview(state.noteSearch || '');
                const loweredQuery = trimmedQuery.toLowerCase();
                notesListEl.innerHTML = '';
                sortNotes();
                const filtered = loweredQuery
                    ? state.notes.filter((note) => matchesNoteSearch(note, loweredQuery))
                    : state.notes.slice();

                const hasQuery = Boolean(trimmedQuery);
                const exactMatch = hasQuery
                    ? state.notes.some((note) => normalizePreview(note.title || '').toLowerCase() === loweredQuery)
                    : false;
                const createSuggestion = hasQuery && !exactMatch;

                if (!filtered.length && !createSuggestion) {
                    if (noteEmptyEl) {
                        noteEmptyEl.hidden = false;
                        noteEmptyEl.textContent = trimmedQuery
                            ? `No notes match "${trimmedQuery}". Press Enter or click New to create it.`
                            : 'Click "New" to create your first note.';
                    }
                    return;
                }

                if (noteEmptyEl) {
                    if (createSuggestion && !filtered.length) {
                        noteEmptyEl.hidden = false;
                        noteEmptyEl.textContent = `Press Enter or click below to create "${trimmedQuery}".`;
                    } else {
                        noteEmptyEl.hidden = true;
                        noteEmptyEl.textContent = '';
                    }
                }

                const fragment = document.createDocumentFragment();

                if (createSuggestion) {
                    const createButton = document.createElement('button');
                    createButton.type = 'button';
                    createButton.className = 'fc-note fc-note--create';
                    createButton.setAttribute('data-create-note', trimmedQuery);

                    const title = document.createElement('div');
                    title.className = 'fc-note__title';
                    title.textContent = `Create "${trimmedQuery}"`;

                    const hint = document.createElement('div');
                    hint.className = 'fc-note__preview';
                    hint.textContent = 'Start a fresh note with this title.';

                    createButton.appendChild(title);
                    createButton.appendChild(hint);
                    createButton.addEventListener('click', async () => {
                        try {
                            const note = await createNote(trimmedQuery);
                            if (noteSearchEl) {
                                noteSearchEl.value = '';
                            }
                            state.noteSearch = '';
                            renderNotes();
                            if (note) {
                                await selectNote(note.id, { focusComposer: true });
                            }
                        } catch (error) {
                            console.error('Failed to create note', error);
                            showError('Unable to create that note.');
                        }
                    });
                    fragment.appendChild(createButton);
                }

                filtered.forEach((note) => {
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = 'fc-note' + (note.id === state.activeNoteId ? ' fc-note--active' : '');
                    button.setAttribute('data-note-id', note.id);
                    button.setAttribute('role', 'option');
                    button.setAttribute('aria-selected', note.id === state.activeNoteId ? 'true' : 'false');

                    const title = document.createElement('div');
                    title.className = 'fc-note__title';
                    title.textContent = note.title;

                    const preview = document.createElement('div');
                    preview.className = 'fc-note__preview';
                    const previewText = normalizePreview(note.last_message_preview || '');
                    preview.textContent = previewText.length > 90 ? `${previewText.slice(0, 87)}…` : previewText;

                    const meta = document.createElement('div');
                    meta.className = 'fc-note__meta';
                    if (note.handle) {
                        const handle = document.createElement('span');
                        handle.className = 'fc-note__handle';
                        handle.textContent = `@${note.handle}`;
                        meta.appendChild(handle);
                    }

                    const timestamp = document.createElement('time');
                    timestamp.className = 'fc-note__timestamp';
                    const stampValue = note.updated_at || note.last_message_at || note.created_at;
                    const stampLabel = formatTimestamp(stampValue, true);
                    if (stampLabel) {
                        timestamp.dateTime = stampValue;
                        timestamp.textContent = stampLabel;
                    }

                    button.appendChild(title);
                    if (previewText) {
                        button.appendChild(preview);
                    }
                    if (meta.childElementCount) {
                        meta.appendChild(timestamp);
                        button.appendChild(meta);
                    } else if (stampLabel) {
                        button.appendChild(timestamp);
                    }
                    button.addEventListener('click', () => {
                        selectNote(note.id, { focusComposer: true });
                    });
                    fragment.appendChild(button);
                });

                notesListEl.appendChild(fragment);
            };

            const renderAttachmentChips = () => {
                if (!attachmentChipsEl) {
                    return;
                }
                attachmentChipsEl.innerHTML = '';
                if (!state.pendingFiles.length) {
                    attachmentChipsEl.hidden = true;
                    return;
                }
                attachmentChipsEl.hidden = false;
                const fragment = document.createDocumentFragment();
                state.pendingFiles.forEach((item) => {
                    const chip = document.createElement('div');
                    chip.className = 'fc-chip';
                    chip.textContent = item.file.name;

                    const removeButton = document.createElement('button');
                    removeButton.type = 'button';
                    removeButton.className = 'fc-chip__remove';
                    removeButton.setAttribute('aria-label', `Remove ${item.file.name}`);
                    removeButton.textContent = 'Remove';
                    removeButton.addEventListener('click', () => {
                        removePendingFile(item.id);
                    });
                    chip.appendChild(removeButton);
                    fragment.appendChild(chip);
                });
                attachmentChipsEl.appendChild(fragment);
            };

            if (noteHandleButton) {
                noteHandleButton.addEventListener('click', async () => {
                    const handle = noteHandleButton.dataset.handle || '';
                    if (!handle) {
                        return;
                    }
                    try {
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            await navigator.clipboard.writeText(handle);
                        } else {
                            const helper = document.createElement('textarea');
                            helper.value = handle;
                            helper.setAttribute('readonly', '');
                            helper.style.position = 'fixed';
                            helper.style.opacity = '0';
                            document.body.appendChild(helper);
                            helper.select();
                            document.execCommand('copy');
                            document.body.removeChild(helper);
                        }
                        window.clearTimeout(handleCopyResetTimer);
                        noteHandleButton.classList.add('is-copied');
                        noteHandleButton.textContent = 'Copied';
                        handleCopyResetTimer = window.setTimeout(() => {
                            updateNoteHandleButton(handle);
                        }, 1400);
                    } catch (error) {
                        console.error('Failed to copy handle', error);
                        window.prompt('Copy handle', handle);
                    }
                });
            }

            if (deleteButton) {
                deleteButton.disabled = true;
                deleteButton.setAttribute('aria-disabled', 'true');
                deleteButton.addEventListener('click', async () => {
                    if (!state.activeNoteId) {
                        return;
                    }
                    const active = state.notes.find((note) => note.id === state.activeNoteId);
                    const label = normalizePreview(active ? active.title : '') || 'this note';
                    const confirmed = window.confirm(`Delete "${label}"? This will remove all messages and files.`);
                    if (!confirmed) {
                        return;
                    }
                    deleteButton.disabled = true;
                    deleteButton.setAttribute('aria-disabled', 'true');
                    try {
                        await deleteNote(state.activeNoteId);
                        const removedId = state.activeNoteId;
                        state.notes = state.notes.filter((note) => note.id !== removedId);
                        state.activeNoteId = '';
                        state.activeNote = null;
                        state.messages = [];
                        renderMessages();
                        renderNoteTitle(null);
                        renderNotes();
                        state.pendingFiles = [];
                        renderAttachmentChips();
                        clearError();
                        refreshMentionHandles();
                        updateComposerAvailability();
                        if (state.notes.length) {
                            await selectNote(state.notes[0].id, { focusComposer: true });
                        }
                    } catch (error) {
                        console.error('Failed to delete note', error);
                        showError('Unable to delete this note.');
                    } finally {
                        updateComposerAvailability();
                    }
                });
            }

            const createMetadataDetails = (metadata) => {
                if (!metadata || typeof metadata !== 'object') {
                    return null;
                }
                const container = document.createElement('div');
                container.className = 'fc-message__meta';
                const action = metadata.action;

                if (action === 'calendar_event_created' && metadata.event) {
                    const heading = document.createElement('div');
                    heading.className = 'fc-message__meta-heading';
                    heading.textContent = 'Calendar event';
                    const body = document.createElement('div');
                    body.className = 'fc-message__meta-body';
                    const event = metadata.event;
                    const lines = [
                        event.title,
                        formatEventWindow(event),
                        normalizePreview(event.location || ''),
                    ].filter(Boolean);
                    body.textContent = lines.join(' • ');
                    container.appendChild(heading);
                    container.appendChild(body);
                    return container;
                }

                if (action === 'reminder_created' && metadata.reminder) {
                    const heading = document.createElement('div');
                    heading.className = 'fc-message__meta-heading';
                    heading.textContent = 'Reminder';
                    const body = document.createElement('div');
                    body.className = 'fc-message__meta-body';
                    const reminder = metadata.reminder;
                    const parts = [reminder.title];
                    if (reminder.due_at) {
                        const dueLabel = formatTimestamp(reminder.due_at, Boolean(reminder.due_has_time));
                        if (dueLabel) {
                            parts.push(`due ${dueLabel}`);
                        }
                    }
                    if (reminder.notes) {
                        parts.push(reminder.notes);
                    }
                    body.textContent = parts.join(' • ');
                    container.appendChild(heading);
                    container.appendChild(body);
                    return container;
                }

                if (action === 'password_lookup') {
                    const heading = document.createElement('div');
                    heading.className = 'fc-message__meta-heading';
                    heading.textContent = 'Passwords';
                    const list = document.createElement('ul');
                    list.className = 'fc-message__meta-list';
                    (metadata.matches || []).slice(0, 5).forEach((match) => {
                        const item = document.createElement('li');
                        const service = match.service || 'Service';
                        const username = match.username || '—';
                        const passwordValue = match.password || '—';
                        item.textContent = `${service}: ${username} / ${passwordValue}`;
                        list.appendChild(item);
                    });
                    container.appendChild(heading);
                    container.appendChild(list);
                    return container;
                }

                if (action === 'report_list' && Array.isArray(metadata.reports)) {
                    const heading = document.createElement('div');
                    heading.className = 'fc-message__meta-heading';
                    heading.textContent = 'Available reports';
                    const list = document.createElement('ul');
                    list.className = 'fc-message__meta-list';
                    metadata.reports.slice(0, 6).forEach((report) => {
                        const item = document.createElement('li');
                        item.textContent = `${report.id}: ${report.name || ''}`.trim();
                        list.appendChild(item);
                    });
                    container.appendChild(heading);
                    container.appendChild(list);
                    return container;
                }

                if (action === 'report_run' && metadata.report) {
                    const heading = document.createElement('div');
                    heading.className = 'fc-message__meta-heading';
                    heading.textContent = metadata.report.name || metadata.report.id || 'Report';
                    const list = document.createElement('ul');
                    list.className = 'fc-message__meta-list';
                    (metadata.report.summary || []).slice(0, 5).forEach((entry) => {
                        const item = document.createElement('li');
                        const label = entry.label || entry.id;
                        const value = entry.display || entry.value;
                        item.textContent = `${label}: ${value}`;
                        list.appendChild(item);
                    });
                    container.appendChild(heading);
                    container.appendChild(list);
                    return container;
                }

                return null;
            };

            const renderMentionText = (container, content) => {
                if (!content) {
                    return false;
                }
                const components = window.RecordMentionComponents || {};
                if (
                    !components.RecordMentionText ||
                    !window.React ||
                    !window.ReactDOM ||
                    typeof window.ReactDOM.createRoot !== 'function'
                ) {
                    return false;
                }
                try {
                    const root = window.ReactDOM.createRoot(container);
                    root.render(
                        window.React.createElement(components.RecordMentionText, {
                            text: content,
                            entityTypes: mentionEntityTypes,
                            className: 'fc-message__text-content',
                        })
                    );
                    activeMentionTextRoots.push(root);
                    return true;
                } catch (error) {
                    console.debug('Failed to render mention text', error);
                    return false;
                }
            };

            const getReactionKey = (messageId, emoji) => `${messageId}:${emoji}`;

            const updateRecentReactions = (emoji) => {
                if (!emoji) {
                    return;
                }
                const normalized = String(emoji).trim();
                if (!normalized) {
                    return;
                }
                const current = Array.isArray(state.recentReactions)
                    ? state.recentReactions.slice()
                    : [];
                const filtered = current.filter((entry) => entry !== normalized);
                filtered.unshift(normalized);
                state.recentReactions = filtered.slice(0, QUICK_REACTIONS_LIMIT);
            };

            const getQuickReactionOptions = () => {
                const seen = new Set();
                const merged = [];
                (state.recentReactions || []).forEach((emoji) => {
                    if (!emoji || seen.has(emoji)) {
                        return;
                    }
                    seen.add(emoji);
                    merged.push(emoji);
                });
                REACTION_OPTIONS.forEach((emoji) => {
                    if (!emoji || seen.has(emoji)) {
                        return;
                    }
                    seen.add(emoji);
                    merged.push(emoji);
                });
                return merged.slice(0, QUICK_REACTIONS_LIMIT);
            };

            const isReactionPending = (messageId, emoji) => {
                if (!messageId || !emoji) {
                    return false;
                }
                return pendingReactions.has(getReactionKey(messageId, emoji));
            };

            const setReactionPending = (messageId, emoji, pending) => {
                if (!messageId || !emoji) {
                    return;
                }
                const key = getReactionKey(messageId, emoji);
                if (pending) {
                    pendingReactions.add(key);
                } else {
                    pendingReactions.delete(key);
                }
            };

            const upsertMessage = (message) => {
                if (!message || !message.id) {
                    return;
                }
                const index = state.messages.findIndex((entry) => entry.id === message.id);
                if (index >= 0) {
                    const existing = state.messages[index];
                    state.messages[index] = { ...existing, ...message };
                } else {
                    state.messages.push(message);
                }
            };

            const handleReactionToggle = async (messageId, emoji) => {
                if (!messageId || !emoji) {
                    return;
                }
                if (isReactionPending(messageId, emoji)) {
                    return;
                }
                setReactionPending(messageId, emoji, true);
                renderMessages();
                try {
                    const response = await fetch(REACTION_ENDPOINT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message_id: messageId, emoji }),
                    });
                    if (!response.ok) {
                        throw new Error('Failed to update reaction');
                    }
                    const payload = await response.json();
                    if (payload && payload.message) {
                        upsertMessage(payload.message);
                        clearError();
                        if (payload.action === 'added') {
                            updateRecentReactions(emoji);
                        }
                    }
                } catch (error) {
                    console.error('Failed to toggle reaction', error);
                    showError('Unable to update reaction.');
                } finally {
                    setReactionPending(messageId, emoji, false);
                    renderMessages();
                }
            };

            const createReactionButton = (message, emoji, summary) => {
                if (!message || !message.id || !emoji) {
                    return null;
                }
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'fc-reaction';
                const reacted = summary && summary.reacted;
                const count = summary && Number.isFinite(summary.count) ? Number(summary.count) : 0;
                button.textContent = count > 0 ? `${emoji} ${count}` : emoji;
                button.setAttribute('aria-pressed', reacted ? 'true' : 'false');
                if (reacted) {
                    button.classList.add('is-active');
                }
                const pending = isReactionPending(message.id, emoji);
                if (pending) {
                    button.classList.add('is-pending');
                    button.disabled = true;
                }
                button.addEventListener('click', () => {
                    handleReactionToggle(message.id, emoji);
                });
                let description = `React with ${emoji}`;
                if (summary && Array.isArray(summary.reactors) && summary.reactors.length) {
                    description = `${emoji} reaction from ${summary.reactors.join(', ')}`;
                }
                button.title = description;
                button.setAttribute('aria-label', description);
                if (count === 0) {
                    button.classList.add('fc-reaction--ghost');
                }
                return button;
            };

            const renderReactionRow = (message) => {
                if (!message || !message.id) {
                    return null;
                }
                const container = document.createElement('div');
                container.className = 'fc-message__reactions';
                let hasVisible = false;
                if (Array.isArray(message.reactions)) {
                    message.reactions.forEach((reaction) => {
                        if (!reaction || !reaction.emoji) {
                            return;
                        }
                        const button = createReactionButton(message, reaction.emoji, reaction);
                        if (button) {
                            container.appendChild(button);
                            hasVisible = true;
                        }
                    });
                }
                if (!hasVisible) {
                    return null;
                }
                return container;
            };

            const isUserMessage = (message) => {
                return String(message && message.author && message.author.toLowerCase()) === 'user';
            };

            const isMessageBeingEdited = (messageId) => {
                return Boolean(state.activeMessageEdit && state.activeMessageEdit.id === messageId);
            };

            const setMessageEditValue = (value) => {
                if (!state.activeMessageEdit) {
                    return;
                }
                state.activeMessageEdit = {
                    ...state.activeMessageEdit,
                    value,
                };
            };

            const startMessageEdit = (message) => {
                if (!message || !message.id) {
                    return;
                }
                closeActivePopover();
                state.activeMessageEdit = {
                    id: message.id,
                    noteId: message.note_id,
                    value: message.content || '',
                    pending: false,
                };
                renderMessages();
                scheduleFrame(() => {
                    const textarea = document.querySelector(`[data-edit-textarea="${message.id}"]`);
                    if (textarea) {
                        textarea.focus();
                        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                    }
                });
            };

            const cancelMessageEdit = () => {
                if (!state.activeMessageEdit) {
                    return;
                }
                state.activeMessageEdit = null;
                renderMessages();
            };

            const submitMessageEdit = async () => {
                const editState = state.activeMessageEdit;
                if (!editState || editState.pending) {
                    return;
                }
                const messageId = editState.id;
                const content = editState.value || '';
                const trimmed = normalizePreview(content);
                if (!trimmed) {
                    showError('Add some text before saving edits.');
                    return;
                }
                const originalState = { ...editState };
                state.activeMessageEdit = { ...editState, pending: true };
                renderMessages();
                try {
                    const response = await fetch(`${MESSAGE_ENDPOINT}/${encodeURIComponent(messageId)}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ content }),
                    });
                    if (!response.ok) {
                        throw new Error('Failed to save message edits');
                    }
                    const payload = await response.json();
                    if (payload.message) {
                        upsertMessage(payload.message);
                    }
                    if (payload.note) {
                        updateNoteFromResponse(payload.note);
                    }
                    state.activeMessageEdit = null;
                    clearError();
                } catch (error) {
                    console.error('Failed to update message', error);
                    showError('Unable to update that message.');
                    state.activeMessageEdit = { ...originalState, pending: false };
                } finally {
                    renderMessages();
                }
            };

            const replyToMessage = (message) => {
                if (!message) {
                    return;
                }
                closeActivePopover();
                const content = message.content || '';
                const replyBlock = content
                    ? content
                          .split('\n')
                          .map((line) => `> ${line}`)
                          .join('\n')
                    : '';
                const existing = getComposerValue();
                const authorLabel = formatMessageAuthorLabel(message.author);
                const mention = authorLabel.startsWith('@')
                    ? authorLabel
                    : `@${authorLabel.toLowerCase()}`;
                const segments = [];
                if (existing) {
                    segments.push(existing.trimEnd());
                }
                if (replyBlock) {
                    segments.push(replyBlock);
                }
                segments.push(`${mention} `);
                const composed = segments.join('\n');
                setComposerValue(composed, { forceRender: true });
                scheduleFrame(() => {
                    const textarea = getActiveTextarea();
                    if (textarea) {
                        textarea.focus();
                        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                    }
                });
            };

            const setPendingMessageAction = (action) => {
                state.pendingMessageAction = action;
            };

            const isMessageActionPending = (messageId) => {
                const pending = state.pendingMessageAction;
                return Boolean(pending && pending.messageId === messageId);
            };

            const handleDeleteMessage = async (message) => {
                if (!message || !message.id) {
                    return;
                }
                const confirmDelete = window.confirm('Delete this message?');
                if (!confirmDelete) {
                    return;
                }
                closeActivePopover();
                setPendingMessageAction({ type: 'delete', messageId: message.id });
                renderMessages();
                try {
                    const response = await fetch(`${MESSAGE_ENDPOINT}/${encodeURIComponent(message.id)}`, {
                        method: 'DELETE',
                    });
                    if (!response.ok) {
                        throw new Error('Failed to delete');
                    }
                    const payload = await response.json();
                    state.messages = state.messages.filter((entry) => entry.id !== message.id);
                    if (payload.note) {
                        updateNoteFromResponse(payload.note);
                    }
                    clearError();
                } catch (error) {
                    console.error('Failed to delete message', error);
                    showError('Unable to delete that message.');
                } finally {
                    setPendingMessageAction(null);
                    renderMessages();
                }
            };

            const handleForwardMessage = async (message, targetNoteId) => {
                if (!message || !message.id || !targetNoteId) {
                    return;
                }
                closeActivePopover();
                setPendingMessageAction({ type: 'forward', messageId: message.id });
                renderMessages();
                try {
                    const response = await fetch(FORWARD_ENDPOINT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message_id: message.id, target_note_id: targetNoteId }),
                    });
                    if (!response.ok) {
                        throw new Error('Failed to forward');
                    }
                    const payload = await response.json();
                    if (payload.message) {
                        if (payload.message.note_id === state.activeNoteId) {
                            upsertMessage(payload.message);
                        }
                    }
                    if (payload.note) {
                        updateNoteFromResponse(payload.note);
                    }
                    clearError();
                } catch (error) {
                    console.error('Failed to forward message', error);
                    showError('Unable to forward that message.');
                } finally {
                    setPendingMessageAction(null);
                    renderMessages();
                }
            };

            const handleCopyMessageText = async (message) => {
                if (!navigator.clipboard || !message) {
                    return;
                }
                try {
                    await navigator.clipboard.writeText(message.content || '');
                    closeActivePopover();
                } catch (error) {
                    console.error('Failed to copy message text', error);
                    showError('Unable to copy message text.');
                }
            };

            const handleCopyMessageLink = async (message) => {
                if (!navigator.clipboard || !message || !message.id) {
                    return;
                }
                const origin = window.location.origin || window.location.href;
                const url = `${origin.replace(/\/#?$/, '')}/firenotes#message-${message.id}`;
                try {
                    await navigator.clipboard.writeText(url);
                    closeActivePopover();
                } catch (error) {
                    console.error('Failed to copy message link', error);
                    showError('Unable to copy message link.');
                }
            };

            const openReactionPicker = (anchor, message) => {
                if (!anchor || !message) {
                    return;
                }
                openPopover(anchor, () => {
                    const container = document.createElement('div');
                    container.className = 'fc-popover__emoji';
                    REACTION_OPTIONS.forEach((emoji) => {
                        const button = document.createElement('button');
                        button.type = 'button';
                        button.className = 'fc-popover__emoji-button';
                        button.textContent = emoji;
                        button.setAttribute('aria-label', `React with ${emoji}`);
                        button.addEventListener('click', (event) => {
                            event.preventDefault();
                            closeActivePopover();
                            handleReactionToggle(message.id, emoji);
                        });
                        container.appendChild(button);
                    });
                    return container;
                });
            };

            const openForwardPicker = (anchor, message) => {
                if (!anchor || !message) {
                    return;
                }
                openPopover(anchor, () => {
                    const panel = document.createElement('div');
                    panel.className = 'fc-popover__panel';
                    const title = document.createElement('div');
                    title.className = 'fc-popover__title';
                    title.textContent = 'Forward message to…';
                    panel.appendChild(title);
                    const list = document.createElement('div');
                    list.className = 'fc-popover__list';
                    const notes = Array.isArray(state.notes) ? state.notes : [];
                    if (!notes.length) {
                        const empty = document.createElement('div');
                        empty.className = 'fc-popover__empty';
                        empty.textContent = 'No notes available';
                        panel.appendChild(empty);
                        return panel;
                    }
                    notes.forEach((note) => {
                        if (!note || !note.id) {
                            return;
                        }
                        const item = document.createElement('button');
                        item.type = 'button';
                        item.className = 'fc-popover__item';
                        item.textContent = note.title || 'Untitled note';
                        if (state.pendingMessageAction && state.pendingMessageAction.messageId === message.id) {
                            item.disabled = true;
                        }
                        item.addEventListener('click', (event) => {
                            event.preventDefault();
                            handleForwardMessage(message, note.id);
                        });
                        list.appendChild(item);
                    });
                    panel.appendChild(list);
                    return panel;
                });
            };

            const openMessageMenu = (anchor, message) => {
                if (!anchor || !message) {
                    return;
                }
                openPopover(anchor, () => {
                    const menu = document.createElement('div');
                    menu.className = 'fc-popover__menu';
                    const addItem = (label, handler, options = {}) => {
                        const item = document.createElement('button');
                        item.type = 'button';
                        item.className = 'fc-popover__menu-item';
                        if (options.destructive) {
                            item.classList.add('is-destructive');
                        }
                        item.textContent = label;
                        if (options.disabled) {
                            item.disabled = true;
                        }
                        item.addEventListener('click', (event) => {
                            event.preventDefault();
                            handler();
                        });
                        menu.appendChild(item);
                    };
                    addItem('Add Reaction', () => {
                        closeActivePopover();
                        openReactionPicker(anchor, message);
                    });
                    if (isUserMessage(message)) {
                        addItem('Edit Message', () => {
                            startMessageEdit(message);
                        }, { disabled: isMessageBeingEdited(message.id) });
                    }
                    addItem('Reply', () => {
                        replyToMessage(message);
                    });
                    addItem('Forward', () => {
                        openForwardPicker(anchor, message);
                    });
                    addItem('Copy Text', () => {
                        handleCopyMessageText(message);
                    });
                    addItem('Copy Message Link', () => {
                        handleCopyMessageLink(message);
                    });
                    if (isUserMessage(message)) {
                        addItem(
                            'Delete Message',
                            () => {
                                handleDeleteMessage(message);
                            },
                            { destructive: true }
                        );
                    }
                    return menu;
                });
            };

            const createToolbarButton = (label, icon, handler) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'fc-message__toolbar-button';
                button.title = label;
                button.setAttribute('aria-label', label);
                if (icon) {
                    const iconSpan = document.createElement('span');
                    iconSpan.className = 'fc-message__toolbar-icon';
                    iconSpan.textContent = icon;
                    button.appendChild(iconSpan);
                }
                button.addEventListener('click', (event) => {
                    event.preventDefault();
                    handler(event.currentTarget || button);
                });
                return button;
            };

            const createQuickReactionButton = (message, emoji) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'fc-message__toolbar-button fc-message__toolbar-button--emoji';
                button.textContent = emoji;
                button.setAttribute('aria-label', `React with ${emoji}`);
                if (isReactionPending(message.id, emoji) || isMessageActionPending(message.id)) {
                    button.disabled = true;
                }
                button.addEventListener('click', (event) => {
                    event.preventDefault();
                    handleReactionToggle(message.id, emoji);
                });
                return button;
            };

            const createMessageToolbar = (message) => {
                const toolbar = document.createElement('div');
                toolbar.className = 'fc-message__toolbar';
                if (!message || !message.id) {
                    return toolbar;
                }
                const quickGroup = document.createElement('div');
                quickGroup.className = 'fc-message__toolbar-group fc-message__toolbar-group--reactions';
                getQuickReactionOptions().forEach((emoji) => {
                    quickGroup.appendChild(createQuickReactionButton(message, emoji));
                });
                if (quickGroup.children.length) {
                    toolbar.appendChild(quickGroup);
                }
                const actionsGroup = document.createElement('div');
                actionsGroup.className = 'fc-message__toolbar-group';
                const addReactionButton = createToolbarButton('Add reaction', '😊', (anchor) => {
                    openReactionPicker(anchor, message);
                });
                actionsGroup.appendChild(addReactionButton);
                if (isUserMessage(message)) {
                    const editButton = createToolbarButton('Edit message', '✏️', () => {
                        startMessageEdit(message);
                    });
                    if (isMessageBeingEdited(message.id)) {
                        editButton.disabled = true;
                    }
                    actionsGroup.appendChild(editButton);
                }
                const forwardButton = createToolbarButton('Forward message', '↗', (anchor) => {
                    openForwardPicker(anchor, message);
                });
                if (isMessageActionPending(message.id)) {
                    forwardButton.disabled = true;
                }
                actionsGroup.appendChild(forwardButton);
                const menuButton = createToolbarButton('More actions', '⋯', (anchor) => {
                    openMessageMenu(anchor, message);
                });
                actionsGroup.appendChild(menuButton);
                toolbar.appendChild(actionsGroup);
                return toolbar;
            };

            const createMessageEditForm = (message, editState) => {
                const form = document.createElement('form');
                form.className = 'fc-message__edit';
                const textarea = document.createElement('textarea');
                textarea.className = 'fc-message__edit-input';
                textarea.value = editState.value || '';
                textarea.rows = Math.min(12, Math.max(3, textarea.value.split('\n').length));
                textarea.setAttribute('data-edit-textarea', message.id);
                textarea.addEventListener('input', () => {
                    setMessageEditValue(textarea.value);
                });
                form.appendChild(textarea);
                const actions = document.createElement('div');
                actions.className = 'fc-message__edit-actions';
                const saveButton = document.createElement('button');
                saveButton.type = 'submit';
                saveButton.className = 'fc-button fc-button--primary';
                saveButton.textContent = editState.pending ? 'Saving…' : 'Save';
                saveButton.disabled = !!editState.pending;
                const cancelButton = document.createElement('button');
                cancelButton.type = 'button';
                cancelButton.className = 'fc-button';
                cancelButton.textContent = 'Cancel';
                cancelButton.disabled = !!editState.pending;
                cancelButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    cancelMessageEdit();
                });
                actions.appendChild(cancelButton);
                actions.appendChild(saveButton);
                form.appendChild(actions);
                form.addEventListener('submit', (event) => {
                    event.preventDefault();
                    submitMessageEdit();
                });
                return form;
            };

            const formatMessageAuthorLabel = (author) => {
                const normalized = String(author || '').trim();
                if (!normalized) {
                    return '@firenotes';
                }
                const lowered = normalized.toLowerCase();
                if (lowered === 'user') {
                    return 'You';
                }
                if (lowered === 'assistant') {
                    return '@firenotes';
                }
                if (normalized.startsWith('@')) {
                    return normalized;
                }
                return `@${normalized}`;
            };

            const createMessageElement = (message) => {
                const author = (message.author || '').toLowerCase();
                const isUser = author === 'user';
                const wrapper = document.createElement('article');
                wrapper.className = 'fc-message' + (isUser ? ' fc-message--user' : ' fc-message--assistant');
                if (message.id) {
                    wrapper.id = `message-${message.id}`;
                }
                if (isMessageActionPending(message.id)) {
                    wrapper.classList.add('is-processing');
                }
                const metadata = message.metadata || {};
                const editingState = isMessageBeingEdited(message.id) ? state.activeMessageEdit : null;
                if (editingState) {
                    wrapper.classList.add('is-editing');
                }

                const bubble = document.createElement('div');
                bubble.className = 'fc-message__bubble';

                const main = document.createElement('div');
                main.className = 'fc-message__main';

                const header = document.createElement('div');
                header.className = 'fc-message__header';

                const authorLabel = document.createElement('span');
                authorLabel.className = 'fc-message__author';
                authorLabel.textContent = formatMessageAuthorLabel(message.author);
                header.appendChild(authorLabel);

                const timestamp = document.createElement('time');
                timestamp.className = 'fc-message__timestamp';
                if (message.created_at) {
                    timestamp.dateTime = message.created_at;
                    const stampLabel = formatTimestamp(message.created_at, true);
                    if (stampLabel) {
                        timestamp.textContent = stampLabel;
                    }
                }
                header.appendChild(timestamp);

                if (metadata.edited_at) {
                    const editedIndicator = document.createElement('span');
                    editedIndicator.className = 'fc-message__edited';
                    editedIndicator.textContent = '(edited)';
                    header.appendChild(editedIndicator);
                }

                main.appendChild(header);

                const body = document.createElement('div');
                body.className = 'fc-message__body';

                const appendAttachments = () => {
                    if (!Array.isArray(message.attachments) || !message.attachments.length) {
                        return;
                    }
                    const attachments = document.createElement('div');
                    attachments.className = 'fc-message__attachments';
                    message.attachments.forEach((attachment) => {
                        if (attachment.is_image) {
                            const figure = document.createElement('figure');
                            figure.className = 'fc-message__attachment fc-message__attachment--image';
                            const img = document.createElement('img');
                            img.src = attachment.url;
                            img.alt = attachment.filename || 'Image attachment';
                            figure.appendChild(img);
                            attachments.appendChild(figure);
                        } else {
                            const link = document.createElement('a');
                            link.className = 'fc-message__attachment';
                            link.href = attachment.url;
                            link.target = '_blank';
                            link.rel = 'noopener noreferrer';
                            link.textContent = attachment.filename || 'Download file';
                            attachments.appendChild(link);
                        }
                    });
                    body.appendChild(attachments);
                };

                if (editingState) {
                    body.appendChild(createMessageEditForm(message, editingState));
                    appendAttachments();
                } else {
                    if (metadata.forwarded_from) {
                        const forwarded = document.createElement('div');
                        forwarded.className = 'fc-message__forwarded';
                        const forwardedAuthor = formatMessageAuthorLabel(metadata.forwarded_from.author);
                        const forwardedStamp = metadata.forwarded_from.created_at
                            ? formatTimestamp(metadata.forwarded_from.created_at, true)
                            : null;
                        forwarded.textContent = forwardedStamp
                            ? `Forwarded from ${forwardedAuthor} · ${forwardedStamp}`
                            : `Forwarded from ${forwardedAuthor}`;
                        body.appendChild(forwarded);
                    }
                    if (message.content) {
                        const text = document.createElement('div');
                        text.className = 'fc-message__text';
                        if (!renderMentionText(text, message.content)) {
                            text.textContent = message.content;
                        }
                        body.appendChild(text);
                    }
                    appendAttachments();
                    const metadataDetails = createMetadataDetails(metadata);
                    if (metadataDetails) {
                        body.appendChild(metadataDetails);
                    }
                    const reactionsRow = renderReactionRow(message);
                    if (reactionsRow) {
                        body.appendChild(reactionsRow);
                    }
                }

                main.appendChild(body);
                bubble.appendChild(main);

                const toolbar = createMessageToolbar(message);
                bubble.appendChild(toolbar);

                wrapper.appendChild(bubble);
                return wrapper;
            };

            const matchesMessageSearch = (message, query) => {
                if (!query) {
                    return true;
                }
                const lowered = query.toLowerCase();
                const content = normalizePreview(message.content || '').toLowerCase();
                if (content.includes(lowered)) {
                    return true;
                }
                if (Array.isArray(message.attachments)) {
                    if (message.attachments.some((attachment) => (attachment.filename || '').toLowerCase().includes(lowered))) {
                        return true;
                    }
                }
                try {
                    const metadataText = JSON.stringify(message.metadata || {});
                    if (metadataText && metadataText.toLowerCase().includes(lowered)) {
                        return true;
                    }
                } catch (error) {
                    console.debug('Unable to search metadata', error);
                }
                return false;
            };

            const renderMessages = () => {
                if (!chatLogEl) {
                    return;
                }
                if (
                    state.activeMessageEdit &&
                    !state.messages.some((entry) => entry && entry.id === state.activeMessageEdit.id)
                ) {
                    state.activeMessageEdit = null;
                }
                cleanupMentionTextRoots();
                closeActivePopover();
                chatLogEl.innerHTML = '';
                if (!state.activeNoteId) {
                    const empty = document.createElement('div');
                    empty.className = 'fc-chat-placeholder';
                    empty.textContent = 'Create a note to start chatting.';
                    chatLogEl.appendChild(empty);
                    return;
                }
                if (state.isLoadingMessages) {
                    setBusy(true);
                    const loading = document.createElement('div');
                    loading.className = 'fc-chat-placeholder';
                    loading.textContent = 'Loading note…';
                    chatLogEl.appendChild(loading);
                    return;
                }
                setBusy(false);
                const trimmedQuery = normalizePreview(state.messageSearch || '');
                const lowered = trimmedQuery.toLowerCase();
                const visible = lowered
                    ? state.messages.filter((message) => matchesMessageSearch(message, lowered))
                    : state.messages.slice();
                if (!visible.length) {
                    const empty = document.createElement('div');
                    empty.className = 'fc-chat-placeholder';
                    empty.textContent = lowered ? 'No matches in this note.' : 'Drop a thought to get started.';
                    chatLogEl.appendChild(empty);
                    return;
                }
                const fragment = document.createDocumentFragment();
                visible.forEach((message) => {
                    fragment.appendChild(createMessageElement(message));
                });
                chatLogEl.appendChild(fragment);
                if (!lowered) {
                    chatLogEl.scrollTop = chatLogEl.scrollHeight;
                }
            };

            const autoResizeInput = () => {
                const textarea = getActiveTextarea();
                if (!textarea) {
                    return;
                }
                textarea.style.height = 'auto';
                const targetHeight = Math.min(MAX_COMPOSER_HEIGHT, textarea.scrollHeight || 0);
                const finalHeight = Math.max(targetHeight, 44);
                textarea.style.height = `${finalHeight}px`;
                if (mentionComposer.useMentionComponent && mentionRootEl) {
                    const overlay = mentionRootEl.querySelector('.record-mention-textarea__overlay');
                    if (overlay) {
                        overlay.style.height = `${finalHeight}px`;
                    }
                }
            };

            const setComposerEnabled = (enabled) => {
                state.composerDisabled = !enabled;
                if (attachmentButtonEl) {
                    attachmentButtonEl.disabled = !enabled;
                }
                if (composerEl) {
                    composerEl.setAttribute('data-disabled', enabled ? 'false' : 'true');
                }
                if (deleteButton) {
                    deleteButton.disabled = !enabled;
                    deleteButton.setAttribute('aria-disabled', enabled ? 'false' : 'true');
                }
                if (mentionComposer.useMentionComponent) {
                    renderMentionComposer();
                } else if (inputEl) {
                    inputEl.disabled = !enabled;
                    if (!enabled) {
                        inputEl.value = '';
                    }
                }
                if (!enabled) {
                    state.pendingFiles = [];
                    renderAttachmentChips();
                    setComposerValue('', { forceRender: true });
                } else {
                    autoResizeInput();
                }
            };

            const updateComposerAvailability = () => {
                const enabled = Boolean(state.activeNoteId);
                setComposerEnabled(enabled);
                if (enabled) {
                    autoResizeInput();
                }
            };

            const resetComposer = () => {
                setComposerValue('');
                state.pendingFiles = [];
                renderAttachmentChips();
            };

            const updateNoteFromResponse = (note) => {
                if (!note || !note.id) {
                    return;
                }
                const existingIndex = state.notes.findIndex((entry) => entry.id === note.id);
                let handleChanged = false;
                if (existingIndex >= 0) {
                    const existing = state.notes[existingIndex];
                    handleChanged = (existing.handle || '') !== (note.handle || '');
                    state.notes[existingIndex] = { ...existing, ...note };
                } else {
                    state.notes.push(note);
                    handleChanged = Boolean(note.handle);
                }
                sortNotes();
                if (note.id === state.activeNoteId) {
                    state.activeNote = note;
                    renderNoteTitle(note);
                }
                renderNotes();
                if (handleChanged) {
                    refreshMentionHandles();
                }
            };

            const removePendingFile = (id) => {
                state.pendingFiles = state.pendingFiles.filter((item) => item.id !== id);
                renderAttachmentChips();
            };

            const addPendingFiles = (fileList) => {
                if (!fileList || !fileList.length) {
                    return;
                }
                const files = Array.from(fileList);
                files.forEach((file) => {
                    const id = `file-${Date.now()}-${Math.random().toString(16).slice(2)}`;
                    state.pendingFiles.push({ id, file });
                });
                renderAttachmentChips();
            };

            const loadMessages = async (noteId, options = {}) => {
                if (!noteId) {
                    return;
                }
                const silent = Boolean(options.silent);
                if (!silent) {
                    state.isLoadingMessages = true;
                    renderMessages();
                }
                try {
                    const response = await fetch(`${API_BASE}/chat?noteId=${encodeURIComponent(noteId)}&limit=400`);
                    if (!response.ok) {
                        throw new Error('Failed to load messages');
                    }
                    const payload = await response.json();
                    state.messages = Array.isArray(payload.messages) ? payload.messages : [];
                    pendingReactions.clear();
                    if (payload.note) {
                        state.activeNote = payload.note;
                        state.activeNoteId = payload.note.id;
                        updateNoteFromResponse(payload.note);
                    }
                    clearError();
                } catch (error) {
                    console.error('Failed to load messages', error);
                    showError('Unable to load this note.');
                } finally {
                    state.isLoadingMessages = false;
                    renderMessages();
                }
            };

            const selectNote = async (noteId, options = {}) => {
                if (!noteId) {
                    return;
                }
                state.activeNoteId = noteId;
                state.activeNote = state.notes.find((note) => note.id === noteId) || null;
                state.messageSearch = '';
                if (messageSearchEl) {
                    messageSearchEl.value = '';
                }
                renderNoteTitle(state.activeNote);
                renderNotes();
                updateComposerAvailability();
                renderAttachmentChips();
                renderMessages();
                await loadMessages(noteId, { silent: options.silent });
                if (options.focusComposer) {
                    const textarea = getActiveTextarea();
                    if (textarea) {
                        textarea.focus();
                    }
                }
            };

            const createNote = async (title) => {
                const response = await fetch(`${API_BASE}/notes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title }),
                });
                if (!response.ok) {
                    throw new Error('Failed to create note');
                }
                const payload = await response.json();
                if (payload.note) {
                    updateNoteFromResponse(payload.note);
                }
                return payload.note;
            };

            const deleteNote = async (noteId) => {
                const response = await fetch(`${API_BASE}/notes`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: noteId }),
                });
                if (!response.ok) {
                    throw new Error('Failed to delete note');
                }
                return response.json();
            };

            const loadNotes = async (options = {}) => {
                const silent = Boolean(options.silent);
                if (!silent) {
                    state.isLoadingNotes = true;
                }
                try {
                    const response = await fetch(`${API_BASE}/notes`);
                    if (!response.ok) {
                        throw new Error('Failed to load notes');
                    }
                    const payload = await response.json();
                    state.notes = Array.isArray(payload.notes) ? payload.notes : [];
                    sortNotes();
                    renderNotes();
                    await refreshMentionDirectory();
                    if (!state.activeNoteId && state.notes.length) {
                        await selectNote(state.notes[0].id, { focusComposer: true, silent: true });
                    }
                    if (!state.notes.length && !autoCreatingNote) {
                        autoCreatingNote = true;
                        try {
                            const note = await createNote('New note');
                            if (note) {
                                await selectNote(note.id, { focusComposer: true });
                            }
                        } catch (error) {
                            console.error('Failed to create default note', error);
                        } finally {
                            autoCreatingNote = false;
                        }
                    }
                } catch (error) {
                    console.error('Failed to load notes', error);
                    showError('Unable to load notes.');
                } finally {
                    state.isLoadingNotes = false;
                }
            };

            const sendMessage = async (overrideContent = undefined) => {
                if (!state.activeNoteId || state.isSending) {
                    return;
                }
                const rawContent =
                    overrideContent !== undefined && overrideContent !== null
                        ? String(overrideContent)
                        : getComposerValue();
                const trimmed = normalizePreview(rawContent);
                if (!trimmed && !state.pendingFiles.length) {
                    return;
                }
                state.isSending = true;
                clearError();
                try {
                    let response;
                    if (state.pendingFiles.length) {
                        const formData = new FormData();
                        formData.append('note_id', state.activeNoteId);
                        formData.append('content', rawContent);
                        state.pendingFiles.forEach((item) => {
                            formData.append('attachments', item.file, item.file.name);
                        });
                        response = await fetch(`${API_BASE}/chat`, {
                            method: 'POST',
                            body: formData,
                        });
                    } else {
                        response = await fetch(`${API_BASE}/chat`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ note_id: state.activeNoteId, content: rawContent }),
                        });
                    }
                    if (!response.ok) {
                        throw new Error('Message failed');
                    }
                    const payload = await response.json();
                    const incoming = Array.isArray(payload.messages) ? payload.messages : [];
                    incoming.forEach((entry) => {
                        upsertMessage(entry);
                    });
                    if (payload.note) {
                        updateNoteFromResponse(payload.note);
                    }
                    resetComposer();
                    renderMessages();
                    clearError();
                } catch (error) {
                    console.error('Failed to send message', error);
                    showError('Unable to send that message.');
                } finally {
                    state.isSending = false;
                    if (chatLogEl) {
                        chatLogEl.scrollTop = chatLogEl.scrollHeight;
                    }
                    if (attachmentInputEl) {
                        attachmentInputEl.value = '';
                    }
                }
            };

            if (noteSearchEl) {
                noteSearchEl.addEventListener('input', () => {
                    state.noteSearch = noteSearchEl.value || '';
                    renderNotes();
                });
                noteSearchEl.addEventListener('keydown', async (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        const trimmed = normalizePreview(noteSearchEl.value || '');
                        if (!trimmed) {
                            return;
                        }
                        const trimmedLower = trimmed.toLowerCase();
                        const existing = state.notes.find((note) => {
                            const candidate = normalizePreview(note.title || '').toLowerCase();
                            return candidate && candidate === trimmedLower;
                        });
                        if (existing) {
                            await selectNote(existing.id, { focusComposer: true });
                            return;
                        }
                        try {
                            const note = await createNote(trimmed);
                            noteSearchEl.value = '';
                            state.noteSearch = '';
                            renderNotes();
                            if (note) {
                                await selectNote(note.id, { focusComposer: true });
                            }
                        } catch (error) {
                            console.error('Failed to create note', error);
                            showError('Unable to create that note.');
                        }
                    }
                });
            }

            if (createNoteButton) {
                createNoteButton.addEventListener('click', async () => {
                    const desiredTitle = normalizePreview((noteSearchEl && noteSearchEl.value) || '');
                    const fallbackTitle = desiredTitle || 'New note';
                    const match = desiredTitle
                        ? state.notes.find((note) => normalizePreview(note.title || '').toLowerCase() === desiredTitle.toLowerCase())
                        : null;
                    try {
                        createNoteButton.disabled = true;
                        if (match) {
                            await selectNote(match.id, { focusComposer: true });
                            return;
                        }
                        const note = await createNote(fallbackTitle);
                        if (noteSearchEl) {
                            noteSearchEl.value = '';
                        }
                        state.noteSearch = '';
                        renderNotes();
                        if (note) {
                            await selectNote(note.id, { focusComposer: true });
                        }
                    } catch (error) {
                        console.error('Failed to create note', error);
                        showError('Unable to create that note.');
                    } finally {
                        createNoteButton.disabled = false;
                    }
                });
            }

            if (messageSearchEl) {
                messageSearchEl.addEventListener('input', () => {
                    state.messageSearch = messageSearchEl.value || '';
                    renderMessages();
                });
            }

            if (refreshButton) {
                refreshButton.addEventListener('click', () => {
                    if (state.activeNoteId) {
                        loadMessages(state.activeNoteId, { silent: false });
                    }
                });
            }

            if (inputEl) {
                inputEl.addEventListener('input', () => {
                    state.composerValue = inputEl.value || '';
                    autoResizeInput();
                });
                inputEl.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter' && !event.shiftKey) {
                        event.preventDefault();
                        sendMessage(inputEl.value || '');
                    }
                });
            }

            if (attachmentButtonEl) {
                attachmentButtonEl.addEventListener('click', () => {
                    if (attachmentInputEl && !attachmentButtonEl.disabled) {
                        attachmentInputEl.click();
                    }
                });
            }

            if (attachmentInputEl) {
                attachmentInputEl.addEventListener('change', (event) => {
                    addPendingFiles(event.target.files);
                });
            }

            renderNotes();
            renderMessages();
            renderAttachmentChips();
            ensureMentionComposer();
            loadNotes();
        })();
    </script>
</body>
</html>
