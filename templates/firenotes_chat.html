<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FireNotes | FireCoast</title>
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="/assets/css/styles.css">
    <link rel="stylesheet" href="/assets/css/firenotes_chat.css">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel" src="/assets/js/record_mentions.jsx"></script>
</head>
<body class="bg-slate-50 min-h-screen font-sans firenotes-chat">
    <a class="fc-screen-reader-only" href="#fc-chat-log">Skip to chat</a>
    {% include 'partials/navbar.html' %}

    <main>
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 fc-chat-wrapper">
        <div class="fc-chat-layout">
            <aside class="fc-notes" aria-label="Notes">
                <div class="fc-notes__search">
                    <label class="fc-screen-reader-only" for="fc-note-search">Search or create note</label>
                    <div class="fc-notes__search-row">
                        <input id="fc-note-search" class="fc-notes__search-input" type="search" placeholder="Search or create note" autocomplete="off">
                        <button type="button" id="fc-create-note" class="fc-notes__create-button" aria-label="Create a new note">
                            <span class="fc-notes__create-icon" aria-hidden="true">ï¼‹</span>
                            <span class="fc-notes__create-label">New</span>
                        </button>
                    </div>
                </div>
                <div id="fc-note-list" class="fc-notes__list" role="listbox" aria-label="Saved notes"></div>
                <p id="fc-no-notes" class="fc-notes__empty" hidden></p>
            </aside>
            <section class="fc-chat-panel" aria-label="Note conversation">
                <header class="fc-chat-panel__header">
                    <div class="fc-chat-panel__title-group">
                        <h1 id="fc-note-title" class="fc-chat-panel__title">Untitled note</h1>
                        <button type="button" id="fc-note-handle" class="fc-note-handle" hidden></button>
                    </div>
                    <div class="fc-chat-panel__actions">
                        <label class="fc-screen-reader-only" for="fc-message-search">Search this note</label>
                        <input id="fc-message-search" class="fc-chat-search" type="search" placeholder="Search this note" autocomplete="off">
                        <button type="button" id="fc-refresh" class="fc-icon-button" aria-label="Refresh note">
                            <span aria-hidden="true">â†º</span>
                        </button>
                        <button type="button" id="fc-delete-note" class="fc-icon-button fc-icon-button--danger" aria-label="Delete note">
                            <span aria-hidden="true">ðŸ—‘</span>
                        </button>
                    </div>
                </header>
                <div class="fc-chat-panel__body">
                    <div id="fc-chat-scroll" class="fc-chat-scroll" role="presentation">
                        <div id="fc-chat-log" class="fc-chat-log" role="log" aria-live="polite" aria-busy="false"></div>
                    </div>
                </div>
                <footer class="fc-chat-panel__footer">
                    <p id="fc-error" class="fc-chat-error" role="status" aria-live="assertive" hidden></p>
                    <div class="fc-composer" data-disabled="true">
                        <div id="fc-reply-preview" class="fc-composer__reply" hidden></div>
                        <div id="fc-attachment-chips" class="fc-composer__attachments" aria-live="polite"></div>
                        <label class="fc-screen-reader-only" for="fc-input">Write a message</label>
                        <div class="fc-composer__input-wrapper">
                            <textarea id="fc-input" class="fc-composer__input" placeholder="Write a message" rows="1" disabled></textarea>
                            <div id="fc-mention-root" class="fc-composer__mention-root" hidden></div>
                        </div>
                        <div class="fc-composer__actions">
                            <input type="file" id="fc-attachment-input" class="fc-composer__file-input" multiple hidden>
                            <button type="button" id="fc-attach-button" class="fc-icon-button" aria-label="Add files" disabled>
                                <span aria-hidden="true">ï¼‹</span>
                            </button>
                        </div>
                    </div>
                </footer>
            </section>
        </div>
        </div>
    </main>


    <script>
        (function () {
            const notesListEl = document.getElementById('fc-note-list');
            const noteSearchEl = document.getElementById('fc-note-search');
            const createNoteButton = document.getElementById('fc-create-note');
            const noteEmptyEl = document.getElementById('fc-no-notes');
            const noteTitleEl = document.getElementById('fc-note-title');
            const noteHandleButton = document.getElementById('fc-note-handle');
            const chatLogEl = document.getElementById('fc-chat-log');
            const chatScrollEl = document.getElementById('fc-chat-scroll');
            const chatBottomAnchor = chatLogEl ? document.createElement('div') : null;
            if (chatLogEl && chatBottomAnchor) {
                chatBottomAnchor.className = 'fc-chat-bottom-anchor';
                chatBottomAnchor.setAttribute('aria-hidden', 'true');
                chatLogEl.appendChild(chatBottomAnchor);
            }
            const messageSearchEl = document.getElementById('fc-message-search');
            const refreshButton = document.getElementById('fc-refresh');
            const deleteButton = document.getElementById('fc-delete-note');
            const inputEl = document.getElementById('fc-input');
            const attachmentInputEl = document.getElementById('fc-attachment-input');
            const attachmentButtonEl = document.getElementById('fc-attach-button');
            const attachmentChipsEl = document.getElementById('fc-attachment-chips');
            const replyPreviewEl = document.getElementById('fc-reply-preview');
            const composerEl = document.querySelector('.fc-composer');
            const mentionRootEl = document.getElementById('fc-mention-root');
            const errorEl = document.getElementById('fc-error');

            const API_BASE = '/api/firenotes';
            const REACTION_ENDPOINT = `${API_BASE}/chat/reactions`;
            const MESSAGE_ENDPOINT = `${API_BASE}/chat/messages`;
            const FORWARD_ENDPOINT = `${API_BASE}/chat/forward`;
            const REACTION_OPTIONS = ['ðŸ‘', 'âœ…', 'ðŸ”¥', 'ðŸŽ‰', 'â—'];
            const QUICK_REACTIONS_LIMIT = 3;
            const STICKY_SCROLL_THRESHOLD = 48;
            const MESSAGE_GROUP_WINDOW_MS = 5 * 60 * 1000;

            const normalizeAuthorForGrouping = (author) => {
                if (author === null || author === undefined) {
                    return '';
                }
                return String(author).trim().toLowerCase();
            };

            const getMessageTimestampValue = (message) => {
                if (!message || !message.created_at) {
                    return null;
                }
                const timestamp = new Date(message.created_at).getTime();
                return Number.isNaN(timestamp) ? null : timestamp;
            };

            const shouldGroupWithPreviousMessage = (current, previous) => {
                if (!current || !previous) {
                    return false;
                }
                if (normalizeAuthorForGrouping(current.author) !== normalizeAuthorForGrouping(previous.author)) {
                    return false;
                }
                const currentTimestamp = getMessageTimestampValue(current);
                const previousTimestamp = getMessageTimestampValue(previous);
                if (currentTimestamp === null || previousTimestamp === null) {
                    return false;
                }
                const timestampDelta = Math.abs(currentTimestamp - previousTimestamp);
                return timestampDelta <= MESSAGE_GROUP_WINDOW_MS;
            };

            const scrollPort = chatScrollEl || chatLogEl;
            const setChatLogContent = (...nodes) => {
                if (!chatLogEl) {
                    return;
                }
                if (chatBottomAnchor) {
                    chatLogEl.replaceChildren(...nodes, chatBottomAnchor);
                    return;
                }
                chatLogEl.replaceChildren(...nodes);
            };

            const isNearBottom = (element) => {
                if (!element) {
                    return false;
                }
                const distanceToBottom = element.scrollHeight - element.scrollTop - element.clientHeight;
                return distanceToBottom <= STICKY_SCROLL_THRESHOLD;
            };

            const scrollAnchorIntoView = () => {
                if (!chatBottomAnchor || typeof chatBottomAnchor.scrollIntoView !== 'function') {
                    return false;
                }
                try {
                    chatBottomAnchor.scrollIntoView({ block: 'end' });
                } catch (error) {
                    chatBottomAnchor.scrollIntoView(false);
                }
                return true;
            };

            const jumpToBottom = () => {
                if (!scrollPort) {
                    return;
                }
                const settle = () => {
                    const maxScrollTop = Math.max(0, scrollPort.scrollHeight - scrollPort.clientHeight);
                    const anchorUsed = scrollAnchorIntoView();
                    if (!anchorUsed) {
                        scrollPort.scrollTop = maxScrollTop;
                    }
                };
                if (typeof requestAnimationFrame === 'function') {
                    requestAnimationFrame(settle);
                    return;
                }
                settle();
            };

            const state = {
                notes: [],
                messages: [],
                activeNoteId: '',
                activeNote: null,
                noteSearch: '',
                messageSearch: '',
                isLoadingNotes: false,
                isLoadingMessages: false,
                isSending: false,
                pendingFiles: [],
                error: null,
                composerValue: '',
                composerDisabled: true,
                recentReactions: REACTION_OPTIONS.slice(0, QUICK_REACTIONS_LIMIT),
                activeMessageEdit: null,
                pendingMessageAction: null,
                activeReply: null,
                pendingMessageFocus: null,
            };
            const pendingReactions = new Set();
            let activePopover = null;
            let pendingScrollToBottom = false;


            const handlePopoverDocumentClick = (event) => {
                if (!activePopover) {
                    return;
                }
                const { element, anchor } = activePopover;
                if (element && element.contains(event.target)) {
                    return;
                }
                if (anchor && anchor.contains(event.target)) {
                    return;
                }
                closeActivePopover();
            };

            const closeActivePopover = () => {
                if (!activePopover) {
                    return;
                }
                const { element, cleanup } = activePopover;
                if (typeof cleanup === 'function') {
                    try {
                        cleanup();
                    } catch (error) {
                        console.debug('Popover cleanup failed', error);
                    }
                }
                if (element && element.parentNode) {
                    element.parentNode.removeChild(element);
                }
                document.removeEventListener('mousedown', handlePopoverDocumentClick, true);
                window.removeEventListener('resize', closeActivePopover);
                window.removeEventListener('scroll', closeActivePopover, true);
                activePopover = null;
            };

            const openPopover = (anchor, buildContent, options = {}) => {
                if (typeof buildContent !== 'function') {
                    return null;
                }
                closeActivePopover();
                const popover = document.createElement('div');
                const placementOption = typeof options.placement === 'string' ? options.placement : 'bottom-end';
                const additionalClassName = typeof options.className === 'string' ? options.className.trim() : '';
                const classNames = ['fc-popover'];
                if (additionalClassName) {
                    additionalClassName.split(/\s+/).forEach((name) => {
                        if (name) {
                            classNames.push(name);
                        }
                    });
                }
                popover.className = classNames.join(' ');
                popover.style.visibility = 'hidden';
                const content = buildContent(popover);
                if (content instanceof Node) {
                    popover.appendChild(content);
                }
                document.body.appendChild(popover);
                const rect = anchor.getBoundingClientRect();
                const offsetY = Number.isFinite(options.offsetY) ? options.offsetY : 8;
                const offsetX = Number.isFinite(options.offsetX) ? options.offsetX : 0;
                const width = popover.offsetWidth;
                const height = popover.offsetHeight;
                const scrollY = window.scrollY || window.pageYOffset || 0;
                const scrollX = window.scrollX || window.pageXOffset || 0;
                const viewportBottom = scrollY + window.innerHeight;
                const viewportTop = scrollY;
                const viewportRight = scrollX + window.innerWidth;
                const minMargin = 8;
                const sanitizePlacement = (value) => {
                    if (value === 'top-end' || value === 'bottom-end') {
                        return value;
                    }
                    return 'bottom-end';
                };
                let resolvedPlacement = sanitizePlacement(placementOption);
                let top = scrollY;
                let left = scrollX;
                const computeAlignedLeft = () => rect.right - width + offsetX + scrollX;
                const clampLeft = (candidate) => {
                    let next = candidate;
                    if (next + width > viewportRight - minMargin) {
                        next = Math.max(viewportRight - width - minMargin, scrollX + minMargin);
                    }
                    if (next < scrollX + minMargin) {
                        next = scrollX + minMargin;
                    }
                    return next;
                };
                const placeTopEnd = () => {
                    const candidateTop = rect.top - height - offsetY + scrollY;
                    if (candidateTop < viewportTop + minMargin) {
                        return null;
                    }
                    return {
                        top: candidateTop,
                        left: clampLeft(computeAlignedLeft()),
                    };
                };
                const placeBottomEnd = () => {
                    const candidateTop = rect.bottom + offsetY + scrollY;
                    if (candidateTop + height > viewportBottom - minMargin && rect.top - height - offsetY > viewportTop + minMargin) {
                        const alternative = placeTopEnd();
                        if (alternative) {
                            resolvedPlacement = 'top-end';
                            return alternative;
                        }
                    }
                    return {
                        top: candidateTop,
                        left: clampLeft(computeAlignedLeft()),
                    };
                };
                let position = null;
                if (resolvedPlacement === 'top-end') {
                    position = placeTopEnd();
                    if (!position) {
                        resolvedPlacement = 'bottom-end';
                        position = placeBottomEnd();
                    }
                } else {
                    position = placeBottomEnd();
                }
                top = position ? position.top : rect.bottom + offsetY + scrollY;
                left = position ? position.left : clampLeft(computeAlignedLeft());
                popover.dataset.placement = resolvedPlacement;
                popover.classList.add(`fc-popover--placement-${resolvedPlacement}`);
                popover.style.top = `${Math.max(scrollY, top)}px`;
                popover.style.left = `${left}px`;
                popover.style.visibility = 'visible';
                activePopover = {
                    element: popover,
                    anchor,
                    cleanup: options.onClose,
                };
                setTimeout(() => {
                    document.addEventListener('mousedown', handlePopoverDocumentClick, true);
                    window.addEventListener('resize', closeActivePopover);
                    window.addEventListener('scroll', closeActivePopover, true);
                }, 0);
                return popover;
            };
            const MAX_COMPOSER_HEIGHT = 220;
            let autoCreatingNote = false;
            const mentionEntityTypes = null;

            let handleCopyResetTimer = null;
            const activeMentionTextRoots = [];

            const scheduleFrame = (callback) => {
                if (typeof window !== 'undefined' && typeof window.requestAnimationFrame === 'function') {
                    window.requestAnimationFrame(callback);
                } else {
                    window.setTimeout(callback, 16);
                }
            };

            const mentionComposer = {
                useMentionComponent: false,
                root: null,
                textareaComponent: null,
                textComponent: null,
                renderScheduled: false,
            };

            const mentionDirectory = {
                handles: [],
                isLoading: false,
                error: null,
            };

            const cleanupMentionTextRoots = () => {
                while (activeMentionTextRoots.length) {
                    const root = activeMentionTextRoots.pop();
                    try {
                        root.unmount();
                    } catch (error) {
                        console.debug('Failed to unmount mention renderer', error);
                    }
                }
            };

            const getActiveTextarea = () => {
                if (mentionComposer.useMentionComponent && mentionRootEl) {
                    return mentionRootEl.querySelector('textarea');
                }
                return inputEl;
            };

            const renderMentionComposer = () => {
                if (!mentionComposer.useMentionComponent || !mentionComposer.root || !mentionComposer.textareaComponent) {
                    return;
                }
                mentionComposer.renderScheduled = false;
                mentionComposer.root.render(
                    window.React.createElement(mentionComposer.textareaComponent, {
                        value: state.composerValue,
                        onChange: (value) => {
                            setComposerValue(value);
                        },
                        onSubmit: (value) => {
                            sendMessage(value);
                        },
                        disabled: state.composerDisabled,
                        rows: 1,
                        placeholder: 'Write a message',
                        entityTypes: mentionEntityTypes,
                        className: 'fc-composer__mention',
                        textareaClassName: 'fc-composer__mention-input',
                    })
                );
                scheduleFrame(() => {
                    autoResizeInput();
                });
            };

            const scheduleMentionComposerRender = (options = {}) => {
                if (!mentionComposer.useMentionComponent || !mentionComposer.root) {
                    return;
                }
                const immediate = Boolean(options.immediate);
                if (immediate) {
                    mentionComposer.renderScheduled = false;
                    renderMentionComposer();
                    return;
                }
                if (mentionComposer.renderScheduled) {
                    return;
                }
                mentionComposer.renderScheduled = true;
                scheduleFrame(() => {
                    renderMentionComposer();
                });
            };

            const ensureMentionComposer = (attempt = 0) => {
                if (!mentionRootEl || mentionComposer.useMentionComponent) {
                    return;
                }
                const components = window.RecordMentionComponents || {};
                if (
                    components.RecordMentionTextarea &&
                    components.RecordMentionText &&
                    window.React &&
                    window.ReactDOM &&
                    typeof window.ReactDOM.createRoot === 'function'
                ) {
                    mentionComposer.useMentionComponent = true;
                    mentionComposer.textareaComponent = components.RecordMentionTextarea;
                    mentionComposer.textComponent = components.RecordMentionText;
                    mentionComposer.root = window.ReactDOM.createRoot(mentionRootEl);
                    mentionRootEl.hidden = false;
                    mentionRootEl.setAttribute('data-ready', 'true');
                    if (inputEl) {
                        inputEl.hidden = true;
                    }
                    renderMentionComposer();
                    renderMessages();
                    return;
                }
                if (attempt < 40) {
                    window.setTimeout(() => ensureMentionComposer(attempt + 1), 150);
                }
            };

            const refreshMentionHandles = () => {
                if (!mentionComposer.useMentionComponent || !mentionComposer.root || !mentionRootEl) {
                    return;
                }
                try {
                    mentionComposer.root.unmount();
                } catch (error) {
                    console.debug('Failed to refresh mention composer', error);
                }
                mentionComposer.root = window.ReactDOM.createRoot(mentionRootEl);
                renderMentionComposer();
            };

            const refreshMentionDirectory = async () => {
                mentionDirectory.isLoading = true;
                mentionDirectory.error = null;
                try {
                    const params = new URLSearchParams();
                    if (mentionEntityTypes && Array.isArray(mentionEntityTypes) && mentionEntityTypes.length) {
                        params.set('entity_types', mentionEntityTypes.join(','));
                    } else if (typeof mentionEntityTypes === 'string' && mentionEntityTypes.trim()) {
                        params.set('entity_types', mentionEntityTypes.trim());
                    }
                    const query = params.toString();
                    const response = await fetch(query ? `/api/records/handles?${query}` : '/api/records/handles');
                    if (!response.ok) {
                        throw new Error('Failed to load mention handles');
                    }
                    const payload = await response.json();
                    const handles = Array.isArray(payload.handles) ? payload.handles : [];
                    mentionDirectory.handles = handles;
                    if (mentionComposer.useMentionComponent) {
                        refreshMentionHandles();
                    }
                } catch (error) {
                    mentionDirectory.error = error;
                    console.debug('Unable to refresh mention directory', error);
                } finally {
                    mentionDirectory.isLoading = false;
                }
                return mentionDirectory.handles;
            };

            const getComposerValue = () => {
                if (mentionComposer.useMentionComponent) {
                    return state.composerValue || '';
                }
                return inputEl ? inputEl.value || '' : '';
            };

            function setComposerValue(value, options = {}) {
                const next = value === null || value === undefined ? '' : String(value);
                const forceRender = Boolean(options.forceRender);
                const immediate = Boolean(options.immediate);
                const previous = state.composerValue;
                const hasChanged = previous !== next;
                state.composerValue = next;
                if (mentionComposer.useMentionComponent) {
                    if (mentionComposer.root && (hasChanged || forceRender)) {
                        scheduleMentionComposerRender({ immediate });
                    } else if (forceRender) {
                        scheduleMentionComposerRender({ immediate });
                    }
                } else if (inputEl) {
                    inputEl.value = next;
                }
                if (!options.skipResize) {
                    scheduleFrame(() => {
                        autoResizeInput();
                    });
                }
            }

            const normalizePreview = (value) => {
                if (value === null || value === undefined) {
                    return '';
                }
                return String(value).replace(/\s+/g, ' ').trim();
            };

            const summarizeTextPreview = (value, limit = 140) => {
                const normalized = normalizePreview(value || '');
                if (!normalized) {
                    return '';
                }
                if (normalized.length <= limit) {
                    return normalized;
                }
                const truncated = normalized.slice(0, Math.max(1, limit - 1)).trimEnd();
                return `${truncated}â€¦`;
            };

            const buildAttachmentPreview = (attachments) => {
                if (!Array.isArray(attachments) || !attachments.length) {
                    return '';
                }
                if (attachments.length === 1) {
                    const attachment = attachments[0] || {};
                    if (attachment.filename) {
                        return attachment.filename;
                    }
                    if (attachment.is_image) {
                        return 'Image attachment';
                    }
                    return 'Attachment';
                }
                return `${attachments.length} attachments`;
            };

            const getMessagePreview = (message, limit = 140) => {
                if (!message) {
                    return '';
                }
                const text = summarizeTextPreview(message.content, limit);
                if (text) {
                    return text;
                }
                return buildAttachmentPreview(message.attachments);
            };

            const formatTimestamp = (value, withTime = true) => {
                if (!value) {
                    return '';
                }
                const date = new Date(value);
                if (Number.isNaN(date.getTime())) {
                    return '';
                }
                const options = withTime
                    ? { year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' }
                    : { year: 'numeric', month: 'short', day: 'numeric' };
                return new Intl.DateTimeFormat(undefined, options).format(date);
            };

            const formatTimerLabel = (seconds) => {
                if (!Number.isFinite(seconds) || seconds <= 0) {
                    return '';
                }
                let remaining = Math.floor(seconds);
                const parts = [];
                const units = [
                    { value: 86400, label: 'd' },
                    { value: 3600, label: 'h' },
                    { value: 60, label: 'm' },
                ];
                units.forEach(({ value, label }) => {
                    if (remaining >= value) {
                        const count = Math.floor(remaining / value);
                        remaining -= count * value;
                        parts.push(`${count}${label}`);
                    }
                });
                if (remaining || parts.length === 0) {
                    parts.push(`${remaining}s`);
                }
                return parts.join('');
            };

            const formatEventWindow = (event) => {
                if (!event || !event.start_at) {
                    return '';
                }
                const start = new Date(event.start_at);
                const end = new Date(event.end_at || event.start_at);
                if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
                    return formatTimestamp(event.start_at, !event.all_day);
                }
                const sameDay = start.toDateString() === end.toDateString();
                if (event.all_day || (start.getHours() === 0 && start.getMinutes() === 0 && sameDay)) {
                    return sameDay
                        ? formatTimestamp(start.toISOString(), false)
                        : `${formatTimestamp(start.toISOString(), false)} â€“ ${formatTimestamp(end.toISOString(), false)}`;
                }
                if (sameDay) {
                    const timeFormatter = new Intl.DateTimeFormat(undefined, {
                        hour: 'numeric',
                        minute: '2-digit',
                    });
                    return `${formatTimestamp(start.toISOString(), true)} â€“ ${timeFormatter.format(end)}`;
                }
                return `${formatTimestamp(start.toISOString(), true)} â€“ ${formatTimestamp(end.toISOString(), true)}`;
            };

            const setBusy = (value) => {
                if (!chatLogEl) {
                    return;
                }
                chatLogEl.setAttribute('aria-busy', value ? 'true' : 'false');
            };

            const showError = (message) => {
                state.error = message;
                if (!errorEl) {
                    return;
                }
                if (message) {
                    errorEl.hidden = false;
                    errorEl.textContent = message;
                } else {
                    errorEl.hidden = true;
                    errorEl.textContent = '';
                }
            };

            const clearError = () => showError('');

            const updateNoteHandleButton = (handle) => {
                if (!noteHandleButton) {
                    return;
                }
                window.clearTimeout(handleCopyResetTimer);
                handleCopyResetTimer = null;
                if (!handle) {
                    noteHandleButton.hidden = true;
                    noteHandleButton.dataset.handle = '';
                    noteHandleButton.textContent = '';
                    noteHandleButton.classList.remove('is-copied');
                    noteHandleButton.disabled = true;
                    noteHandleButton.title = '';
                    return;
                }
                noteHandleButton.hidden = false;
                noteHandleButton.disabled = false;
                noteHandleButton.dataset.handle = handle;
                noteHandleButton.textContent = handle;
                noteHandleButton.classList.remove('is-copied');
                noteHandleButton.title = 'Copy note handle';
            };

            const renderNoteTitle = (note) => {
                if (!noteTitleEl) {
                    return;
                }
                if (!note) {
                    noteTitleEl.textContent = 'Untitled note';
                    noteTitleEl.title = 'Select a note to view messages';
                    noteTitleEl.removeAttribute('data-handle');
                    updateNoteHandleButton('');
                    return;
                }
                const label = normalizePreview(note.title || '') || 'Untitled note';
                const handle = note.handle ? `@${note.handle}` : '';
                noteTitleEl.textContent = label;
                noteTitleEl.title = handle ? `${label} (${handle})` : label;
                if (handle) {
                    noteTitleEl.setAttribute('data-handle', handle);
                } else {
                    noteTitleEl.removeAttribute('data-handle');
                }
                updateNoteHandleButton(handle);
            };

            const sortNotes = () => {
                state.notes.sort((a, b) => {
                    const left = new Date(a.updated_at || a.last_message_at || a.created_at || 0).getTime();
                    const right = new Date(b.updated_at || b.last_message_at || b.created_at || 0).getTime();
                    return right - left;
                });
            };

            const matchesNoteSearch = (note, query) => {
                if (!query) {
                    return true;
                }
                const lowered = query.toLowerCase();
                const fields = [note.title, note.handle, note.last_message_preview];
                return fields.some((field) => normalizePreview(field || '').toLowerCase().includes(lowered));
            };

            const renderNotes = () => {
                if (!notesListEl) {
                    return;
                }
                const trimmedQuery = normalizePreview(state.noteSearch || '');
                const loweredQuery = trimmedQuery.toLowerCase();
                notesListEl.innerHTML = '';
                sortNotes();
                const filtered = loweredQuery
                    ? state.notes.filter((note) => matchesNoteSearch(note, loweredQuery))
                    : state.notes.slice();

                const hasQuery = Boolean(trimmedQuery);
                const exactMatch = hasQuery
                    ? state.notes.some((note) => normalizePreview(note.title || '').toLowerCase() === loweredQuery)
                    : false;
                const createSuggestion = hasQuery && !exactMatch;

                if (!filtered.length && !createSuggestion) {
                    if (noteEmptyEl) {
                        noteEmptyEl.hidden = false;
                        noteEmptyEl.textContent = trimmedQuery
                            ? `No notes match "${trimmedQuery}". Press Enter or click New to create it.`
                            : 'Click "New" to create your first note.';
                    }
                    return;
                }

                if (noteEmptyEl) {
                    if (createSuggestion && !filtered.length) {
                        noteEmptyEl.hidden = false;
                        noteEmptyEl.textContent = `Press Enter or click below to create "${trimmedQuery}".`;
                    } else {
                        noteEmptyEl.hidden = true;
                        noteEmptyEl.textContent = '';
                    }
                }

                const fragment = document.createDocumentFragment();

                if (createSuggestion) {
                    const createButton = document.createElement('button');
                    createButton.type = 'button';
                    createButton.className = 'fc-note fc-note--create';
                    createButton.setAttribute('data-create-note', trimmedQuery);

                    const title = document.createElement('div');
                    title.className = 'fc-note__title';
                    title.textContent = `Create "${trimmedQuery}"`;

                    const hint = document.createElement('div');
                    hint.className = 'fc-note__preview';
                    hint.textContent = 'Start a fresh note with this title.';

                    createButton.appendChild(title);
                    createButton.appendChild(hint);
                    createButton.addEventListener('click', async () => {
                        try {
                            const note = await createNote(trimmedQuery);
                            if (noteSearchEl) {
                                noteSearchEl.value = '';
                            }
                            state.noteSearch = '';
                            renderNotes();
                            if (note) {
                                await selectNote(note.id, { focusComposer: true });
                            }
                        } catch (error) {
                            console.error('Failed to create note', error);
                            showError('Unable to create that note.');
                        }
                    });
                    fragment.appendChild(createButton);
                }

                filtered.forEach((note) => {
                    const button = document.createElement('button');
                    button.type = 'button';
                    button.className = 'fc-note' + (note.id === state.activeNoteId ? ' fc-note--active' : '');
                    button.setAttribute('data-note-id', note.id);
                    button.setAttribute('role', 'option');
                    button.setAttribute('aria-selected', note.id === state.activeNoteId ? 'true' : 'false');

                    const title = document.createElement('div');
                    title.className = 'fc-note__title';
                    title.textContent = note.title;

                    const preview = document.createElement('div');
                    preview.className = 'fc-note__preview';
                    const previewText = normalizePreview(note.last_message_preview || '');
                    preview.textContent = previewText.length > 90 ? `${previewText.slice(0, 87)}â€¦` : previewText;

                    const meta = document.createElement('div');
                    meta.className = 'fc-note__meta';
                    if (note.handle) {
                        const handle = document.createElement('span');
                        handle.className = 'fc-note__handle';
                        handle.textContent = `@${note.handle}`;
                        meta.appendChild(handle);
                    }

                    const timestamp = document.createElement('time');
                    timestamp.className = 'fc-note__timestamp';
                    const stampValue = note.updated_at || note.last_message_at || note.created_at;
                    const stampLabel = formatTimestamp(stampValue, true);
                    if (stampLabel) {
                        timestamp.dateTime = stampValue;
                        timestamp.textContent = stampLabel;
                    }

                    button.appendChild(title);
                    if (previewText) {
                        button.appendChild(preview);
                    }
                    if (meta.childElementCount) {
                        meta.appendChild(timestamp);
                        button.appendChild(meta);
                    } else if (stampLabel) {
                        button.appendChild(timestamp);
                    }
                    button.addEventListener('click', () => {
                        selectNote(note.id, { focusComposer: true });
                    });
                    fragment.appendChild(button);
                });

                notesListEl.appendChild(fragment);
            };

            const renderAttachmentChips = () => {
                if (!attachmentChipsEl) {
                    return;
                }
                attachmentChipsEl.innerHTML = '';
                if (!state.pendingFiles.length) {
                    attachmentChipsEl.hidden = true;
                    return;
                }
                attachmentChipsEl.hidden = false;
                const fragment = document.createDocumentFragment();
                state.pendingFiles.forEach((item) => {
                    const chip = document.createElement('div');
                    chip.className = 'fc-chip';
                    chip.textContent = item.file.name;

                    const removeButton = document.createElement('button');
                    removeButton.type = 'button';
                    removeButton.className = 'fc-chip__remove';
                    removeButton.setAttribute('aria-label', `Remove ${item.file.name}`);
                    removeButton.textContent = 'Remove';
                    removeButton.addEventListener('click', () => {
                        removePendingFile(item.id);
                    });
                    chip.appendChild(removeButton);
                    fragment.appendChild(chip);
                });
                attachmentChipsEl.appendChild(fragment);
            };

            const renderReplyPreview = () => {
                if (!replyPreviewEl) {
                    return;
                }
                replyPreviewEl.innerHTML = '';
                const replyState = state.activeReply;
                if (!replyState) {
                    replyPreviewEl.hidden = true;
                    return;
                }
                replyPreviewEl.hidden = false;
                const details = document.createElement('div');
                details.className = 'fc-composer__reply-details';
                const label = document.createElement('div');
                label.className = 'fc-composer__reply-label';
                label.textContent = replyState.noteId && replyState.noteId !== state.activeNoteId && replyState.noteTitle
                    ? `Replying to ${replyState.authorLabel} in ${replyState.noteTitle}`
                    : `Replying to ${replyState.authorLabel}`;
                details.appendChild(label);
                if (replyState.preview) {
                    const snippet = document.createElement('div');
                    snippet.className = 'fc-composer__reply-snippet';
                    snippet.textContent = replyState.preview;
                    details.appendChild(snippet);
                }
                const cancelButton = document.createElement('button');
                cancelButton.type = 'button';
                cancelButton.className = 'fc-composer__reply-cancel';
                cancelButton.setAttribute('aria-label', 'Cancel reply');
                cancelButton.textContent = 'Cancel';
                cancelButton.addEventListener('click', () => {
                    clearActiveReply();
                });
                replyPreviewEl.appendChild(details);
                replyPreviewEl.appendChild(cancelButton);
            };

            const clearActiveReply = () => {
                if (!state.activeReply) {
                    return;
                }
                state.activeReply = null;
                renderReplyPreview();
            };

            if (noteHandleButton) {
                noteHandleButton.addEventListener('click', async () => {
                    const handle = noteHandleButton.dataset.handle || '';
                    if (!handle) {
                        return;
                    }
                    try {
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            await navigator.clipboard.writeText(handle);
                        } else {
                            const helper = document.createElement('textarea');
                            helper.value = handle;
                            helper.setAttribute('readonly', '');
                            helper.style.position = 'fixed';
                            helper.style.opacity = '0';
                            document.body.appendChild(helper);
                            helper.select();
                            document.execCommand('copy');
                            document.body.removeChild(helper);
                        }
                        window.clearTimeout(handleCopyResetTimer);
                        noteHandleButton.classList.add('is-copied');
                        noteHandleButton.textContent = 'Copied';
                        handleCopyResetTimer = window.setTimeout(() => {
                            updateNoteHandleButton(handle);
                        }, 1400);
                    } catch (error) {
                        console.error('Failed to copy handle', error);
                        window.prompt('Copy handle', handle);
                    }
                });
            }

            if (deleteButton) {
                deleteButton.disabled = true;
                deleteButton.setAttribute('aria-disabled', 'true');
                deleteButton.addEventListener('click', async () => {
                    if (!state.activeNoteId) {
                        return;
                    }
                    const active = state.notes.find((note) => note.id === state.activeNoteId);
                    const label = normalizePreview(active ? active.title : '') || 'this note';
                    const confirmed = window.confirm(`Delete "${label}"? This will remove all messages and files.`);
                    if (!confirmed) {
                        return;
                    }
                    deleteButton.disabled = true;
                    deleteButton.setAttribute('aria-disabled', 'true');
                    try {
                        await deleteNote(state.activeNoteId);
                        const removedId = state.activeNoteId;
                        state.notes = state.notes.filter((note) => note.id !== removedId);
                        state.activeNoteId = '';
                        state.activeNote = null;
                        state.messages = [];
                        renderMessages();
                        renderNoteTitle(null);
                        renderNotes();
                        state.pendingFiles = [];
                        renderAttachmentChips();
                        clearError();
                        refreshMentionHandles();
                        updateComposerAvailability();
                        if (state.notes.length) {
                            await selectNote(state.notes[0].id, { focusComposer: true });
                        }
                    } catch (error) {
                        console.error('Failed to delete note', error);
                        showError('Unable to delete this note.');
                    } finally {
                        updateComposerAvailability();
                    }
                });
            }

            const createMetadataDetails = (metadata) => {
                if (!metadata || typeof metadata !== 'object') {
                    return null;
                }
                const container = document.createElement('div');
                container.className = 'fc-message__meta';
                const action = metadata.action;

                if (action === 'calendar_event_created' && metadata.event) {
                    const heading = document.createElement('div');
                    heading.className = 'fc-message__meta-heading';
                    heading.textContent = 'Calendar event';
                    const body = document.createElement('div');
                    body.className = 'fc-message__meta-body';
                    const event = metadata.event;
                    const lines = [
                        event.title,
                        formatEventWindow(event),
                        normalizePreview(event.location || ''),
                    ].filter(Boolean);
                    body.textContent = lines.join(' â€¢ ');
                    container.appendChild(heading);
                    container.appendChild(body);
                    return container;
                }

                if (action === 'reminder_created' && metadata.reminder) {
                    const heading = document.createElement('div');
                    heading.className = 'fc-message__meta-heading';
                    heading.textContent = 'Reminder';
                    const body = document.createElement('div');
                    body.className = 'fc-message__meta-body';
                    const reminder = metadata.reminder;
                    const parts = [reminder.title];
                    if (reminder.due_at) {
                        const dueLabel = formatTimestamp(reminder.due_at, Boolean(reminder.due_has_time));
                        if (dueLabel) {
                            parts.push(`due ${dueLabel}`);
                        }
                    }
                    if (reminder.notes) {
                        parts.push(reminder.notes);
                    }
                    body.textContent = parts.join(' â€¢ ');
                    container.appendChild(heading);
                    container.appendChild(body);
                    return container;
                }

                if (action === 'task_created' && metadata.task) {
                    const heading = document.createElement('div');
                    heading.className = 'fc-message__meta-heading';
                    heading.textContent = 'Task';
                    const body = document.createElement('div');
                    body.className = 'fc-message__meta-body';
                    const task = metadata.task;
                    const parts = [task.title];
                    if (task.due_at) {
                        const dueLabel = formatTimestamp(task.due_at, Boolean(task.due_has_time));
                        if (dueLabel) {
                            parts.push(`due ${dueLabel}`);
                        }
                    } else if (task.timer_seconds) {
                        const timerLabel = formatTimerLabel(Number(task.timer_seconds));
                        if (timerLabel) {
                            parts.push(`timer ${timerLabel}`);
                        }
                    }
                    if (task.notes) {
                        parts.push(task.notes);
                    }
                    body.textContent = parts.filter(Boolean).join(' â€¢ ');
                    container.appendChild(heading);
                    container.appendChild(body);
                    return container;
                }

                if (action === 'password_lookup') {
                    const heading = document.createElement('div');
                    heading.className = 'fc-message__meta-heading';
                    heading.textContent = 'Passwords';
                    const list = document.createElement('ul');
                    list.className = 'fc-message__meta-list';
                    (metadata.matches || []).slice(0, 5).forEach((match) => {
                        const item = document.createElement('li');
                        const service = match.service || 'Service';
                        const username = match.username || 'â€”';
                        const passwordValue = match.password || 'â€”';
                        item.textContent = `${service}: ${username} / ${passwordValue}`;
                        list.appendChild(item);
                    });
                    container.appendChild(heading);
                    container.appendChild(list);
                    return container;
                }

                if (action === 'report_list' && Array.isArray(metadata.reports)) {
                    const heading = document.createElement('div');
                    heading.className = 'fc-message__meta-heading';
                    heading.textContent = 'Available reports';
                    const list = document.createElement('ul');
                    list.className = 'fc-message__meta-list';
                    metadata.reports.slice(0, 6).forEach((report) => {
                        const item = document.createElement('li');
                        item.textContent = `${report.id}: ${report.name || ''}`.trim();
                        list.appendChild(item);
                    });
                    container.appendChild(heading);
                    container.appendChild(list);
                    return container;
                }

                if (action === 'report_run' && metadata.report) {
                    const heading = document.createElement('div');
                    heading.className = 'fc-message__meta-heading';
                    heading.textContent = metadata.report.name || metadata.report.id || 'Report';
                    const list = document.createElement('ul');
                    list.className = 'fc-message__meta-list';
                    (metadata.report.summary || []).slice(0, 5).forEach((entry) => {
                        const item = document.createElement('li');
                        const label = entry.label || entry.id;
                        const value = entry.display || entry.value;
                        item.textContent = `${label}: ${value}`;
                        list.appendChild(item);
                    });
                    container.appendChild(heading);
                    container.appendChild(list);
                    return container;
                }

                return null;
            };

            const renderMentionText = (container, content) => {
                if (!content) {
                    return false;
                }
                const components = window.RecordMentionComponents || {};
                if (
                    !components.RecordMentionText ||
                    !window.React ||
                    !window.ReactDOM ||
                    typeof window.ReactDOM.createRoot !== 'function'
                ) {
                    return false;
                }
                try {
                    const root = window.ReactDOM.createRoot(container);
                    root.render(
                        window.React.createElement(components.RecordMentionText, {
                            text: content,
                            entityTypes: mentionEntityTypes,
                            className: 'fc-message__text-content',
                        })
                    );
                    activeMentionTextRoots.push(root);
                    return true;
                } catch (error) {
                    console.debug('Failed to render mention text', error);
                    return false;
                }
            };

            const getReactionKey = (messageId, emoji) => `${messageId}:${emoji}`;

            const updateRecentReactions = (emoji) => {
                if (!emoji) {
                    return;
                }
                const normalized = String(emoji).trim();
                if (!normalized) {
                    return;
                }
                const current = Array.isArray(state.recentReactions)
                    ? state.recentReactions.slice()
                    : [];
                const filtered = current.filter((entry) => entry !== normalized);
                filtered.unshift(normalized);
                state.recentReactions = filtered.slice(0, QUICK_REACTIONS_LIMIT);
            };

            const getQuickReactionOptions = () => {
                const seen = new Set();
                const merged = [];
                (state.recentReactions || []).forEach((emoji) => {
                    if (!emoji || seen.has(emoji)) {
                        return;
                    }
                    seen.add(emoji);
                    merged.push(emoji);
                });
                REACTION_OPTIONS.forEach((emoji) => {
                    if (!emoji || seen.has(emoji)) {
                        return;
                    }
                    seen.add(emoji);
                    merged.push(emoji);
                });
                return merged.slice(0, QUICK_REACTIONS_LIMIT);
            };

            const isReactionPending = (messageId, emoji) => {
                if (!messageId || !emoji) {
                    return false;
                }
                return pendingReactions.has(getReactionKey(messageId, emoji));
            };

            const setReactionPending = (messageId, emoji, pending) => {
                if (!messageId || !emoji) {
                    return;
                }
                const key = getReactionKey(messageId, emoji);
                if (pending) {
                    pendingReactions.add(key);
                } else {
                    pendingReactions.delete(key);
                }
            };

            const upsertMessage = (message) => {
                if (!message || !message.id) {
                    return;
                }
                const index = state.messages.findIndex((entry) => entry.id === message.id);
                if (index >= 0) {
                    const existing = state.messages[index];
                    state.messages[index] = { ...existing, ...message };
                } else {
                    state.messages.push(message);
                }
            };

            const handleReactionToggle = async (messageId, emoji) => {
                if (!messageId || !emoji) {
                    return;
                }
                if (isReactionPending(messageId, emoji)) {
                    return;
                }
                setReactionPending(messageId, emoji, true);
                renderMessages();
                try {
                    const response = await fetch(REACTION_ENDPOINT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message_id: messageId, emoji }),
                    });
                    if (!response.ok) {
                        throw new Error('Failed to update reaction');
                    }
                    const payload = await response.json();
                    if (payload && payload.message) {
                        upsertMessage(payload.message);
                        clearError();
                        if (payload.action === 'added') {
                            updateRecentReactions(emoji);
                        }
                    }
                } catch (error) {
                    console.error('Failed to toggle reaction', error);
                    showError('Unable to update reaction.');
                } finally {
                    setReactionPending(messageId, emoji, false);
                    renderMessages();
                }
            };

            const createReactionButton = (message, emoji, summary) => {
                if (!message || !message.id || !emoji) {
                    return null;
                }
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'fc-reaction';
                const reacted = summary && summary.reacted;
                const count = summary && Number.isFinite(summary.count) ? Number(summary.count) : 0;
                button.textContent = count > 0 ? `${emoji} ${count}` : emoji;
                button.setAttribute('aria-pressed', reacted ? 'true' : 'false');
                if (reacted) {
                    button.classList.add('is-active');
                }
                const pending = isReactionPending(message.id, emoji);
                if (pending) {
                    button.classList.add('is-pending');
                    button.disabled = true;
                }
                button.addEventListener('click', () => {
                    handleReactionToggle(message.id, emoji);
                });
                let description = `React with ${emoji}`;
                if (summary && Array.isArray(summary.reactors) && summary.reactors.length) {
                    description = `${emoji} reaction from ${summary.reactors.join(', ')}`;
                }
                button.title = description;
                button.setAttribute('aria-label', description);
                if (count === 0) {
                    button.classList.add('fc-reaction--ghost');
                }
                return button;
            };

            const renderReactionRow = (message) => {
                if (!message || !message.id) {
                    return null;
                }
                const container = document.createElement('div');
                container.className = 'fc-message__reactions';
                let hasVisible = false;
                if (Array.isArray(message.reactions)) {
                    message.reactions.forEach((reaction) => {
                        if (!reaction || !reaction.emoji) {
                            return;
                        }
                        const button = createReactionButton(message, reaction.emoji, reaction);
                        if (button) {
                            container.appendChild(button);
                            hasVisible = true;
                        }
                    });
                }
                if (!hasVisible) {
                    return null;
                }
                return container;
            };

            const isUserMessage = (message) => {
                return String(message && message.author && message.author.toLowerCase()) === 'user';
            };

            const isMessageBeingEdited = (messageId) => {
                return Boolean(state.activeMessageEdit && state.activeMessageEdit.id === messageId);
            };

            const setMessageEditValue = (value) => {
                if (!state.activeMessageEdit) {
                    return;
                }
                state.activeMessageEdit = {
                    ...state.activeMessageEdit,
                    value,
                };
            };

            const startMessageEdit = (message) => {
                if (!message || !message.id) {
                    return;
                }
                closeActivePopover();
                state.activeMessageEdit = {
                    id: message.id,
                    noteId: message.note_id,
                    value: message.content || '',
                    pending: false,
                };
                renderMessages();
                scheduleFrame(() => {
                    const textarea = document.querySelector(`[data-edit-textarea="${message.id}"]`);
                    if (textarea) {
                        textarea.focus();
                        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                    }
                });
            };

            const cancelMessageEdit = () => {
                if (!state.activeMessageEdit) {
                    return;
                }
                state.activeMessageEdit = null;
                renderMessages();
            };

            const submitMessageEdit = async () => {
                const editState = state.activeMessageEdit;
                if (!editState || editState.pending) {
                    return;
                }
                const messageId = editState.id;
                const content = editState.value || '';
                const trimmed = normalizePreview(content);
                if (!trimmed) {
                    showError('Add some text before saving edits.');
                    return;
                }
                const originalState = { ...editState };
                state.activeMessageEdit = { ...editState, pending: true };
                renderMessages();
                try {
                    const response = await fetch(`${MESSAGE_ENDPOINT}/${encodeURIComponent(messageId)}`, {
                        method: 'PATCH',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ content }),
                    });
                    if (!response.ok) {
                        throw new Error('Failed to save message edits');
                    }
                    const payload = await response.json();
                    if (payload.message) {
                        upsertMessage(payload.message);
                    }
                    if (payload.note) {
                        updateNoteFromResponse(payload.note);
                    }
                    state.activeMessageEdit = null;
                    clearError();
                } catch (error) {
                    console.error('Failed to update message', error);
                    showError('Unable to update that message.');
                    state.activeMessageEdit = { ...originalState, pending: false };
                } finally {
                    renderMessages();
                }
            };

            const replyToMessage = (message) => {
                if (!message) {
                    return;
                }
                closeActivePopover();
                const authorLabel = formatMessageAuthorLabel(message.author);
                let noteTitle = '';
                if (message.note_id && message.note_id !== state.activeNoteId) {
                    const related = state.notes.find((entry) => entry.id === message.note_id);
                    noteTitle = normalizePreview(related ? related.title : '') || 'Untitled note';
                } else if (state.activeNote) {
                    noteTitle = normalizePreview(state.activeNote.title) || '';
                }
                state.activeReply = {
                    id: message.id || '',
                    noteId: message.note_id || state.activeNoteId || '',
                    noteTitle,
                    authorLabel,
                    preview: getMessagePreview(message, 120),
                };
                renderReplyPreview();
                scheduleFrame(() => {
                    const textarea = getActiveTextarea();
                    if (textarea) {
                        textarea.focus();
                        textarea.setSelectionRange(textarea.value.length, textarea.value.length);
                    }
                });
            };

            const setPendingMessageAction = (action) => {
                state.pendingMessageAction = action;
            };

            const isMessageActionPending = (messageId) => {
                const pending = state.pendingMessageAction;
                return Boolean(pending && pending.messageId === messageId);
            };

            const handleDeleteMessage = async (message) => {
                if (!message || !message.id) {
                    return;
                }
                const confirmDelete = window.confirm('Delete this message?');
                if (!confirmDelete) {
                    return;
                }
                closeActivePopover();
                setPendingMessageAction({ type: 'delete', messageId: message.id });
                renderMessages();
                try {
                    const response = await fetch(`${MESSAGE_ENDPOINT}/${encodeURIComponent(message.id)}`, {
                        method: 'DELETE',
                    });
                    if (!response.ok) {
                        throw new Error('Failed to delete');
                    }
                    const payload = await response.json();
                    state.messages = state.messages.filter((entry) => entry.id !== message.id);
                    if (payload.note) {
                        updateNoteFromResponse(payload.note);
                    }
                    clearError();
                } catch (error) {
                    console.error('Failed to delete message', error);
                    showError('Unable to delete that message.');
                } finally {
                    setPendingMessageAction(null);
                    renderMessages();
                }
            };

            const handleForwardMessage = async (message, targetNoteId) => {
                if (!message || !message.id || !targetNoteId) {
                    return;
                }
                closeActivePopover();
                setPendingMessageAction({ type: 'forward', messageId: message.id });
                renderMessages();
                try {
                    const response = await fetch(FORWARD_ENDPOINT, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ message_id: message.id, target_note_id: targetNoteId }),
                    });
                    if (!response.ok) {
                        throw new Error('Failed to forward');
                    }
                    const payload = await response.json();
                    if (payload.message) {
                        if (payload.message.note_id === state.activeNoteId) {
                            upsertMessage(payload.message);
                        }
                    }
                    if (payload.note) {
                        updateNoteFromResponse(payload.note);
                    }
                    clearError();
                } catch (error) {
                    console.error('Failed to forward message', error);
                    showError('Unable to forward that message.');
                } finally {
                    setPendingMessageAction(null);
                    renderMessages();
                }
            };

            const handleCopyMessageText = async (message) => {
                if (!navigator.clipboard || !message) {
                    return;
                }
                try {
                    await navigator.clipboard.writeText(message.content || '');
                    closeActivePopover();
                } catch (error) {
                    console.error('Failed to copy message text', error);
                    showError('Unable to copy message text.');
                }
            };

            const handleCopyMessageLink = async (message) => {
                if (!navigator.clipboard || !message || !message.id) {
                    return;
                }
                const origin = window.location.origin || window.location.href;
                const url = `${origin.replace(/\/#?$/, '')}/firenotes#message-${message.id}`;
                try {
                    await navigator.clipboard.writeText(url);
                    closeActivePopover();
                } catch (error) {
                    console.error('Failed to copy message link', error);
                    showError('Unable to copy message link.');
                }
            };

            const openReactionPicker = (anchor, message) => {
                if (!anchor || !message) {
                    return;
                }
                openPopover(anchor, () => {
                    const container = document.createElement('div');
                    container.className = 'fc-popover__emoji';
                    REACTION_OPTIONS.forEach((emoji) => {
                        const button = document.createElement('button');
                        button.type = 'button';
                        button.className = 'fc-popover__emoji-button';
                        button.textContent = emoji;
                        button.setAttribute('aria-label', `React with ${emoji}`);
                        button.addEventListener('click', (event) => {
                            event.preventDefault();
                            closeActivePopover();
                            handleReactionToggle(message.id, emoji);
                        });
                        container.appendChild(button);
                    });
                    return container;
                });
            };

            const openForwardPicker = (anchor, message) => {
                if (!anchor || !message) {
                    return;
                }
                openPopover(anchor, () => {
                    const panel = document.createElement('div');
                    panel.className = 'fc-popover__panel';
                    const title = document.createElement('div');
                    title.className = 'fc-popover__title';
                    title.textContent = 'Forward message toâ€¦';
                    panel.appendChild(title);
                    const list = document.createElement('div');
                    list.className = 'fc-popover__list';
                    const notes = Array.isArray(state.notes) ? state.notes : [];
                    if (!notes.length) {
                        const empty = document.createElement('div');
                        empty.className = 'fc-popover__empty';
                        empty.textContent = 'No notes available';
                        panel.appendChild(empty);
                        return panel;
                    }
                    notes.forEach((note) => {
                        if (!note || !note.id) {
                            return;
                        }
                        const item = document.createElement('button');
                        item.type = 'button';
                        item.className = 'fc-popover__item';
                        item.textContent = note.title || 'Untitled note';
                        if (state.pendingMessageAction && state.pendingMessageAction.messageId === message.id) {
                            item.disabled = true;
                        }
                        item.addEventListener('click', (event) => {
                            event.preventDefault();
                            handleForwardMessage(message, note.id);
                        });
                        list.appendChild(item);
                    });
                    panel.appendChild(list);
                    return panel;
                });
            };

            const openMessageMenu = (anchor, message) => {
                if (!anchor || !message) {
                    return;
                }
                openPopover(anchor, () => {
                    const menu = document.createElement('div');
                    menu.className = 'fc-popover__menu';
                    const addItem = (label, handler, options = {}) => {
                        const item = document.createElement('button');
                        item.type = 'button';
                        item.className = 'fc-popover__menu-item';
                        if (options.destructive) {
                            item.classList.add('is-destructive');
                        }
                        item.textContent = label;
                        if (options.disabled) {
                            item.disabled = true;
                        }
                        item.addEventListener('click', (event) => {
                            event.preventDefault();
                            handler();
                        });
                        menu.appendChild(item);
                    };
                    addItem('Add Reaction', () => {
                        closeActivePopover();
                        openReactionPicker(anchor, message);
                    });
                    if (isUserMessage(message)) {
                        addItem('Edit Message', () => {
                            startMessageEdit(message);
                        }, { disabled: isMessageBeingEdited(message.id) });
                    }
                    addItem('Reply', () => {
                        replyToMessage(message);
                    });
                    addItem('Forward', () => {
                        openForwardPicker(anchor, message);
                    });
                    addItem('Copy Text', () => {
                        handleCopyMessageText(message);
                    });
                    addItem('Copy Message Link', () => {
                        handleCopyMessageLink(message);
                    });
                    addItem(
                        'Delete Message',
                        () => {
                            handleDeleteMessage(message);
                        },
                        {
                            destructive: true,
                            disabled: !message.id || isMessageActionPending(message.id),
                        }
                    );
                    return menu;
                }, {
                    placement: 'top-end',
                    offsetY: 6,
                    className: 'fc-popover--badge',
                });
            };

            const createToolbarButton = (label, icon, handler) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'fc-message__toolbar-button';
                button.title = label;
                button.setAttribute('aria-label', label);
                if (icon) {
                    const iconSpan = document.createElement('span');
                    iconSpan.className = 'fc-message__toolbar-icon';
                    iconSpan.textContent = icon;
                    button.appendChild(iconSpan);
                }
                button.addEventListener('click', (event) => {
                    event.preventDefault();
                    handler(event.currentTarget || button);
                });
                return button;
            };

            const createQuickReactionButton = (message, emoji) => {
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'fc-message__toolbar-button fc-message__toolbar-button--emoji';
                button.textContent = emoji;
                button.setAttribute('aria-label', `React with ${emoji}`);
                if (isReactionPending(message.id, emoji) || isMessageActionPending(message.id)) {
                    button.disabled = true;
                }
                button.addEventListener('click', (event) => {
                    event.preventDefault();
                    handleReactionToggle(message.id, emoji);
                });
                return button;
            };

            const createMessageToolbar = (message) => {
                const toolbar = document.createElement('div');
                toolbar.className = 'fc-message__toolbar';
                if (!message || !message.id) {
                    return toolbar;
                }
                const quickGroup = document.createElement('div');
                quickGroup.className = 'fc-message__toolbar-group fc-message__toolbar-group--reactions';
                getQuickReactionOptions().forEach((emoji) => {
                    quickGroup.appendChild(createQuickReactionButton(message, emoji));
                });
                if (quickGroup.children.length) {
                    toolbar.appendChild(quickGroup);
                }
                const actionsGroup = document.createElement('div');
                actionsGroup.className = 'fc-message__toolbar-group';
                const addReactionButton = createToolbarButton('Add reaction', 'ðŸ˜Š', (anchor) => {
                    openReactionPicker(anchor, message);
                });
                actionsGroup.appendChild(addReactionButton);
                if (isUserMessage(message)) {
                    const editButton = createToolbarButton('Edit message', 'âœï¸', () => {
                        startMessageEdit(message);
                    });
                    if (isMessageBeingEdited(message.id)) {
                        editButton.disabled = true;
                    }
                    actionsGroup.appendChild(editButton);
                }
                const forwardButton = createToolbarButton('Forward message', 'â†—', (anchor) => {
                    openForwardPicker(anchor, message);
                });
                if (isMessageActionPending(message.id)) {
                    forwardButton.disabled = true;
                }
                actionsGroup.appendChild(forwardButton);
                const menuButton = createToolbarButton('More actions', 'â‹¯', (anchor) => {
                    openMessageMenu(anchor, message);
                });
                actionsGroup.appendChild(menuButton);
                toolbar.appendChild(actionsGroup);
                return toolbar;
            };

            const createMessageEditForm = (message, editState) => {
                const form = document.createElement('form');
                form.className = 'fc-message__edit';
                const textarea = document.createElement('textarea');
                textarea.className = 'fc-message__edit-input';
                textarea.value = editState.value || '';
                textarea.rows = Math.min(12, Math.max(3, textarea.value.split('\n').length));
                textarea.setAttribute('data-edit-textarea', message.id);
                textarea.addEventListener('input', () => {
                    setMessageEditValue(textarea.value);
                });
                form.appendChild(textarea);
                const actions = document.createElement('div');
                actions.className = 'fc-message__edit-actions';
                const saveButton = document.createElement('button');
                saveButton.type = 'submit';
                saveButton.className = 'fc-button fc-button--primary';
                saveButton.textContent = editState.pending ? 'Savingâ€¦' : 'Save';
                saveButton.disabled = !!editState.pending;
                const cancelButton = document.createElement('button');
                cancelButton.type = 'button';
                cancelButton.className = 'fc-button';
                cancelButton.textContent = 'Cancel';
                cancelButton.disabled = !!editState.pending;
                cancelButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    cancelMessageEdit();
                });
                actions.appendChild(cancelButton);
                actions.appendChild(saveButton);
                form.appendChild(actions);
                form.addEventListener('submit', (event) => {
                    event.preventDefault();
                    submitMessageEdit();
                });
                return form;
            };

            const formatMessageAuthorLabel = (author) => {
                const normalized = String(author || '').trim();
                if (!normalized) {
                    return '@firenotes';
                }
                const lowered = normalized.toLowerCase();
                if (lowered === 'user') {
                    return 'You';
                }
                if (lowered === 'assistant') {
                    return '@firenotes';
                }
                if (normalized.startsWith('@')) {
                    return normalized;
                }
                return `@${normalized}`;
            };

            const requestMessageFocus = (noteId, messageId) => {
                if (!messageId) {
                    return;
                }
                state.pendingMessageFocus = {
                    noteId: noteId || '',
                    messageId,
                    attempts: 0,
                };
            };

            const focusMessageIfNeeded = () => {
                const pending = state.pendingMessageFocus;
                if (!pending || !pending.messageId) {
                    return false;
                }
                if (pending.noteId && pending.noteId !== state.activeNoteId) {
                    return false;
                }
                const target = document.getElementById(`message-${pending.messageId}`);
                if (!target) {
                    pending.attempts = (pending.attempts || 0) + 1;
                    if (pending.attempts > 20) {
                        state.pendingMessageFocus = null;
                    }
                    return false;
                }
                pendingScrollToBottom = false;
                try {
                    target.scrollIntoView({ block: 'center', behavior: 'smooth' });
                } catch (error) {
                    target.scrollIntoView({ block: 'center' });
                }
                target.classList.add('is-highlighted');
                window.setTimeout(() => {
                    target.classList.remove('is-highlighted');
                }, 1800);
                state.pendingMessageFocus = null;
                return true;
            };

            const scheduleMessageFocus = () => {
                if (focusMessageIfNeeded()) {
                    return;
                }
                window.setTimeout(() => {
                    focusMessageIfNeeded();
                }, 120);
            };

            const navigateToMessageReference = async (reference) => {
                if (!reference || !reference.id) {
                    return;
                }
                pendingScrollToBottom = false;
                const targetNoteId = reference.note_id || state.activeNoteId || '';
                requestMessageFocus(targetNoteId, reference.id);
                if (targetNoteId && targetNoteId !== state.activeNoteId) {
                    try {
                        await selectNote(targetNoteId, { focusComposer: false });
                    } catch (error) {
                        console.error('Failed to navigate to referenced message', error);
                    } finally {
                        scheduleMessageFocus();
                    }
                } else {
                    renderMessages();
                    scheduleMessageFocus();
                }
            };

            const createForwardReferenceElement = (reference, options = {}) => {
                if (!reference) {
                    return null;
                }
                const messageId = reference.id || reference.message_id || reference.messageId;
                if (!messageId) {
                    return null;
                }
                const noteId = reference.note_id || reference.noteId || '';
                const contentText = (reference.content || reference.preview || '').trim();
                if (!contentText && !reference.note_title) {
                    return null;
                }
                const authorLabel = formatMessageAuthorLabel(reference.author || reference.author_label || '');
                const timestampLabel = reference.created_at ? formatTimestamp(reference.created_at, true) : '';
                const noteLabel = reference.note_title ? reference.note_title : '';
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'fc-message__forwarded';
                const header = document.createElement('span');
                header.className = 'fc-message__forwarded-header';
                header.textContent = authorLabel ? `Forwarded from ${authorLabel}` : 'Forwarded message';
                button.appendChild(header);
                if (noteLabel || timestampLabel) {
                    const meta = document.createElement('span');
                    meta.className = 'fc-message__forwarded-meta';
                    const parts = [];
                    if (noteLabel) {
                        parts.push(noteLabel);
                    }
                    if (timestampLabel) {
                        parts.push(timestampLabel);
                    }
                    meta.textContent = parts.join(' - ');
                    button.appendChild(meta);
                }
                if (contentText) {
                    const body = document.createElement('span');
                    body.className = 'fc-message__forwarded-content';
                    body.textContent = contentText;
                    button.appendChild(body);
                }
                const ariaPreview = summarizeTextPreview(contentText || noteLabel, 160) || 'forwarded message';
                const ariaLabel = options.ariaLabel
                    || `View forwarded message${authorLabel ? ` from ${authorLabel}` : ''}: ${ariaPreview}`;
                button.setAttribute('aria-label', ariaLabel);
                const tooltipLines = [header.textContent];
                if (noteLabel || timestampLabel) {
                    tooltipLines.push((noteLabel && timestampLabel) ? `${noteLabel} - ${timestampLabel}` : (noteLabel || timestampLabel));
                }
                if (contentText) {
                    tooltipLines.push(contentText);
                }
                button.title = tooltipLines.filter(Boolean).join('\n');
                button.addEventListener('click', async (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    await navigateToMessageReference({ id: messageId, note_id: noteId });
                });
                return button;
            };

            const createMessageReferenceElement = (reference, options = {}) => {
                if (!reference) {
                    return null;
                }
                if ((options.variant || 'reply') === 'forward') {
                    return createForwardReferenceElement(reference, options);
                }
                const messageId = reference.id || reference.message_id || reference.messageId;
                if (!messageId) {
                    return null;
                }
                const noteId = reference.note_id || reference.noteId || '';
                const authorLabel = formatMessageAuthorLabel(reference.author || reference.author_label || '');
                const button = document.createElement('button');
                button.type = 'button';
                button.className = 'fc-message__reference';
                const icon = document.createElement('span');
                icon.className = 'fc-message__reference-icon';
                icon.textContent = options.icon || 'â†©ï¸Ž';
                button.appendChild(icon);
                const textGroup = document.createElement('span');
                textGroup.className = 'fc-message__reference-text';
                button.appendChild(textGroup);
                const labelText = authorLabel ? `Replying to ${authorLabel}` : 'Replying to message';
                if (labelText) {
                    const label = document.createElement('span');
                    label.className = 'fc-message__reference-label';
                    label.textContent = labelText;
                    textGroup.appendChild(label);
                }
                const previewText = summarizeTextPreview(reference.preview || reference.content || '', 70);
                if (labelText && previewText) {
                    const separator = document.createElement('span');
                    separator.className = 'fc-message__reference-separator';
                    separator.setAttribute('aria-hidden', 'true');
                    separator.textContent = 'Â·';
                    textGroup.appendChild(separator);
                }
                if (previewText) {
                    const preview = document.createElement('span');
                    preview.className = 'fc-message__reference-preview';
                    preview.textContent = previewText;
                    textGroup.appendChild(preview);
                }
                const tooltipParts = [];
                if (labelText) {
                    tooltipParts.push(labelText);
                }
                if (previewText) {
                    tooltipParts.push(previewText);
                }
                if (tooltipParts.length) {
                    button.title = tooltipParts.join(' Â· ');
                }
                const ariaLabel = options.ariaLabel
                    || `View reply from ${authorLabel || 'the original message'}`;
                button.setAttribute('aria-label', ariaLabel);
                button.addEventListener('click', async (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    await navigateToMessageReference({ id: messageId, note_id: noteId });
                });
                return button;
            };

            const createMessageElement = (message, previousMessage = null) => {
                const author = (message.author || '').toLowerCase();
                const isUser = author === 'user';
                const shouldGroup = shouldGroupWithPreviousMessage(message, previousMessage);
                const wrapper = document.createElement('article');
                const wrapperClasses = ['fc-message', isUser ? 'fc-message--user' : 'fc-message--assistant'];
                if (shouldGroup) {
                    wrapperClasses.push('fc-message--grouped');
                }
                wrapper.className = wrapperClasses.join(' ');
                if (message.id) {
                    wrapper.id = `message-${message.id}`;
                }
                if (isMessageActionPending(message.id)) {
                    wrapper.classList.add('is-processing');
                }
                const metadata = message.metadata || {};
                if (metadata.action === 'task_created' && metadata.task) {
                    wrapper.classList.add('fc-message--task');
                    if (metadata.task.completed) {
                        wrapper.classList.add('fc-message--task-completed');
                    }
                }
                const editingState = isMessageBeingEdited(message.id) ? state.activeMessageEdit : null;
                if (editingState) {
                    wrapper.classList.add('is-editing');
                }

                const bubble = document.createElement('div');
                bubble.className = 'fc-message__bubble';

                const main = document.createElement('div');
                main.className = 'fc-message__main';

                const header = document.createElement('div');
                header.className = 'fc-message__header';

                const authorLabel = document.createElement('span');
                authorLabel.className = 'fc-message__author';
                authorLabel.textContent = formatMessageAuthorLabel(message.author);
                header.appendChild(authorLabel);

                const timestamp = document.createElement('time');
                timestamp.className = 'fc-message__timestamp';
                let stampLabel = '';
                if (message.created_at) {
                    timestamp.dateTime = message.created_at;
                    stampLabel = formatTimestamp(message.created_at, true) || '';
                    if (stampLabel) {
                        timestamp.textContent = stampLabel;
                    }
                }
                header.appendChild(timestamp);

                if (metadata.edited_at) {
                    const editedIndicator = document.createElement('span');
                    editedIndicator.className = 'fc-message__edited';
                    editedIndicator.textContent = '(edited)';
                    header.appendChild(editedIndicator);
                }

                if (shouldGroup) {
                    header.classList.add('fc-message__header--grouped');
                    header.setAttribute('aria-hidden', 'true');
                    if (stampLabel) {
                        bubble.title = stampLabel;
                    }
                }

                main.appendChild(header);

                const body = document.createElement('div');
                body.className = 'fc-message__body';

                const appendAttachments = () => {
                    if (!Array.isArray(message.attachments) || !message.attachments.length) {
                        return;
                    }
                    const attachments = document.createElement('div');
                    attachments.className = 'fc-message__attachments';
                    message.attachments.forEach((attachment) => {
                        if (attachment.is_image) {
                            const figure = document.createElement('figure');
                            figure.className = 'fc-message__attachment fc-message__attachment--image';
                            const img = document.createElement('img');
                            img.src = attachment.url;
                            img.alt = attachment.filename || 'Image attachment';
                            figure.appendChild(img);
                            attachments.appendChild(figure);
                        } else {
                            const link = document.createElement('a');
                            link.className = 'fc-message__attachment';
                            link.href = attachment.url;
                            link.target = '_blank';
                            link.rel = 'noopener noreferrer';
                            link.textContent = attachment.filename || 'Download file';
                            attachments.appendChild(link);
                        }
                    });
                    body.appendChild(attachments);
                };

                if (editingState) {
                    body.appendChild(createMessageEditForm(message, editingState));
                    appendAttachments();
                } else {
                    if (metadata.reply_to) {
                        const replyReference = createMessageReferenceElement(metadata.reply_to, { variant: 'reply' });
                        if (replyReference) {
                            body.appendChild(replyReference);
                        }
                    }
                    if (metadata.forwarded_from) {
                        const forwardReference = createMessageReferenceElement(metadata.forwarded_from, {
                            variant: 'forward',
                        });
                        if (forwardReference) {
                            body.appendChild(forwardReference);
                        }
                    }
                    if (message.content) {
                        const text = document.createElement('div');
                        text.className = 'fc-message__text';
                        if (!renderMentionText(text, message.content)) {
                            text.textContent = message.content;
                        }
                        body.appendChild(text);
                    }
                    appendAttachments();
                    const metadataDetails = createMetadataDetails(metadata);
                    if (metadataDetails) {
                        body.appendChild(metadataDetails);
                    }
                    const reactionsRow = renderReactionRow(message);
                    if (reactionsRow) {
                        body.appendChild(reactionsRow);
                    }
                }

                main.appendChild(body);
                bubble.appendChild(main);

                const toolbar = createMessageToolbar(message);
                bubble.appendChild(toolbar);

                wrapper.appendChild(bubble);
                return wrapper;
            };

            const matchesMessageSearch = (message, query) => {
                if (!query) {
                    return true;
                }
                const lowered = query.toLowerCase();
                const content = normalizePreview(message.content || '').toLowerCase();
                if (content.includes(lowered)) {
                    return true;
                }
                if (Array.isArray(message.attachments)) {
                    if (message.attachments.some((attachment) => (attachment.filename || '').toLowerCase().includes(lowered))) {
                        return true;
                    }
                }
                try {
                    const metadataText = JSON.stringify(message.metadata || {});
                    if (metadataText && metadataText.toLowerCase().includes(lowered)) {
                        return true;
                    }
                } catch (error) {
                    console.debug('Unable to search metadata', error);
                }
                return false;
            };

            const renderMessages = () => {
                if (!chatLogEl) {
                    return;
                }
                if (
                    state.activeMessageEdit &&
                    !state.messages.some((entry) => entry && entry.id === state.activeMessageEdit.id)
                ) {
                    state.activeMessageEdit = null;
                }
                cleanupMentionTextRoots();
                closeActivePopover();
                const previousScrollTop = scrollPort ? scrollPort.scrollTop : 0;
                const shouldStickToBottom = isNearBottom(scrollPort);
                const replaceWithPlaceholder = (message) => {
                    const placeholder = document.createElement('div');
                    placeholder.className = 'fc-chat-placeholder';
                    placeholder.textContent = message;
                    setChatLogContent(placeholder);
                };
                if (!state.activeNoteId) {
                    replaceWithPlaceholder('Create a note to start chatting.');
                    if (scrollPort) {
                        scrollPort.scrollTop = 0;
                    }
                    return;
                }
                if (state.isLoadingMessages) {
                    setBusy(true);
                    replaceWithPlaceholder('Loading noteâ€¦');
                    if (scrollPort) {
                        scrollPort.scrollTop = 0;
                    }
                    return;
                }
                setBusy(false);
                const trimmedQuery = normalizePreview(state.messageSearch || '');
                const lowered = trimmedQuery.toLowerCase();
                const visible = lowered
                    ? state.messages.filter((message) => matchesMessageSearch(message, lowered))
                    : state.messages.slice();
                if (!visible.length) {
                    replaceWithPlaceholder(lowered ? 'No matches in this note.' : 'Drop a thought to get started.');
                    if (scrollPort) {
                        scrollPort.scrollTop = 0;
                    }
                    return;
                }
                const fragment = document.createDocumentFragment();
                visible.forEach((message) => {
                    const messageIndex = state.messages.indexOf(message);
                    const previousMessage = messageIndex > 0 ? state.messages[messageIndex - 1] : null;
                    fragment.appendChild(createMessageElement(message, previousMessage));
                });
                setChatLogContent(fragment);
                if (focusMessageIfNeeded()) {
                    return;
                }
                if (!scrollPort) {
                    return;
                }
                if (pendingScrollToBottom) {
                    jumpToBottom();
                    pendingScrollToBottom = false;
                    return;
                }
                if (lowered) {
                    scrollPort.scrollTop = 0;
                    return;
                }
                if (shouldStickToBottom) {
                    jumpToBottom();
                    return;
                }
                const maxScrollTop = Math.max(0, scrollPort.scrollHeight - scrollPort.clientHeight);
                const targetScrollTop = Math.min(previousScrollTop, maxScrollTop);
                scrollPort.scrollTop = targetScrollTop;
            };

            const autoResizeInput = () => {
                const textarea = getActiveTextarea();
                if (!textarea) {
                    return;
                }
                textarea.style.height = 'auto';
                const targetHeight = Math.min(MAX_COMPOSER_HEIGHT, textarea.scrollHeight || 0);
                const finalHeight = Math.max(targetHeight, 44);
                textarea.style.height = `${finalHeight}px`;
                if (mentionComposer.useMentionComponent && mentionRootEl) {
                    const overlay = mentionRootEl.querySelector('.record-mention-textarea__overlay');
                    if (overlay) {
                        overlay.style.height = `${finalHeight}px`;
                    }
                }
            };

            const setComposerEnabled = (enabled) => {
                state.composerDisabled = !enabled;
                if (attachmentButtonEl) {
                    attachmentButtonEl.disabled = !enabled;
                }
                if (composerEl) {
                    composerEl.setAttribute('data-disabled', enabled ? 'false' : 'true');
                }
                if (deleteButton) {
                    deleteButton.disabled = !enabled;
                    deleteButton.setAttribute('aria-disabled', enabled ? 'false' : 'true');
                }
                if (mentionComposer.useMentionComponent) {
                    renderMentionComposer();
                } else if (inputEl) {
                    inputEl.disabled = !enabled;
                    if (!enabled) {
                        inputEl.value = '';
                    }
                }
                if (!enabled) {
                    state.pendingFiles = [];
                    renderAttachmentChips();
                    setComposerValue('', { forceRender: true });
                    clearActiveReply();
                } else {
                    autoResizeInput();
                    renderReplyPreview();
                }
            };

            const updateComposerAvailability = () => {
                const enabled = Boolean(state.activeNoteId);
                setComposerEnabled(enabled);
                if (enabled) {
                    autoResizeInput();
                }
            };

            const resetComposer = () => {
                setComposerValue('');
                state.pendingFiles = [];
                renderAttachmentChips();
                clearActiveReply();
                renderReplyPreview();
            };

            const updateNoteFromResponse = (note) => {
                if (!note || !note.id) {
                    return;
                }
                const existingIndex = state.notes.findIndex((entry) => entry.id === note.id);
                let handleChanged = false;
                if (existingIndex >= 0) {
                    const existing = state.notes[existingIndex];
                    handleChanged = (existing.handle || '') !== (note.handle || '');
                    state.notes[existingIndex] = { ...existing, ...note };
                } else {
                    state.notes.push(note);
                    handleChanged = Boolean(note.handle);
                }
                sortNotes();
                if (note.id === state.activeNoteId) {
                    state.activeNote = note;
                    renderNoteTitle(note);
                }
                renderNotes();
                if (handleChanged) {
                    refreshMentionHandles();
                }
            };

            const removePendingFile = (id) => {
                state.pendingFiles = state.pendingFiles.filter((item) => item.id !== id);
                renderAttachmentChips();
            };

            const addPendingFiles = (fileList) => {
                if (!fileList || !fileList.length) {
                    return;
                }
                const files = Array.from(fileList);
                files.forEach((file) => {
                    const id = `file-${Date.now()}-${Math.random().toString(16).slice(2)}`;
                    state.pendingFiles.push({ id, file });
                });
                renderAttachmentChips();
            };

            const loadMessages = async (noteId, options = {}) => {
                if (!noteId) {
                    return;
                }
                const silent = Boolean(options.silent);
                if (!silent) {
                    state.isLoadingMessages = true;
                    renderMessages();
                }
                try {
                    const response = await fetch(`${API_BASE}/chat?noteId=${encodeURIComponent(noteId)}&limit=400`);
                    if (!response.ok) {
                        throw new Error('Failed to load messages');
                    }
                    const payload = await response.json();
                    state.messages = Array.isArray(payload.messages) ? payload.messages : [];
                    pendingReactions.clear();
                    if (payload.note) {
                        state.activeNote = payload.note;
                        state.activeNoteId = payload.note.id;
                        updateNoteFromResponse(payload.note);
                    }
                    clearError();
                } catch (error) {
                    console.error('Failed to load messages', error);
                    showError('Unable to load this note.');
                } finally {
                    state.isLoadingMessages = false;
                    renderMessages();
                }
            };

            const applyClearResult = (clearResult) => {
                if (!clearResult || typeof clearResult !== 'object') {
                    return false;
                }
                const deletedIds = Array.isArray(clearResult.deleted_message_ids)
                    ? clearResult.deleted_message_ids.map((value) => String(value)).filter(Boolean)
                    : [];
                if (deletedIds.length) {
                    const toDelete = new Set(deletedIds);
                    state.messages = state.messages.filter((entry) => {
                        if (!entry || !entry.id) {
                            return true;
                        }
                        return !toDelete.has(String(entry.id));
                    });
                }
                if (
                    clearResult.status &&
                    clearResult.status !== 'success' &&
                    clearResult.message
                ) {
                    showError(clearResult.message);
                    return true;
                }
                return false;
            };

            const selectNote = async (noteId, options = {}) => {
                if (!noteId) {
                    return;
                }
                state.activeNoteId = noteId;
                state.activeNote = state.notes.find((note) => note.id === noteId) || null;
                state.messageSearch = '';
                if (messageSearchEl) {
                    messageSearchEl.value = '';
                }
                renderNoteTitle(state.activeNote);
                renderNotes();
                updateComposerAvailability();
                renderAttachmentChips();
                renderMessages();
                await loadMessages(noteId, { silent: options.silent });
                if (options.focusComposer) {
                    const textarea = getActiveTextarea();
                    if (textarea) {
                        textarea.focus();
                    }
                }
            };

            const createNote = async (title) => {
                const response = await fetch(`${API_BASE}/notes`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ title }),
                });
                if (!response.ok) {
                    throw new Error('Failed to create note');
                }
                const payload = await response.json();
                if (payload.note) {
                    updateNoteFromResponse(payload.note);
                }
                return payload.note;
            };

            const deleteNote = async (noteId) => {
                const response = await fetch(`${API_BASE}/notes`, {
                    method: 'DELETE',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: noteId }),
                });
                if (!response.ok) {
                    throw new Error('Failed to delete note');
                }
                return response.json();
            };

            const loadNotes = async (options = {}) => {
                const silent = Boolean(options.silent);
                if (!silent) {
                    state.isLoadingNotes = true;
                }
                try {
                    const response = await fetch(`${API_BASE}/notes`);
                    if (!response.ok) {
                        throw new Error('Failed to load notes');
                    }
                    const payload = await response.json();
                    state.notes = Array.isArray(payload.notes) ? payload.notes : [];
                    sortNotes();
                    renderNotes();
                    await refreshMentionDirectory();
                    if (!state.activeNoteId && state.notes.length) {
                        await selectNote(state.notes[0].id, { focusComposer: true, silent: true });
                    }
                    if (!state.notes.length && !autoCreatingNote) {
                        autoCreatingNote = true;
                        try {
                            const note = await createNote('New note');
                            if (note) {
                                await selectNote(note.id, { focusComposer: true });
                            }
                        } catch (error) {
                            console.error('Failed to create default note', error);
                        } finally {
                            autoCreatingNote = false;
                        }
                    }
                } catch (error) {
                    console.error('Failed to load notes', error);
                    showError('Unable to load notes.');
                } finally {
                    state.isLoadingNotes = false;
                }
            };

            const sendMessage = async (overrideContent = undefined) => {
                if (!state.activeNoteId || state.isSending) {
                    return;
                }
                const rawContent =
                    overrideContent !== undefined && overrideContent !== null
                        ? String(overrideContent)
                        : getComposerValue();
                const trimmed = normalizePreview(rawContent);
                if (!trimmed && !state.pendingFiles.length) {
                    return;
                }
                state.isSending = true;
                clearError();
                try {
                    let response;
                    const replyTarget = state.activeReply && state.activeReply.id
                        ? { id: state.activeReply.id, note_id: state.activeReply.noteId }
                        : null;
                    if (state.pendingFiles.length) {
                        const formData = new FormData();
                        formData.append('note_id', state.activeNoteId);
                        formData.append('content', rawContent);
                        if (replyTarget) {
                            formData.append('reply_to', JSON.stringify(replyTarget));
                        }
                        state.pendingFiles.forEach((item) => {
                            formData.append('attachments', item.file, item.file.name);
                        });
                        response = await fetch(`${API_BASE}/chat`, {
                            method: 'POST',
                            body: formData,
                        });
                    } else {
                        const payload = { note_id: state.activeNoteId, content: rawContent };
                        if (replyTarget) {
                            payload.reply_to = replyTarget;
                        }
                        response = await fetch(`${API_BASE}/chat`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload),
                        });
                    }
                    if (!response.ok) {
                        throw new Error('Message failed');
                    }
                    const payload = await response.json();
                    const incoming = Array.isArray(payload.messages) ? payload.messages : [];
                    incoming.forEach((entry) => {
                        upsertMessage(entry);
                    });
                    const displayedClearError = payload.clear
                        ? applyClearResult(payload.clear)
                        : false;
                    if (payload.note) {
                        updateNoteFromResponse(payload.note);
                    }
                    resetComposer();
                    pendingScrollToBottom = true;
                    renderMessages();
                    if (!displayedClearError) {
                        clearError();
                    }
                } catch (error) {
                    console.error('Failed to send message', error);
                    showError('Unable to send that message.');
                } finally {
                    state.isSending = false;
                    jumpToBottom();
                    if (attachmentInputEl) {
                        attachmentInputEl.value = '';
                    }
                }
            };

            if (noteSearchEl) {
                noteSearchEl.addEventListener('input', () => {
                    state.noteSearch = noteSearchEl.value || '';
                    renderNotes();
                });
                noteSearchEl.addEventListener('keydown', async (event) => {
                    if (event.key === 'Enter') {
                        event.preventDefault();
                        const trimmed = normalizePreview(noteSearchEl.value || '');
                        if (!trimmed) {
                            return;
                        }
                        const trimmedLower = trimmed.toLowerCase();
                        const existing = state.notes.find((note) => {
                            const candidate = normalizePreview(note.title || '').toLowerCase();
                            return candidate && candidate === trimmedLower;
                        });
                        if (existing) {
                            await selectNote(existing.id, { focusComposer: true });
                            return;
                        }
                        try {
                            const note = await createNote(trimmed);
                            noteSearchEl.value = '';
                            state.noteSearch = '';
                            renderNotes();
                            if (note) {
                                await selectNote(note.id, { focusComposer: true });
                            }
                        } catch (error) {
                            console.error('Failed to create note', error);
                            showError('Unable to create that note.');
                        }
                    }
                });
            }

            if (createNoteButton) {
                createNoteButton.addEventListener('click', async () => {
                    const desiredTitle = normalizePreview((noteSearchEl && noteSearchEl.value) || '');
                    const fallbackTitle = desiredTitle || 'New note';
                    const match = desiredTitle
                        ? state.notes.find((note) => normalizePreview(note.title || '').toLowerCase() === desiredTitle.toLowerCase())
                        : null;
                    try {
                        createNoteButton.disabled = true;
                        if (match) {
                            await selectNote(match.id, { focusComposer: true });
                            return;
                        }
                        const note = await createNote(fallbackTitle);
                        if (noteSearchEl) {
                            noteSearchEl.value = '';
                        }
                        state.noteSearch = '';
                        renderNotes();
                        if (note) {
                            await selectNote(note.id, { focusComposer: true });
                        }
                    } catch (error) {
                        console.error('Failed to create note', error);
                        showError('Unable to create that note.');
                    } finally {
                        createNoteButton.disabled = false;
                    }
                });
            }

            if (messageSearchEl) {
                messageSearchEl.addEventListener('input', () => {
                    state.messageSearch = messageSearchEl.value || '';
                    renderMessages();
                });
            }

            if (refreshButton) {
                refreshButton.addEventListener('click', () => {
                    if (state.activeNoteId) {
                        loadMessages(state.activeNoteId, { silent: false });
                    }
                });
            }

            if (inputEl) {
                inputEl.addEventListener('input', () => {
                    state.composerValue = inputEl.value || '';
                    autoResizeInput();
                });
                inputEl.addEventListener('keydown', (event) => {
                    if (event.key === 'Enter' && !event.shiftKey) {
                        event.preventDefault();
                        sendMessage(inputEl.value || '');
                    }
                });
            }

            if (attachmentButtonEl) {
                attachmentButtonEl.addEventListener('click', () => {
                    if (attachmentInputEl && !attachmentButtonEl.disabled) {
                        attachmentInputEl.click();
                    }
                });
            }

            if (attachmentInputEl) {
                attachmentInputEl.addEventListener('change', (event) => {
                    addPendingFiles(event.target.files);
                });
            }

            renderNotes();
            renderMessages();
            renderAttachmentChips();
            renderReplyPreview();
            ensureMentionComposer();
            loadNotes();
        })();
    </script>
</body>
</html>
