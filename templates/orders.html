<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>FireCoast</title>
<script src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.plugin.autotable.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="../assets/css/styles.css">
</head>
<body class="bg-slate-50 min-h-screen font-sans">
    <nav class="bg-slate-900 text-white shadow">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex h-16 items-center justify-between">
                <div class="flex items-center space-x-10">
                    <a href="/admin" id="nav-home-link" class="text-lg font-semibold tracking-wide">FireCoast OMS</a>
                    <div class="hidden md:flex items-center space-x-6 text-sm font-medium">
                        <a href="/orders" id="nav-orders-link" class="text-orange-300">Orders</a>
                        <a href="/contacts" class="hover:text-orange-300 transition">Contacts</a>
                        <a href="/analytics" class="hover:text-orange-300 transition">Analytics</a>
                    </div>
                </div>
                <div class="flex items-center space-x-3 text-sm font-medium">
                    <a href="/settings" class="hover:text-orange-300 transition">Settings</a>
                    <a href="#" id="nav-log-out" class="hover:text-orange-300 transition">Log Out</a>
                </div>
            </div>
        </div>
    </nav>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const brandLink = document.getElementById('nav-home-link');
            if (brandLink) {
                brandLink.addEventListener('click', (event) => {
                    event.preventDefault();
                    window.location.href = '/admin';
                });
            }

            const ordersLink = document.getElementById('nav-orders-link');
            if (ordersLink) {
                ordersLink.addEventListener('click', (event) => {
                    if (window.fireCoastNavigateTo) {
                        event.preventDefault();
                        window.fireCoastNavigateTo('dashboard');
                    }
                });
            }
            const logoutLink = document.getElementById('nav-log-out');
            if (logoutLink) {
                logoutLink.addEventListener('click', async (event) => {
                    event.preventDefault();
                    if (window.fireCoastLogout) {
                        window.fireCoastLogout();
                        return;
                    }
                    try {
                        const response = await fetch('/shutdown', { method: 'POST' });
                        if (response.ok) {
                            document.body.innerHTML = '<div class="min-h-screen flex items-center justify-center text-slate-700 text-lg">Application has been shut down. You can now close this tab.</div>';
                        } else {
                            alert('Failed to log out.');
                        }
                    } catch (error) {
                        console.error('Error logging out:', error);
                        alert('Error attempting to log out.');
                    }
                });
            }
        });
    </script>
    <main class="py-10">
        <div id="root" class="orders-app"></div>
    </main>
    {% raw %}
    <script type="text/babel">
// --- FORMATTERS ---
const formatInTimeZone = (dateString, timeZone, options = {}) => {
    try {
        const date = new Date(dateString);
        return date.toLocaleString('en-US', { ...options, timeZone });
    } catch (e) {
        console.error("Error formatting date:", e);
        return "Invalid Date";
    }
};

// --- SHARED HELPER COMPONENTS & ICONS ---
const Input = ({ label, placeholder, value, onChange, type = "text", disabled = false, onFocus, onBlur }) => (
    <div><label className="block text-sm font-medium text-slate-600">{label}</label><input type={type} placeholder={placeholder} value={value} onChange={onChange} disabled={disabled} onFocus={onFocus} onBlur={onBlur} className="mt-1 block w-full px-3 py-2 bg-white border border-slate-300 rounded-md shadow-sm placeholder-slate-400 focus:outline-none focus:ring-orange-500 focus:border-orange-500 sm:text-sm disabled:bg-slate-100 disabled:text-slate-500" /></div>
);
const Select = ({ value, onChange, disabled = false, children }) => (
    <select value={value} onChange={onChange} disabled={disabled} className="w-full px-3 py-2 bg-white border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500 sm:text-sm disabled:bg-slate-100 disabled:text-slate-500">{children}</select>
);
const Textarea = ({ label, placeholder, value, onChange, disabled = false, rows = 3, onFocus, onBlur }) => (
    <div><label className="block text-sm font-medium text-slate-600">{label}</label><textarea rows={rows} placeholder={placeholder} value={value} onChange={onChange} disabled={disabled} onFocus={onFocus} onBlur={onBlur} className="mt-1 block w-full text-sm px-3 py-2 bg-white border border-slate-300 rounded-md shadow-sm placeholder-slate-400 focus:outline-none focus:ring-orange-500 focus:border-orange-500 disabled:bg-slate-100 disabled:text-slate-500"></textarea></div>
);

const ContactMentionTextarea = ({ label, placeholder, value, onChange, disabled = false, rows = 3, contacts = [] }) => {
    const { useState, useRef, useEffect } = React;
    const textareaRef = useRef(null);
    const [suggestions, setSuggestions] = useState([]);
    const [isOpen, setIsOpen] = useState(false);
    const [highlightIndex, setHighlightIndex] = useState(0);
    const lastCaretRef = useRef(0);

    const findMentionQuery = (text, caretPosition) => {
        const uptoCaret = text.slice(0, caretPosition);
        const match = uptoCaret.match(/@([a-z0-9_.-]*)$/i);
        if (match) {
            return match[1].toLowerCase();
        }
        return null;
    };

    const updateSuggestions = (text, caret) => {
        const query = findMentionQuery(text, caret);
        if (query === null) {
            setSuggestions([]);
            setIsOpen(false);
            setHighlightIndex(0);
            return;
        }
        const filtered = contacts
            .filter(contact => contact.handle)
            .filter(contact => {
                if (!query) return true;
                const handle = contact.handle.toLowerCase();
                const name = (contact.contactName || '').toLowerCase();
                const company = (contact.companyName || '').toLowerCase();
                return handle.startsWith(query) || name.includes(query) || company.includes(query);
            })
            .slice(0, 8);
        setSuggestions(filtered);
        setIsOpen(filtered.length > 0);
        setHighlightIndex(0);
    };

    const applyMention = (contact) => {
        const textarea = textareaRef.current;
        if (!textarea) return;
        const caret = textarea.selectionStart;
        const text = textarea.value;
        const uptoCaret = text.slice(0, caret);
        const match = uptoCaret.match(/@([a-z0-9_.-]*)$/i);
        if (!match) return;
        const queryLength = match[1].length;
        const insertionPoint = caret - queryLength;
        const replacement = `@${contact.handle}`;
        const newValue = text.slice(0, insertionPoint) + replacement + text.slice(caret);
        onChange(newValue);
        setTimeout(() => {
            textarea.focus();
            const newCaret = insertionPoint + replacement.length;
            textarea.setSelectionRange(newCaret, newCaret);
        }, 0);
        setSuggestions([]);
        setIsOpen(false);
    };

    const handleChange = (event) => {
        const newValue = event.target.value;
        onChange(newValue);
        const caret = event.target.selectionStart;
        lastCaretRef.current = caret;
        updateSuggestions(newValue, caret);
    };

    const handleKeyDown = (event) => {
        if (!isOpen || suggestions.length === 0) return;
        if (event.key === 'ArrowDown') {
            event.preventDefault();
            setHighlightIndex(prev => (prev + 1) % suggestions.length);
        } else if (event.key === 'ArrowUp') {
            event.preventDefault();
            setHighlightIndex(prev => (prev - 1 + suggestions.length) % suggestions.length);
        } else if (event.key === 'Enter') {
            const selected = suggestions[highlightIndex];
            if (selected) {
                event.preventDefault();
                applyMention(selected);
            }
        } else if (event.key === 'Escape') {
            setIsOpen(false);
        }
    };

    useEffect(() => {
        const textarea = textareaRef.current;
        if (!textarea) return;
        const handler = () => {
            const caret = textarea.selectionStart;
            lastCaretRef.current = caret;
            updateSuggestions(textarea.value, caret);
        };
        textarea.addEventListener('click', handler);
        textarea.addEventListener('keyup', handler);
        return () => {
            textarea.removeEventListener('click', handler);
            textarea.removeEventListener('keyup', handler);
        };
    }, [contacts]);

    return (
        <div className="relative">
            {label !== undefined && label !== null && label !== '' && (
                <label className="block text-sm font-medium text-slate-600">{label}</label>
            )}
            <textarea
                ref={textareaRef}
                rows={rows}
                placeholder={placeholder}
                value={value}
                onChange={handleChange}
                onKeyDown={handleKeyDown}
                disabled={disabled}
                className="mt-1 block w-full text-sm px-3 py-2 bg-white border border-slate-300 rounded-md shadow-sm placeholder-slate-400 focus:outline-none focus:ring-orange-500 focus:border-orange-500 disabled:bg-slate-100 disabled:text-slate-500"
            />
            {isOpen && suggestions.length > 0 && (
                <div className="absolute z-20 mt-1 w-full max-h-56 overflow-y-auto rounded-md border border-slate-200 bg-white shadow-lg">
                    {suggestions.map((contact, index) => (
                        <button
                            type="button"
                            key={contact.id || contact.handle || index}
                            onMouseDown={(event) => { event.preventDefault(); applyMention(contact); }}
                            className={`w-full text-left px-3 py-2 text-sm ${highlightIndex === index ? 'bg-orange-100 text-orange-900' : 'text-slate-700 hover:bg-orange-50'}`}
                        >
                            <span className="font-semibold">@{contact.handle}</span>
                            <span className="ml-2 text-xs text-slate-500">{contact.contactName || contact.companyName}</span>
                        </button>
                    ))}
                </div>
            )}
        </div>
    );
};
const TrashIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm4 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" /></svg>);
const DollarSignIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8v1m0 8v1m-4-4h8m-4-4a8 8 0 100 16 8 8 0 000-16z" /></svg>);
const ViewIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" /></svg>);
const PdfIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>);
const EmailIcon = () => (<svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z" /></svg>);

const OrderLogsSection = ({ orderId, canEdit, allContacts = [] }) => {
    if (!orderId) return null;

    const { useState, useEffect, useRef } = React;
    const [logs, setLogs] = useState([]);
    const [note, setNote] = useState('');
    const [attachment, setAttachment] = useState(null);
    const fileInputRef = useRef(null);
    const [editingLog, setEditingLog] = useState(null);
    const [editedNote, setEditedNote] = useState('');
    const [editedAttachment, setEditedAttachment] = useState(null);

    const fetchLogs = async () => {
        try {
            const response = await fetch(`/api/orders/${orderId}/logs`);
            const data = await response.json();
            setLogs(data);
        } catch (error) {
            console.error("Failed to fetch logs:", error);
        }
    };

    useEffect(() => {
        if (orderId) {
            fetchLogs();
        }
    }, [orderId]);

    const handleFileChange = (e) => setAttachment(e.target.files[0]);
    const handleEditedFileChange = (e) => setEditedAttachment(e.target.files[0]);

    const handleSubmit = async (e) => {
        e.preventDefault();
        const formData = new FormData();
        formData.append('note', note);
        if (attachment) formData.append('attachment', attachment);

        try {
            const response = await fetch(`/api/orders/${orderId}/logs`, { method: 'POST', body: formData });
            if (response.ok) {
                setNote('');
                setAttachment(null);
                if (fileInputRef.current) fileInputRef.current.value = '';
                fetchLogs();
            } else {
                const result = await response.json();
                alert('Failed to add log entry: ' + result.message);
            }
        } catch (error) {
            console.error('Error adding log entry:', error);
            alert('An error occurred while adding the log entry.');
        }
    };

    const handleEditClick = (log) => {
        setEditingLog(log);
        setEditedNote(log.note || '');
        setEditedAttachment(null);
    };

    const handleUpdate = async () => {
        if (!editingLog) return;
        const formData = new FormData();
        formData.append('note', editedNote);
        if (editedAttachment) formData.append('attachment', editedAttachment);

        try {
            const response = await fetch(`/api/orders/${orderId}/logs/${editingLog.log_id}`, { method: 'POST', body: formData });
            if (response.ok) {
                setEditingLog(null);
                setEditedAttachment(null);
                fetchLogs();
            } else {
                const error = await response.json();
                alert('Failed to update log: ' + error.message);
            }
        } catch (error) {
            console.error('Error updating log:', error);
            alert('An error occurred while updating the log.');
        }
    };

    const handleDelete = async (logId) => {
        if (confirm('Are you sure you want to delete this log entry?')) {
            try {
                const response = await fetch(`/api/orders/${orderId}/logs/${logId}`, { method: 'DELETE' });
                if (response.ok) {
                    fetchLogs();
                } else {
                    const error = await response.json();
                    alert('Failed to delete log: ' + error.message);
                }
            } catch (error) {
                console.error('Error deleting log:', error);
                alert('An error occurred while deleting the log entry.');
            }
        }
    };

    return (
        <>
            {editingLog && (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-50">
                    <div className="bg-white p-6 rounded-lg shadow-xl w-full max-w-lg">
                        <h2 className="text-xl font-bold mb-4">Edit Log Entry</h2>
                        <ContactMentionTextarea label="Note" value={editedNote} onChange={setEditedNote} contacts={allContacts} />
                        <div className="mt-4">
                            <label className="block text-sm font-medium text-slate-600">Attachment</label>
                            <input type="file" onChange={handleEditedFileChange} className="mt-1 block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-orange-50 file:text-orange-700 hover:file:bg-orange-100" />
                        </div>
                        <div className="mt-6 flex justify-end space-x-3">
                            <button onClick={() => setEditingLog(null)} className="px-4 py-2 bg-slate-200 text-slate-800 rounded-md hover:bg-slate-300">Cancel</button>
                            <button onClick={handleUpdate} className="px-4 py-2 bg-orange-600 text-white font-semibold rounded-md hover:bg-orange-700">Update</button>
                        </div>
                    </div>
                </div>
            )}
            {canEdit && (
                <div className="bg-white rounded-lg shadow-sm border border-slate-200 mb-6">
                    <div className="p-6">
                        <h2 className="text-xl font-semibold text-slate-700 mb-4">Add Log Entry</h2>
                        <form onSubmit={handleSubmit} className="space-y-4">
                            <ContactMentionTextarea
                                label="Notes"
                                placeholder="Share updates and mention teammates or clients with @handle"
                                value={note}
                                onChange={setNote}
                                contacts={allContacts}
                                rows={4}
                            />
                            <div>
                                <label className="block text-sm font-medium text-slate-600 mb-1">Attachment</label>
                                <input
                                    type="file"
                                    ref={fileInputRef}
                                    onChange={handleFileChange}
                                    className="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-orange-50 file:text-orange-700 hover:file:bg-orange-100"
                                />
                            </div>
                            <div className="flex justify-end space-x-3">
                                <button type="submit" className="px-4 py-2 bg-orange-600 text-white font-semibold rounded-md hover:bg-orange-700">Post Log</button>
                                <button type="button" onClick={() => { setNote(''); setAttachment(null); if (fileInputRef.current) fileInputRef.current.value=''; }} className="px-4 py-2 bg-slate-200 text-slate-700 rounded-md hover:bg-slate-300">Clear</button>
                            </div>
                        </form>
                    </div>
                </div>
            )}
            <div className="bg-white rounded-lg shadow-sm border border-slate-200">
                <div className="p-6">
                    <h2 className="text-xl font-semibold text-slate-700 mb-4">Log History</h2>
                    <div className="overflow-x-auto">
                        <table className="w-full text-sm text-left text-slate-500">
                            <thead className="text-xs text-slate-700 uppercase bg-slate-100">
                                <tr>
                                    <th className="px-4 py-3">Timestamp</th>
                                    <th className="px-4 py-3">Action</th>
                                    <th className="px-4 py-3">Details</th>
                                    <th className="px-4 py-3">Attachment</th>
                                    {canEdit && <th className="px-4 py-3"><span className="sr-only">Actions</span></th>}
                                </tr>
                            </thead>
                            <tbody>
                                {logs.map(log => (
                                    <tr key={log.log_id} className="bg-white border-b hover:bg-slate-50">
                                        <td className="px-4 py-3 font-medium text-slate-800">{new Date(log.timestamp).toLocaleString()}</td>
                                        <td className="px-4 py-3">{log.action}</td>
                                        <td className="px-4 py-3">{log.details || ''}</td>
                                        <td className="px-4 py-3">
                                            {log.attachment_path ? <a href={`/data/${log.attachment_path}`} target="_blank" className="text-orange-600 hover:underline">View File</a> : ''}
                                        </td>
                                        {canEdit && (
                                            <td className="px-4 py-3 text-right">
                                                <button onClick={() => handleEditClick(log)} className="font-medium text-orange-600 hover:underline mr-4">Edit</button>
                                                <button onClick={() => handleDelete(log.log_id)} className="font-medium text-red-600 hover:underline">Delete</button>
                                            </td>
                                        )}
                                    </tr>
                                ))}
                                {logs.length === 0 && (
                                    <tr>
                                        <td colSpan={canEdit ? "5" : "4"} className="text-center py-4 text-slate-500">No log entries for this order yet.</td>
                                    </tr>
                                )}
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </>
    );
};


const CogIcon = () => (
    <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
    </svg>
);

const PriceInput = ({ value, onChange, disabled = false }) => {
    const handleChange = (e) => { const digits = e.target.value.replace(/\D/g, ''); onChange(Number(digits)); };
    const formattedValue = (value / 100).toFixed(2);
    return (<input type="text" value={`$${formattedValue}`} onChange={handleChange} disabled={disabled} className="w-24 sm:w-28 text-right bg-white border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500 sm:text-sm p-2 disabled:bg-slate-100 disabled:text-slate-500" />);
};

const ScentToggle = ({ value, onChange, disabled = false }) => {
    const options = ["Scented", "Unscented", "Mixed"];
    return (<div><label className="block text-sm font-medium text-slate-600 mb-2">Scent Option</label><div className="flex w-full bg-slate-200 p-1 rounded-full">{options.map(option => (<button key={option} onClick={() => !disabled && onChange(option)} disabled={disabled} className={`w-full text-center px-3 py-1.5 text-sm font-semibold rounded-full transition-all duration-300 ease-in-out ${value === option ? 'bg-white text-orange-600 shadow-sm' : 'text-slate-600 hover:bg-slate-300/50'} ${disabled ? 'cursor-not-allowed' : ''}`}>{option}</button>))}</div></div>);
};

const NameDropToggle = ({ value, onChange, disabled = false }) => {
    return (
        <div>
            <label className="block text-sm font-medium text-slate-600 mb-1">Name Drop Surcharge</label>
            <button
                onClick={() => !disabled && onChange(!value)}
                disabled={disabled}
                className={`relative inline-flex items-center h-6 rounded-full w-11 transition-colors duration-200 ease-in-out focus:outline-none ${disabled ? 'cursor-not-allowed opacity-50' : 'focus:ring-2 focus:ring-orange-500 focus:ring-opacity-50'} ${value ? 'bg-orange-600' : 'bg-slate-300'}`}
            >
                <span className={`inline-block w-4 h-4 transform bg-white rounded-full transition-transform duration-200 ease-in-out ${value ? 'translate-x-6' : 'translate-x-1'}`} />
            </button>
            {value && <p className="text-xs text-slate-500 mt-1">$1.00 surcharge per cross item.</p>}
        </div>
    );
};


const generatePdf = (order, allItems, action = 'save') => {
    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    const { contactInfo, lineItems, notes, total, id, date, scentOption, estimatedShippingDate, estimatedShipping, nameDrop, signatureDataUrl } = order; // Added signatureDataUrl and estimatedShipping
    const timeZone = "America/Chicago";
    const dateOptions = { year: 'numeric', month: 'long', day: 'numeric' };
    doc.setFontSize(20); doc.text("Purchase Order", 14, 22);
    doc.setFontSize(12); doc.text(`PO #: ${id}`, 14, 30); doc.text(`Date: ${formatInTimeZone(date, timeZone, dateOptions)}`, 14, 36);
    
    let leftColumnY = 50;
    let rightColumnY = 50;
    const leftColumnX = 14;
    const rightColumnX = 105; // Start addresses further to the right

    // Contact Info - Left Column
    doc.setFontSize(12); doc.text("Contact Information", leftColumnX, leftColumnY); 
    leftColumnY += 6;
    doc.setFontSize(10);
    doc.text(`${contactInfo.companyName}`, leftColumnX, leftColumnY); leftColumnY += 5;
    doc.text(`${contactInfo.contactName}`, leftColumnX, leftColumnY); leftColumnY += 5;
    doc.text(`${contactInfo.email}`, leftColumnX, leftColumnY); leftColumnY += 5;
    doc.text(`${contactInfo.phone}`, leftColumnX, leftColumnY); leftColumnY += 5;

    // Billing Address - Right Column
    if (contactInfo.billingAddress || contactInfo.billingCity) {
        doc.setFontSize(10);
        doc.text("Billing Address:", rightColumnX, rightColumnY); rightColumnY += 5;
        const ba = `${contactInfo.billingAddress || ''}\n${contactInfo.billingCity || ''}, ${contactInfo.billingState || ''} ${contactInfo.billingZipCode || ''}`;
        const billingAddressLines = doc.splitTextToSize(ba, 90);
        doc.text(billingAddressLines, rightColumnX, rightColumnY);
        rightColumnY += (billingAddressLines.length * 4) + 2;
    }

    // Shipping Address - Right Column, below Billing
    if (contactInfo.shippingAddress || contactInfo.shippingCity) {
        if (contactInfo.billingAddress || contactInfo.billingCity) rightColumnY += 3;
        doc.setFontSize(10);
        doc.text("Shipping Address:", rightColumnX, rightColumnY); rightColumnY += 5;
        const sa = `${contactInfo.shippingAddress || ''}\n${contactInfo.shippingCity || ''}, ${contactInfo.shippingState || ''} ${contactInfo.shippingZipCode || ''}`;
        const shippingAddressLines = doc.splitTextToSize(sa, 90);
        doc.text(shippingAddressLines, rightColumnX, rightColumnY);
        rightColumnY += (shippingAddressLines.length * 4) + 2;
    }
    
    // Determine the starting Y for the table, ensuring it's below both columns
    let tableStartY = Math.max(leftColumnY, rightColumnY, 70); // Ensure table starts at least at Y=70 or below the longest column
    tableStartY += 5; // Add a small buffer

    const tableColumn = ["Item", "Style", "Quantity", "Unit Price", "Total"];
    const tableRows = lineItems.map(item => [allItems[item.item]?.name || item.item, item.style, item.quantity, `$${(item.price / 100).toFixed(2)}`, `$${((item.quantity * item.price) / 100).toFixed(2)}`]);
    doc.autoTable({ head: [tableColumn], body: tableRows, startY: tableStartY });

    // Calculate subtotal and name drop surcharge
    let calculatedSubtotal = 0;
    lineItems.forEach(item => {
        calculatedSubtotal += item.quantity * item.price;
    });

    let calculatedNameDropSurcharge = 0;
    if (nameDrop) {
        lineItems.forEach(item => {
            if (item.type === 'cross') { // Assuming item.type is reliably populated
                calculatedNameDropSurcharge += item.quantity * 100; // $1.00 per cross item
            }
        });
    }

    let finalY = doc.lastAutoTable.finalY + 10;
    doc.setFontSize(10); // Smaller font for sub-lines
    doc.text(`Subtotal: $${(calculatedSubtotal / 100).toFixed(2)}`, 14, finalY);
    finalY += 7;

    if (calculatedNameDropSurcharge > 0) {
        doc.text(`Name Drop Surcharge: $${(calculatedNameDropSurcharge / 100).toFixed(2)}`, 14, finalY);
        finalY += 7;
    }

    // Add Estimated Shipping Cost here
    // estimatedShipping is destructured from order, expected to be a string like "12.34"
    const estShippingValue = parseFloat(estimatedShipping) || 0; // Default to 0 if NaN
    if (estShippingValue > 0) { // Display only if positive value
        doc.setFontSize(10); // Ensure font size is consistent for this item
        doc.text(`Est. Shipping Cost: $${estShippingValue.toFixed(2)}`, 14, finalY);
        finalY += 7; // Increment Y for the next line
    }

    // Calculate the grand total for PDF display based on components shown on PDF
    const estimatedShippingInCentsForPdfTotal = Math.round(estShippingValue * 100);
    const grandTotalForPdfDisplay = calculatedSubtotal + calculatedNameDropSurcharge + estimatedShippingInCentsForPdfTotal;

    doc.setFontSize(12); // Larger font for the grand total
    doc.text(`Total: $${(grandTotalForPdfDisplay / 100).toFixed(2)}`, 14, finalY); // Use the self-calculated total for PDF
    
    finalY += 10; 
    doc.setFontSize(10); 
    doc.text(`Scent Option: ${scentOption}`, 14, finalY);

    let currentLineY = finalY + 5; // Y position for the next line of text

    if(estimatedShippingDate) {
        doc.text(`Est. Ship Date: ${formatInTimeZone(estimatedShippingDate, timeZone, dateOptions)}`, 14, currentLineY);
        currentLineY += 5; // Increment Y for the next line
    }
    
    finalY = currentLineY - 5; // Update finalY to the Y position of the last line written (if any date was written)
                               // If no date, finalY remains as it was after Scent Option.
                               // This needs to be robust: if currentLineY didn't change, finalY should be the Y of Scent Option.
    if (currentLineY === finalY + 10) { // This means neither date nor shipping cost (from previous logic) was added after Scent Option
        // If only Scent Option was printed, and then we moved to notes, finalY should be where Scent Option was.
        // However, the new logic places shipping cost before total, so this specific adjustment might need review.
        // Let's simplify: finalY is now the Y after Total. The lines after Total start from there.
        // The `finalY = currentLineY - 5;` was for the block that printed date/shipping *after* total.
        // Now that block is split, we need to ensure `finalY` correctly reflects the Y position *after* the Total.
        // The `finalY += 10;` after Total already correctly sets up for Scent Option.
        // The `currentLineY` logic for Est. Ship Date is fine as it starts from `finalY` (which is after Scent Option).
    }
    
    let notesStartY = finalY + 10; // This should be based on the Y position after Est. Ship Date (if present)
                                   // or after Scent Option if no Est. Ship Date.
                                   // The `finalY = currentLineY - 5;` correctly sets this up if currentLineY was updated.
                                   // If currentLineY was NOT updated (no ship date), then finalY is still the Y of Scent Option.
                                   // So, notesStartY will be 10 below Scent Option or 10 below Est. Ship Date. This seems correct.
    if (notes) { 
        doc.text("Notes:", 14, notesStartY); 
        const splitNotes = doc.splitTextToSize(notes, 180); 
        doc.text(splitNotes, 14, notesStartY + 5);
        finalY = notesStartY + 5 + (splitNotes.length * 4); // Adjust finalY based on notes length
    } else {
        finalY = notesStartY; // If no notes, finalY is just after shipping date
    }

    // Signature Block
    finalY += 15; // Add some space before signature
    if (finalY > 260) { // Check if new page is needed for signature
        doc.addPage();
        finalY = 20; // Reset Y position for new page
    }
    doc.setFontSize(10);
    doc.text("Authorized Signature:", 14, finalY);

    if (signatureDataUrl) {
        try {
            if (signatureDataUrl.startsWith('data:image/png;base64,')) {
                const base64ImageData = signatureDataUrl.substring(signatureDataUrl.indexOf(',') + 1);
                // A very short base64 string might indicate an empty or problematic signature.
                // A 1x1 transparent PNG's base64 data is ~88 chars.
                // We require a bit more to consider it a valid signature image.
                if (base64ImageData.length > 150) { 
                    const signatureImgWidth = 70; // mm
                    const signatureImgHeight = 20; // mm, adjust as needed
                    doc.addImage(signatureDataUrl, 'PNG', 50, finalY - (signatureImgHeight/2) + 2 , signatureImgWidth, signatureImgHeight);
                } else {
                    console.warn("Signature data is too short (length: " + base64ImageData.length + "), possibly empty or corrupted. Drawing a line instead.");
                    doc.line(50, finalY, 120, finalY); // Fallback line
                }
            } else {
                console.error("Signature data URL is not a valid PNG image. Drawing a line instead.");
                doc.line(50, finalY, 120, finalY); // Fallback line
            }
        } catch (e) {
            console.error("Error adding signature image to PDF:", e);
            doc.line(50, finalY, 120, finalY); // Fallback line in case of error
        }
    } else {
        doc.line(50, finalY, 120, finalY); // Draw a line if no signature data
    }
    
    if (action === 'save') { doc.save(`PO_${id}.pdf`); } 
    else if (action === 'preview') { doc.output('dataurlnewwindow'); }
    else if (action === 'datauristring') { return doc.output('datauristring'); }
}

const SalesChart = ({ data }) => {
    const { useRef, useEffect } = React;
    const chartRef = useRef(null);
    const chartInstance = useRef(null);
    useEffect(() => { if (chartRef.current) { if (chartInstance.current) { chartInstance.current.destroy(); } const ctx = chartRef.current.getContext('2d'); chartInstance.current = new Chart(ctx, { type: 'bar', data, options: { responsive: true, maintainAspectRatio: false, scales: { y: { beginAtZero: true } }, plugins: { legend: { display: false } } } }); } return () => { if (chartInstance.current) { chartInstance.current.destroy(); } }; }, [data]);
    return <canvas ref={chartRef} />;
};

const SignaturePad = ({ onSave, initialDataUrl, disabled = false }) => {
    const { useRef, useEffect, useState } = React;
    const canvasRef = useRef(null);
    const [isDrawing, setIsDrawing] = useState(false);
    const [signatureData, setSignatureData] = useState(initialDataUrl || null);

    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        
        // Set canvas dimensions based on its CSS-defined size
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;

        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        if (signatureData) {
            const img = new Image();
            img.onload = () => {
                ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear before drawing existing
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            };
            img.src = signatureData;
        } else {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }

    }, [signatureData, disabled]); // Redraw if signatureData changes or disabled state changes

    const getMousePos = (canvas, evt) => {
        const rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    };
    
    const getTouchPos = (canvas, touch) => {
        const rect = canvas.getBoundingClientRect();
        return {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top
        };
    };

    const startDrawing = (e) => {
        if (disabled) return;
        setIsDrawing(true);
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const pos = e.type.startsWith('touch') ? getTouchPos(canvas, e.touches[0]) : getMousePos(canvas, e);
        ctx.beginPath();
        ctx.moveTo(pos.x, pos.y);
        e.preventDefault(); // Prevent scrolling on touch
    };

    const draw = (e) => {
        if (!isDrawing || disabled) return;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        const pos = e.type.startsWith('touch') ? getTouchPos(canvas, e.touches[0]) : getMousePos(canvas, e);
        ctx.lineTo(pos.x, pos.y);
        ctx.stroke();
        e.preventDefault(); // Prevent scrolling on touch
    };

    const stopDrawing = () => {
        if (!isDrawing || disabled) return;
        setIsDrawing(false);
        const canvas = canvasRef.current;
        const dataUrl = canvas.toDataURL('image/png');
        setSignatureData(dataUrl); // Update local state for display
        if (onSave) {
            onSave(dataUrl); // Propagate to parent
        }
    };

    const clearSignature = () => {
        if (disabled) return;
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        setSignatureData(null);
        if (onSave) {
            onSave(null); // Propagate null to parent
        }
    };
    
    // Add event listeners for touch events
    useEffect(() => {
        const canvas = canvasRef.current;
        if (!canvas || disabled) return;

        // Ensure canvas has dimensions before adding listeners if it might be initially hidden or 0-sized
        // if (canvas.offsetWidth === 0 || canvas.offsetHeight === 0) { // Removed this check as it might prevent listeners if canvas is initially 0px then resized by CSS
            // Optionally, wait for dimensions or log a warning
            // console.warn("SignaturePad canvas has no dimensions yet.");
            // return; // Or handle resize observer
        // }


        canvas.addEventListener('touchstart', startDrawing, { passive: false });
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);

        return () => {
            canvas.removeEventListener('touchstart', startDrawing);
            canvas.removeEventListener('touchmove', draw);
            canvas.removeEventListener('touchend', stopDrawing);
            canvas.removeEventListener('touchcancel', stopDrawing);
        };
    }, [isDrawing, disabled, onSave, canvasRef.current?.offsetWidth, canvasRef.current?.offsetHeight]); // Re-run if canvas dimensions change

    const canvasStyle = {
        touchAction: 'none'
    };

    return (
        <div className="space-y-2">
            <canvas
                ref={canvasRef}
                onMouseDown={startDrawing}
                onMouseMove={draw}
                onMouseUp={stopDrawing}
                onMouseLeave={stopDrawing} // Stop drawing if mouse leaves canvas
                className={`w-full h-40 bg-slate-100 border border-slate-300 rounded-md cursor-crosshair ${disabled ? 'cursor-not-allowed opacity-70' : ''}`}
                style={canvasStyle} // Use the style object here
            ></canvas>
            {!disabled && (
                <button
                    onClick={clearSignature}
                    className="w-full text-center px-4 py-2 bg-slate-200 text-slate-700 font-semibold rounded-md hover:bg-slate-300 transition-colors text-sm"
                >
                    Clear Signature
                </button>
            )}
        </div>
    );
};


const EmailModal = ({ order, onClose, allItems, onEmailClientOpened, appSettings, saveOrder, onOrderUpdatedAfterEmail }) => {
    const { useState, useEffect, useRef } = React;
    const fileInputRef = useRef(null);
    const [attachments, setAttachments] = useState([]); // Handles multiple attachments
    const [isSending, setIsSending] = useState(false);
    const [emailSent, setEmailSent] = useState(false);
    const [isUploading, setIsUploading] = useState(false); // For upload progress
    const [editableBody, setEditableBody] = useState('');

    const hiddenFileInputStyle = { display: 'none' };

    const handleFileSelected = async (event) => {
        const files = Array.from(event.target.files);
        if (files.length === 0) return;

        setIsUploading(true);
        const uploadPromises = files.map(file => {
            const formData = new FormData();
            formData.append('file', file);
            return fetch('/api/upload-attachment', {
                method: 'POST',
                body: formData,
            }).then(response => response.json());
        });

        try {
            const results = await Promise.all(uploadPromises);
            const newAttachments = results.map((result, index) => {
                if (result.status === 'success') {
                    const expectedPoName = `PO_${order.id}.pdf`;
                    return {
                        original: result.originalFilename,
                        unique: result.uniqueFilename,
                        isMatch: result.originalFilename === expectedPoName,
                    };
                } else {
                    alert(`Failed to upload ${files[index].name}: ${result.message}`);
                    return null;
                }
            }).filter(Boolean); // Filter out nulls from failed uploads

            setAttachments(prev => [...prev, ...newAttachments]);
        } catch (error) {
            alert(`Error during file upload: ${error.message}`);
        } finally {
            setIsUploading(false);
            // Reset file input to allow re-selecting the same file(s)
            if(fileInputRef.current) {
                fileInputRef.current.value = "";
            }
        }
    };

    // useEffect for generating pdfDataUri is removed.

    useEffect(() => {
        const handleOutsideClick = (event) => {
            // Check if the click is outside the modal content
            if (event.target.id === "email-modal-backdrop") {
                onClose();
            }
        };

        // Add event listener when the modal is shown
        document.addEventListener('mousedown', handleOutsideClick);

        // Clean up event listener when the modal is hidden or component unmounts
        return () => {
            document.removeEventListener('mousedown', handleOutsideClick);
        };
    }, [onClose]);

    useEffect(() => {
        if (order && appSettings && appSettings.default_email_body) {
            let body = appSettings.default_email_body;
            // Replace placeholders
            // For [customerName], prefer contact name, fallback to company name.
            body = body.replace(/\[customerName\]/g, order.contactInfo.contactName || order.contactInfo.companyName || '');
            // For [contactCompanyName], use company name.
            body = body.replace(/\[contactCompanyName\]/g, order.contactInfo.companyName || '');
            body = body.replace(/\[contactCompany\]/g, order.contactInfo.companyName || '');
            body = body.replace(/\[orderID\]/g, order.id || '');
            body = body.replace(/\[yourCompany\]/g, appSettings.company_name || 'Your Company');
            setEditableBody(body);
        } else if (order) {
            // Fallback if settings are not loaded or default_email_body is missing
            const fallbackYourCompanyName = appSettings?.company_name || "Your Company";
            setEditableBody(
`Dear ${order.contactInfo.contactName || order.contactInfo.companyName},

Please find attached the purchase order ${order.id} for your records.

Thank you,
${fallbackYourCompanyName}`
            );
        }
    }, [order, appSettings]);

    if (!order) return null;

    const recipient = order.contactInfo.email;
    const subjectText = `${appSettings?.company_name || "Your Company"} - Order Confirmation ${order.id}`;
    
    // mailtoHref will be constructed on click or when rendering the link to use the latest editableBody
    const getMailtoHref = () => `mailto:${recipient}?subject=${encodeURIComponent(subjectText)}&body=${encodeURIComponent(editableBody)}`;

    return (
    <div id="email-modal-backdrop" className="fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center p-4">
        <div className="bg-white rounded-lg shadow-xl p-8 w-full max-w-2xl max-h-[90vh] overflow-y-auto modal-content">
                <h2 className="text-2xl font-bold text-slate-800 mb-4">Send Order Confirmation</h2>
                <div className="space-y-4">
                    <Input label="To" value={order.contactInfo.email} disabled />
                    <Input label="Subject" value={subjectText} disabled />
                    <Textarea label="Email Body" value={editableBody} onChange={e => setEditableBody(e.target.value)} rows={8} disabled={false} />
                    <div className="bg-orange-50 p-4 rounded-md border border-orange-200">
                        <p className="text-sm font-medium text-orange-700 mb-2">Order PDF:</p>
                        {/* Button to trigger client-side PDF generation for download */}
                        <button
                            onClick={() => {
                                if (order && allItems) {
                                    try {
                                        generatePdf(order, allItems, 'save'); // 'save' action directly downloads
                                    } catch (e) {
                                        console.error("Error generating PDF for download:", e);
                                        alert("Failed to generate PDF for download.");
                                    }
                                } else {
                                    alert("Order data or item data is missing, cannot generate PDF.");
                                }
                            }}
                            className="w-full flex items-center justify-center bg-blue-600 hover:bg-blue-700 text-white font-semibold px-4 py-3 rounded-md shadow-sm transition-colors"
                        >
                            <PdfIcon />
                            <span className="ml-2">Download PO_{order.id}.pdf</span>
                        </button>
                        <p className="mt-2 text-xs text-orange-700">Click to download the PO. Then, use the 'Upload Custom Attachment' button below if you wish to attach it to the email.</p>
                    </div>

                    {/* File Upload Section */}
                    <div className="pt-2"> {/* Added some top padding */}
                        <input
                            type="file"
                            ref={fileInputRef}
                            style={hiddenFileInputStyle}
                            onChange={handleFileSelected}
                            multiple // Allow multiple files
                        />
                        <button
                            onClick={() => fileInputRef.current && fileInputRef.current.click()}
                            className={`w-full flex items-center justify-center bg-slate-200 hover:bg-slate-300 text-slate-700 font-semibold px-4 py-3 rounded-md shadow-sm transition-colors text-sm ${isUploading ? 'opacity-50 cursor-not-allowed' : ''}`}
                            disabled={isUploading}
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5 mr-2" viewBox="0 0 20 20" fill="currentColor">
                                <path fillRule="evenodd" d="M3 17a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM6.293 6.707a1 1 0 010-1.414l3-3a1 1 0 011.414 0l3 3a1 1 0 01-1.414 1.414L11 5.414V13a1 1 0 11-2 0V5.414L7.707 6.707a1 1 0 01-1.414 0z" clipRule="evenodd" />
                            </svg>
                            {isUploading ? 'Uploading...' : 'Upload Attachments'}
                        </button>
                        {attachments.length > 0 && (
                            <div className="mt-3 space-y-2">
                                <p className="text-sm font-medium text-slate-700">Attached Files:</p>
                                <ul className="list-disc list-inside bg-slate-50 p-3 rounded-md border border-slate-200">
                                    {attachments.map((att, index) => (
                                        <li key={index} className="text-xs flex justify-between items-center">
                                            <span className={att.isMatch ? 'text-green-600 font-semibold' : 'text-slate-600'}>
                                                {att.original}
                                                {att.isMatch && <span className="ml-1">✔ Matches Order</span>}
                                            </span>
                                            <button onClick={() => setAttachments(attachments.filter((_, i) => i !== index))} className="text-red-500 hover:text-red-700 p-1">
                                                <TrashIcon />
                                            </button>
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        )}
                    </div>
                </div>
                <div className="mt-6 flex items-center justify-between">
                    <button 
                        onClick={onClose} 
                        className="px-4 py-2 bg-slate-200 text-slate-700 font-semibold rounded-md hover:bg-slate-300 transition-colors"
                    >
                        Cancel
                    </button>
                    <button
                        onClick={async () => {
                            if (isSending || isUploading) return;

                            const hasMismatchedPo = attachments.some(att => !att.isMatch);
                            if (attachments.length === 0) {
                                // popup
                                if (!window.confirm("No files are attached. Send email without attachments?")) return;
                            } else if (hasMismatchedPo) {
                                const expectedPoName = `PO_${order.id}.pdf`;
                                if (!window.confirm(`Warning: At least one attachment does not match the expected PO name "${expectedPoName}". Proceed anyway?`)) return;
                            }
                            
                            setIsSending(true);
                            const emailPayload = {
                                order: order,
                                recipientEmail: order.contactInfo.email,
                                subject: subjectText,
                                body: editableBody,
                                attachments: attachments.map(a => ({ original: a.original, unique: a.unique })),
                            };

                            try {
                                const response = await fetch('/api/send-order-email', {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify(emailPayload)
                                });
                                const result = await response.json();
                                if (response.ok) {
                                    setEmailSent(true);
                                    
                                    // New logic: After email sends, update the order status to 'Sent' and save it.
                                    const newStatusHistory = [...order.statusHistory, { status: 'Sent', date: new Date().toISOString() }];
                                    const updatedOrderForStatusChange = { ...order, status: 'Sent', statusHistory: newStatusHistory };

                                    try {
                                        // saveOrder is passed from App, it handles the API call and global state update.
                                        await saveOrder(updatedOrderForStatusChange);
                                    } catch (saveError) {
                                        // If saving the status fails, the user should be notified.
                                        alert(`Email was sent successfully, but there was an error updating the order status: ${saveError.message}`);
                                    }

                                    setTimeout(() => {
                                        if (onEmailClientOpened) {
                                            onEmailClientOpened();
                                        }
                                    }, 1000);
                                } else {
                                    alert(`Failed to send email: ${result.message || 'Server error'}`);
                                }
                            } catch (error) {
                                alert(`Error sending email: ${error.message}`);
                            } finally {
                                setIsSending(false);
                            }
                        }}
                        className={`px-6 py-2 bg-green-600 text-white font-semibold rounded-md hover:bg-green-700 transition-colors ${isSending || isUploading || emailSent ? 'opacity-50 cursor-not-allowed' : ''}`}
                        disabled={isSending || isUploading || emailSent}
                    >
                        {emailSent ? 'Sent!' : isSending ? 'Sending...' : 'Send via Server'}
                    </button>
                </div>
            </div>
        </div>
    );
};

const Calendar = ({ onSelectDate, position, onClose }) => {
    const { useState, useEffect, useRef } = React;
    const [date, setDate] = useState(new Date());
    const calendarRef = useRef(null);

    const handleDateChange = (e) => {
        const newDate = new Date(e.target.value);
        onSelectDate(newDate);
    };
    
    useEffect(() => {
        const handleClickOutside = (event) => {
            if (calendarRef.current && !calendarRef.current.contains(event.target)) {
                onClose();
            }
        };

        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [onClose]);

    return (
        <div ref={calendarRef} style={{ top: position.top, left: position.left }} className="absolute z-20 bg-white border rounded-lg shadow-lg p-2 calendar-container">
            <input type="date" onChange={handleDateChange} className="w-full p-1 border-gray-300 rounded-md"/>
        </div>
    );
};

const ShippedStatusBadge = ({ statusText }) => {
    const { useState, useRef, useEffect } = React;
    const [glintStyle, setGlintStyle] = useState({});
    const badgeRef = useRef(null);
    const proximityThreshold = 75; // Pixels around the badge to trigger the effect

    const baseStyle = {
        background: `linear-gradient(135deg, #FDE047, #FBBF24, #F59E0B)`, // amber-300, amber-400, amber-500
    };

    useEffect(() => {
        setGlintStyle(baseStyle); // Set initial background

        const handleGlobalMouseMove = (e) => {
            if (!badgeRef.current) return;

            const rect = badgeRef.current.getBoundingClientRect();
            const badgeCenterX = rect.left + rect.width / 2;
            const badgeCenterY = rect.top + rect.height / 2;

            const cursorX = e.clientX;
            const cursorY = e.clientY;

            const distanceX = cursorX - badgeCenterX;
            const distanceY = cursorY - badgeCenterY;
            const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);

            if (distance < proximityThreshold + rect.width / 2) { // Add half width/height for smoother edge detection
                // Calculate glare position relative to the badge, even if cursor is outside
                // Normalize cursor position relative to the badge's top-left corner
                const xInBadge = cursorX - rect.left;
                const yInBadge = cursorY - rect.top;

                const glareX = (xInBadge / rect.width) * 100;
                const glareY = (yInBadge / rect.height) * 100;
                
                // Clamp glareX and glareY to prevent extreme gradients if cursor is far but within threshold
                const clampedGlareX = Math.max(-50, Math.min(150, glareX)); // Allow some overflow for effect
                const clampedGlareY = Math.max(-50, Math.min(150, glareY));


                setGlintStyle({
                    background: `radial-gradient(circle at ${clampedGlareX}% ${clampedGlareY}%, rgba(255,255,255,0.75) 0%, rgba(255,255,255,0) 50%), linear-gradient(135deg, #FDE047, #FBBF24, #F59E0B)`,
                    transition: 'background 0.05s linear' // Faster transition for responsiveness
                });
            } else {
                setGlintStyle({...baseStyle, transition: 'background 0.3s ease-out'}); // Slower transition when resetting
            }
        };

        document.addEventListener('mousemove', handleGlobalMouseMove);
        return () => {
            document.removeEventListener('mousemove', handleGlobalMouseMove);
        };
    }, []); // Empty dependency array means this effect runs once on mount and cleans up on unmount

    return (
        <span
            ref={badgeRef}
            className="px-2 py-1 text-xs font-semibold rounded-full text-amber-800 border-2 border-amber-500 shadow-md"
            style={{...glintStyle, display: 'inline-block', position: 'relative', overflow: 'hidden' }} // Added overflow hidden for cleaner gradient edges
        >
            {statusText}
        </span>
    );
};

// --- COMPONENTS ---
const Dashboard = ({ orders, navigateTo, viewOrder, allContacts, allSelectableItems, setOrderForEmailModal }) => {
    const { useState, useEffect, useMemo, useRef } = React;
    const [filteredOrders, setFilteredOrders] = useState(orders);
    const [searchPills, setSearchPills] = useState([]);
    const [inputValue, setInputValue] = useState('');
    const [dashboardStats, setDashboardStats] = useState({ totalRevenue: 0, averageOrderRevenue: 0, totalOrders: 0 });
    const searchInputRef = useRef(null);
    const [showCalendar, setShowCalendar] = useState(false);
    const [calendarPosition, setCalendarPosition] = useState({ top: 0, left: 0 });
    const [dateKeyword, setDateKeyword] = useState('');

    const handleDateSelect = (date) => {
        const dateString = date.toISOString().split('T')[0];
        const newPill = `${dateKeyword}${dateString}`;
        
        // Remove the keyword and any partial date from the input value
        const newInputValue = inputValue.replace(new RegExp(`${dateKeyword}\\S*`), '').trim();

        setInputValue(newInputValue);
        setSearchPills(prev => [...prev, newPill]);
        setShowCalendar(false);
        
        // Focus the input and trigger search after state update
        setTimeout(() => {
            searchInputRef.current.focus();
            handleSearch([...searchPills, newPill].join(' '));
        }, 0);
    };

    const parseInputToPills = (value) => {
        const keywords = ['from', 'contact', 'customer', 'status', 'item', 'note', 'log', 'before', 'after', 'during'];
        const keywordPattern = `(?:${keywords.join('|')}):`;
        const structuredPattern = new RegExp(`(\\b(?:${keywordPattern})(?:"[^"]+"|\S+))|(\\btotal\\s*(?:>=|<=|<>|!=|=|<|>)\\s*\\d+\\.?\\d*)`, 'g');
        
        const newPills = value.match(structuredPattern) || [];
        const remainingText = value.replace(structuredPattern, '').trim();
        
        if (newPills.length > 0) {
            setSearchPills(prev => [...prev, ...newPills]);
        }
        setInputValue(remainingText);
    };

    const handleInputChange = (e) => {
        const { value } = e.target;
        const dateKeywords = ['before:', 'after:', 'during:'];
        const activeKeyword = dateKeywords.find(kw => value.includes(kw));
    
        if (activeKeyword) {
            if (!showCalendar) {
                setDateKeyword(activeKeyword);
                const inputRect = e.target.getBoundingClientRect();
                setCalendarPosition({ top: inputRect.bottom + window.scrollY, left: inputRect.left + window.scrollX });
                setShowCalendar(true);
            }
        }
        
        setInputValue(value);
    };
    
    const handleKeyDown = (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            // Parse any remaining text into pills before searching
            parseInputToPills(inputValue);
            // Use a timeout to allow state to update before searching
            setTimeout(() => handleSearch(), 0);
        } else if (e.key === 'Backspace' && inputValue === '' && searchPills.length > 0) {
            e.preventDefault();
            setSearchPills(searchPills.slice(0, -1));
        }
    };
    
    const removePill = (indexToRemove) => {
        setSearchPills(searchPills.filter((_, index) => index !== indexToRemove));
    };

    const handleSearch = async (query) => {
        const fullQuery = query || [...searchPills, inputValue].join(' ').trim();
        if (fullQuery === '') {
            setFilteredOrders(orders);
            return;
        }
        try {
            const response = await fetch(`/api/search-orders?query=${encodeURIComponent(fullQuery)}`);
            const data = await response.json();
            setFilteredOrders(data);
        } catch (error) {
            console.error("Failed to fetch search results:", error);
        }
    };

    useEffect(() => {
        setFilteredOrders(orders);
        const fetchDashboardStats = async () => {
            try {
                const response = await fetch('/api/dashboard-stats');
                const data = await response.json();
                setDashboardStats(data);
            } catch (error) {
                console.error("Failed to fetch dashboard stats:", error);
                // Set default or error values if needed
                setDashboardStats({ totalRevenue: 0, averageOrderRevenue: 0, totalOrders: orders.length });
            }
        };
        fetchDashboardStats();
    }, [orders]);

    // This function now expects amountInDollars
    const formatCurrency = (amountInDollars) => { 
        // Ensure amountInDollars is a number, default to 0 if not
        const numericAmount = typeof amountInDollars === 'number' ? amountInDollars : parseFloat(amountInDollars) || 0;
        return numericAmount.toLocaleString('en-US', {
            style: 'currency',
            currency: 'USD',
            minimumFractionDigits: 2,
            maximumFractionDigits: 2
        });
    };

    return (
        <React.Fragment>
            {showCalendar && (
                <Calendar
                    onSelectDate={handleDateSelect}
                    position={calendarPosition}
                    onClose={() => setShowCalendar(false)}
                />
            )}
            {/* EmailModal is now handled globally or by OrderForm, so removed from here directly */}
            <div className="flex justify-between items-center mb-6">
                <h1 className="text-3xl font-bold text-slate-800">Dashboard</h1>
                <div className="flex space-x-2">
                    <button onClick={() => navigateTo('createOrder')} className="px-4 py-2 bg-orange-600 text-white font-semibold rounded-md hover:bg-orange-700 transition-colors shadow">+ Create New Order</button>
                </div>
            </div>
            <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                <div className="flex justify-between items-center mb-4">
                    <h2 className="text-xl font-semibold text-slate-700">All Orders</h2>
                    <div className="flex items-center space-x-2">
                        <div 
                            className="flex items-center flex-wrap gap-2 w-full max-w-md bg-white border border-slate-300 rounded-md shadow-sm p-1.5 focus-within:ring-2 focus-within:ring-orange-500 focus-within:border-orange-500"
                            onClick={() => searchInputRef.current && searchInputRef.current.focus()}
                        >
                            {searchPills.map((pill, index) => (
                                <span key={index} className="flex items-center bg-slate-200 text-slate-700 text-sm font-medium px-2 py-1 rounded">
                                    {pill}
                                    <button onClick={() => removePill(index)} className="ml-1.5 text-slate-500 hover:text-slate-800 focus:outline-none">
                                        &times;
                                    </button>
                                </span>
                            ))}
                            <input
                                ref={searchInputRef}
                                type="text"
                                value={inputValue}
                                onChange={handleInputChange}
                                onKeyDown={handleKeyDown}
                                onBlur={() => {
                                    parseInputToPills(inputValue);
                                    setTimeout(() => {
                                        if (!document.activeElement.closest('.calendar-container')) {
                                            setShowCalendar(false);
                                        }
                                    }, 150);
                                }}
                                placeholder={searchPills.length === 0 ? 'Search for anything' : ''}
                                className="flex-grow p-1 bg-transparent focus:outline-none min-w-[100px]"
                            />
                        </div>
                        <button onClick={() => { parseInputToPills(inputValue); setTimeout(() => handleSearch(), 0); }} className="px-4 py-2 bg-orange-600 text-white font-semibold rounded-md hover:bg-orange-700 transition-colors">Search</button>
                    </div>
                </div>
                <div className="overflow-x-auto"><table className="w-full text-sm text-left text-slate-500"><thead className="text-xs text-slate-700 uppercase bg-slate-100"><tr><th className="px-4 py-3">Order ID</th><th className="px-4 py-3">Customer</th><th className="px-4 py-3">Date</th><th className="px-4 py-3">Total</th><th className="px-4 py-3">Status</th><th className="px-4 py-3 text-center">Actions</th></tr></thead>
                    <tbody>{filteredOrders.map(order => {
                        const timeZone = "America/Chicago";
                        const dateOptions = { year: 'numeric', month: 'long', day: 'numeric' };
                        return (<tr key={order.id} onClick={() => viewOrder(order)} className="bg-white border-b hover:bg-slate-50 cursor-pointer">
                        <td className="px-4 py-3 font-medium text-slate-800">{order.display_id || order.id}</td><td className="px-4 py-3">{order.contactInfo.companyName}</td>
                        <td className="px-4 py-3">{formatInTimeZone(order.date, timeZone, dateOptions)}</td><td className="px-4 py-3">${parseFloat(order.total || 0).toFixed(2)}</td>
                        <td className="px-4 py-3">
                            {order.status === 'Shipped' ? (
                                <ShippedStatusBadge statusText={order.status} />
                            ) : (
                                <span className={`px-2 py-1 text-xs font-semibold rounded-full ${
                                    order.status === 'Paid' ? 'bg-green-100 text-green-800' :
                                    order.status === 'Sent' ? 'bg-blue-100 text-blue-800' :
                                    'bg-slate-100 text-slate-800' // Draft or other
                                }`}>{order.status}</span>
                            )}
                        </td>
                        <td className="px-4 py-3 text-center" onClick={e => e.stopPropagation()}>
                            <div className="flex items-center justify-center space-x-2">
                                <button onClick={() => generatePdf(order, allSelectableItems, 'preview')} className="p-1 text-slate-500 hover:text-orange-600"><PdfIcon /></button>
                                <button onClick={() => setOrderForEmailModal(order)} className="p-1 text-slate-500 hover:text-orange-600"><EmailIcon /></button>
                            </div>
                        </td>
                    </tr>)})}</tbody>
                </table></div>
            </div>
        </React.Fragment>
    );
};

const UnsavedChangesModal = ({ onCancel, onDelete, onSaveAndClose }) => {
    return (
        <div className="fixed inset-0 bg-black bg-opacity-50 z-50 flex justify-center items-center p-4">
            <div className="bg-white rounded-lg shadow-xl p-8 w-full max-w-md">
                <h2 className="text-xl font-bold text-slate-800 mb-4">You have unsaved changes.</h2>
                <p className="text-slate-600 mb-6">What would you like to do?</p>
                <div className="flex justify-end space-x-4">
                    <button onClick={onCancel} className="px-4 py-2 bg-slate-200 text-slate-700 font-semibold rounded-md hover:bg-slate-300 transition-colors">Cancel</button>
                    <button onClick={onDelete} className="px-4 py-2 bg-red-600 text-white font-semibold rounded-md hover:bg-red-700 transition-colors">Delete</button>
                    <button onClick={onSaveAndClose} className="px-4 py-2 bg-orange-600 text-white font-semibold rounded-md hover:bg-orange-700 transition-colors">Save and Close</button>
                </div>
            </div>
        </div>
    );
};

const OrderForm = ({ order, navigateTo, saveOrder, deleteOrder, allContacts, allSelectableItems, itemData, packageData, fetchAndUpdateContacts, setOrderForEmailModal }) => { // Added setOrderForEmailModal
    const { useState, useMemo, useEffect, useRef } = React;
    const [isEditing, setIsEditing] = useState(!order || order.status === 'Draft');
    const [formData, setFormData] = useState(order ? {...order, display_id: order.display_id || '', estimatedShipping: order.estimatedShipping || '', scentOption: order.scentOption || 'Scented'} : { display_id: '', contactInfo: { companyName: '', contactName: '', email: '', phone: '', billingAddress: '', billingCity: '', billingState: '', billingZipCode: '', shippingAddress: '', shippingCity: '', shippingState: '', shippingZipCode: '' }, lineItems: [], notes: "", estimatedShippingDate: '', estimatedShipping: '', scentOption: 'Scented', nameDrop: false, signatureDataUrl: null, statusHistory: [{ status: 'Draft', date: new Date().toISOString() }], status: 'Draft' });
    const [contactSuggestions, setContactSuggestions] = useState([]);
    const [showUnsavedChangesModal, setShowUnsavedChangesModal] = useState(false);
    // orderToEmail state is removed, setOrderForEmailModal prop will be used directly
    const [scanInput, setScanInput] = useState('');
    const scanInputRef = React.useRef(null);
    const [sameAsShipping, setSameAsShipping] = useState(true);
    const [isAutofilledContactActive, setIsAutofilledContactActive] = useState(false); // Renamed
    const [initialContactInfoAfterAutofill, setInitialContactInfoAfterAutofill] = useState(null); // New state
    const [isEditingAutofilledContact, setIsEditingAutofilledContact] = useState(false);
    const [isContactInputActive, setIsContactInputActive] = useState(false);
    const hideSuggestionsTimeoutRef = React.useRef(null);
    // fetchAndUpdateContacts is now directly available from props destructuring

    const handleReturnToDashboard = () => {
        const isNewUnsavedDraft = !order && (formData.lineItems.length > 0 || (formData.contactInfo && formData.contactInfo.companyName));

        if (isNewUnsavedDraft) {
            setShowUnsavedChangesModal(true);
        } else {
            navigateTo('dashboard');
        }
    };

    useEffect(() => {
        // Debounce function
        const debounce = (func, delay) => {
            let timeoutId;
            return (...args) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        };

        const debouncedFetchShipping = debounce(fetchEstimatedShipping, 750); // 750ms debounce

        if (formData.contactInfo.shippingZipCode && formData.lineItems) {
             // Only call if zip is 5 digits and there are items
            if (formData.contactInfo.shippingZipCode.length === 5 && /^\d{5}$/.test(formData.contactInfo.shippingZipCode) && formData.lineItems.length > 0) {
                debouncedFetchShipping(formData.contactInfo.shippingZipCode, formData.lineItems);
            } else if (formData.contactInfo.shippingZipCode.length === 5 && /^\d{5}$/.test(formData.contactInfo.shippingZipCode) && formData.lineItems.length === 0) {
                // If valid zip but no items, set shipping to 0
                setFormData(prev => ({ ...prev, estimatedShipping: '0.00' }));
            }
        }
    }, [formData.contactInfo.shippingZipCode, formData.lineItems]);





    const fetchEstimatedShipping = async (zipCode, items) => {
        if (!zipCode || zipCode.length !== 5 || !/^\d{5}$/.test(zipCode)) {
            // console.log("Skipping shipping calculation: Invalid ZIP code format.");
            // Optionally set shipping to 0 or a specific state if ZIP is invalid
            // setFormData(prev => ({ ...prev, estimatedShipping: '' })); // Clear if zip is invalid
            return;
        }
        if (!items || items.length === 0) {
            // console.log("Skipping shipping calculation: No items.");
            setFormData(prev => ({ ...prev, estimatedShipping: '0.00' })); // No items, no shipping cost
            return;
        }

        try {
            const response = await fetch('/api/calculate-shipping-estimate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ shippingZipCode: zipCode, lineItems: items })
            });
            const data = await response.json();
            if (response.ok) {
                setFormData(prev => ({ ...prev, estimatedShipping: data.estimatedShipping.toString() }));
            } else {
                console.error("Failed to fetch shipping estimate:", data.message);
                // setFormData(prev => ({ ...prev, estimatedShipping: '' })); // Clear or set to error state
            }
        } catch (error) {
            console.error("Error fetching shipping estimate:", error);
            // setFormData(prev => ({ ...prev, estimatedShipping: '' })); // Clear or set to error state
        }
    };
    
    useEffect(() => {
        // Debounce function
        const debounce = (func, delay) => {
            let timeoutId;
            return (...args) => {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                    func.apply(this, args);
                }, delay);
            };
        };

        const debouncedFetchShipping = debounce(fetchEstimatedShipping, 750); // 750ms debounce

        if (formData.contactInfo.shippingZipCode && formData.lineItems) {
             // Only call if zip is 5 digits and there are items
            if (formData.contactInfo.shippingZipCode.length === 5 && /^\d{5}$/.test(formData.contactInfo.shippingZipCode) && formData.lineItems.length > 0) {
                debouncedFetchShipping(formData.contactInfo.shippingZipCode, formData.lineItems);
            } else if (formData.contactInfo.shippingZipCode.length === 5 && /^\d{5}$/.test(formData.contactInfo.shippingZipCode) && formData.lineItems.length === 0) {
                // If valid zip but no items, set shipping to 0
                setFormData(prev => ({ ...prev, estimatedShipping: '0.00' }));
            }
        }
    }, [formData.contactInfo.shippingZipCode, formData.lineItems]);


    const formatPhoneNumber = (value) => {
        if (!value) return value;
        const phoneNumber = value.replace(/[^\d]/g, '');
        const phoneNumberLength = phoneNumber.length;
        if (phoneNumberLength < 4) return phoneNumber;
        if (phoneNumberLength < 7) {
            return `(${phoneNumber.slice(0, 3)}) ${phoneNumber.slice(3)}`;
        }
        return `(${phoneNumber.slice(0, 3)}) ${phoneNumber.slice(3, 6)}-${phoneNumber.slice(6, 10)}`;
    };

    let nextId = useMemo(() => formData.lineItems.length > 0 ? Math.max(...formData.lineItems.map(i => i.id)) + 1 : 1, [formData.lineItems]);

    const handleContactInputFocus = () => {
        clearTimeout(hideSuggestionsTimeoutRef.current);
        setIsContactInputActive(true);
    };

    const handleContactInputBlur = () => {
        // Use a timeout to allow click on suggestion list before it disappears
        hideSuggestionsTimeoutRef.current = setTimeout(() => {
            setIsContactInputActive(false);
        }, 150); 
    };
    
const unpackPackage = (id, pkgCode) => {
 
  const pkg = packageData[pkgCode] || { contents: [] };

  const newItems = pkg.contents.map(({ itemCode, quantity }) => {
    const info = itemData[itemCode] || {};
    const selectableInfo = allSelectableItems[itemCode] || {};
    return {
      id:       nextId++,
      item:     itemCode,
      style:    (info.styles && info.styles[0]) || '',
      type:     selectableInfo.type || 'cross',
      quantity: quantity,
      price:    (info.price || 0),
      packageCode: pkgCode,
    };
  });

  setFormData(prev => ({
    ...prev,
    lineItems: [
      ...prev.lineItems.filter(item => item.id !== id),
      ...newItems
    ]
  }));
};

    const handleLineItemChange = (id, field, value) => {
        if (field === 'item' && allSelectableItems[value]?.type === 'package') {
            unpackPackage(id, value);
        } else {
             setFormData(prev => ({...prev, lineItems: prev.lineItems.map(item => {
                 if (item.id !== id) return item;
                 const updatedItem = {...item, [field]: value};
                 if (field === 'item' && itemData[value]) {
                     updatedItem.style = itemData[value].styles?.[0] || '';
                     updatedItem.price = (itemData[value].price || 0);
                     updatedItem.type = allSelectableItems[value]?.type || 'cross';
                 }
                 return updatedItem;
             })}));
        }
    };
    
    const handleScanAddItem = (event) => {
        if (event) event.preventDefault();

        const itemCode = scanInput.trim().toUpperCase();
        if (allSelectableItems[itemCode]) {
            if (allSelectableItems[itemCode].type === 'package') {
                unpackPackage(nextId++, itemCode);
            } else {
                setFormData(prev => ({ ...prev, lineItems: [...prev.lineItems, { id: nextId++, item: itemCode, style: itemData[itemCode]?.styles[0] || '', type: allSelectableItems[itemCode]?.type || 'cross', quantity: 1, price: (itemData[itemCode]?.price || 0), packageCode: null }] })); 
            }
            setScanInput('');
        } else { 
            console.log("Item code not found:", itemCode); 
        }
        if (scanInputRef.current) {
            scanInputRef.current.focus();
        }
    };
    
    const addEmptyLineItem = () => { setFormData(prev => ({ ...prev, lineItems: [...prev.lineItems, { id: nextId++, item: '-- Select Item --', style: '', type: '', quantity: 1, price: 0 }] })); };
    const removeLineItem = (id) => { setFormData(prev => ({ ...prev, lineItems: prev.lineItems.filter(item => item.id !== id) })); };

    const handleContactInfoChange = (field, value) => {
        let processedValue = value;
        if (field === 'phone') {
            processedValue = formatPhoneNumber(value);
        }
        const newContactInfo = {...formData.contactInfo, [field]: processedValue};
        if (field === 'billingAddress' && sameAsBilling) {
            newContactInfo.shippingAddress = processedValue; // if billing address is phone, this would be an issue, but it's not
        }
        // Special handling if 'billingAddress' is being updated and 'sameAsBilling' is true
        if (field === 'billingAddress' && sameAsBilling) {
            newContactInfo.shippingAddress = newContactInfo.billingAddress;
        }

        setFormData(prev => ({ ...prev, contactInfo: newContactInfo }));

        if (isAutofilledContactActive) {
            // Compare current form contact info with the initial info after autofill
            const currentContactString = JSON.stringify(newContactInfo);
            const initialContactString = JSON.stringify(initialContactInfoAfterAutofill);
            if (currentContactString !== initialContactString) {
                setIsEditingAutofilledContact(true);
            } else {
                setIsEditingAutofilledContact(false);
            }
        } else {
            setIsEditingAutofilledContact(false); // If not an active autofilled contact, not editing one
        }

        if (value.length > 1 && (field === 'companyName' || field === 'contactName' || field === 'email')) { // Only suggest for certain fields
            const searchResults = allContacts.filter(contact => {
                const searchLower = value.toLowerCase();
                return (contact.companyName && contact.companyName.toLowerCase().includes(searchLower)) ||
                       (contact.contactName && contact.contactName.toLowerCase().includes(searchLower)) ||
                       (contact.email && contact.email.toLowerCase().includes(searchLower));
            });
            setContactSuggestions(searchResults);
        } else { setContactSuggestions([]); }
    };

    const handleSameAsShippingChange = (e) => {
        const isChecked = e.target.checked;
        setSameAsShipping(isChecked);
        setFormData(prev => ({
            ...prev,
            contactInfo: {
                ...prev.contactInfo,
                billingAddress: isChecked ? prev.contactInfo.shippingAddress : '',
                billingCity: isChecked ? prev.contactInfo.shippingCity : '',
                billingState: isChecked ? prev.contactInfo.shippingState : '',
                billingZipCode: isChecked ? prev.contactInfo.shippingZipCode : ''
            }
        }));
    };
    
    useEffect(() => {
        // Initialize sameAsShipping based on whether shipping and billing addresses are identical when an order is loaded
        if (order && order.contactInfo) {
            if (order.contactInfo.shippingAddress && order.contactInfo.shippingAddress === order.contactInfo.billingAddress) {
                setSameAsShipping(true);
            } else if (order.contactInfo.shippingAddress && !order.contactInfo.billingAddress) {
                 // If billing is empty but shipping is not, assume sameAsShipping should be true initially
                setSameAsShipping(true);
                setFormData(prev => ({
                    ...prev,
                    contactInfo: {
                        ...prev.contactInfo,
                        billingAddress: prev.contactInfo.shippingAddress,
                        billingCity: prev.contactInfo.shippingCity,
                        billingState: prev.contactInfo.shippingState,
                        billingZipCode: prev.contactInfo.shippingZipCode
                    }
                }));
            }
            else {
                setSameAsShipping(false);
            }
        } else {
            // For new orders, default to true
            setSameAsShipping(true);
             setFormData(prev => ({ // ensure billing address is copied if shipping has a default
                ...prev,
                contactInfo: {
                    ...prev.contactInfo,
                    billingAddress: prev.contactInfo.shippingAddress,
                    billingCity: prev.contactInfo.shippingCity,
                    billingState: prev.contactInfo.shippingState,
                    billingZipCode: prev.contactInfo.shippingZipCode
                }
            }));
        }
    }, [order]);


    const selectContact = (contact) => {
        clearTimeout(hideSuggestionsTimeoutRef.current); // Clear any pending hide
        setFormData(prev => {
            const newContactInfo = {...contact};
            if (sameAsShipping) {
                newContactInfo.billingAddress = newContactInfo.shippingAddress;
                newContactInfo.billingCity = newContactInfo.shippingCity;
                newContactInfo.billingState = newContactInfo.shippingState;
                newContactInfo.billingZipCode = newContactInfo.shippingZipCode;
            } else {
                // If not sameAsShipping, retain existing billingAddress from form or set to empty if contact doesn't have one
                newContactInfo.billingAddress = prev.contactInfo.billingAddress || contact.billingAddress || '';
                newContactInfo.billingCity = prev.contactInfo.billingCity || contact.billingCity || '';
                newContactInfo.billingState = prev.contactInfo.billingState || contact.billingState || '';
                newContactInfo.billingZipCode = prev.contactInfo.billingZipCode || contact.billingZipCode || '';
            }
            return {...prev, contactInfo: newContactInfo};
        }); 
        setContactSuggestions([]);
        setInitialContactInfoAfterAutofill(JSON.parse(JSON.stringify(contact))); // Store a deep copy
        setIsAutofilledContactActive(true);
        setIsEditingAutofilledContact(false);
        setIsContactInputActive(false); // Hide suggestions immediately after selection
    }
    
    const orderTotals = useMemo(() => {
        const subtotal = formData.lineItems.reduce((acc, item) => acc + (item.quantity * item.price), 0);
        let nameDropSurcharge = 0;
        let crossItemCount = 0;
        if (formData.nameDrop) {
            formData.lineItems.forEach(item => {
                if (item.type === 'cross') {
                    nameDropSurcharge += item.quantity * 100; // $1 per item quantity
                    crossItemCount += item.quantity;
                }
            });
        }
        // formData.estimatedShipping is expected to be in dollars (float)
        const estimatedShipping = parseFloat(formData.estimatedShipping) || 0; // in dollars
        const estimatedShippingInCents = Math.round(estimatedShipping * 100);

        // Always calculate the total based on current form data components.
        const liveCalculatedTotal = subtotal + nameDropSurcharge + estimatedShippingInCents;

        return { 
            subtotal, // in cents
            nameDropSurcharge, // in cents
            estimatedShipping, // in dollars (for display in summary)
            total: liveCalculatedTotal, // always use the live calculation, in cents
            crossItemCount 
        };
    }, [formData.lineItems, formData.nameDrop, formData.estimatedShipping]);

    const isDraft = formData.status === 'Draft';
    const canEdit = isEditing || isDraft;
    
    const handleStatusChange = (newStatus) => {
        const newStatusHistory = [...formData.statusHistory, { status: newStatus, date: new Date().toISOString() }];
        const updatedOrder = { ...formData, status: newStatus, statusHistory: newStatusHistory };
        setFormData(updatedOrder);
        saveOrder(updatedOrder);
    };
    
    const createOrderObject = (status) => {
        const finalStatus = status || formData.status;
        const newStatusHistory = formData.statusHistory.find(h => h.status === finalStatus) ? formData.statusHistory : [...formData.statusHistory, { status: finalStatus, date: new Date().toISOString() }];
        const isNewOrder = !formData.id;
        
        // Filter out unselected line items before saving
        const filteredLineItems = formData.lineItems.filter(item => item.item !== '-- Select Item --');

        // Recalculate totals based on filtered items
        const subtotal = filteredLineItems.reduce((acc, item) => acc + (item.quantity * item.price), 0);
        let nameDropSurcharge = 0;
        if (formData.nameDrop) {
            filteredLineItems.forEach(item => {
                if (item.type === 'cross') {
                    nameDropSurcharge += item.quantity * 100;
                }
            });
        }
        const estimatedShippingInCents = Math.round((parseFloat(formData.estimatedShipping) || 0) * 100);
        const finalTotal = subtotal + nameDropSurcharge + estimatedShippingInCents;

        return { 
            ...formData, 
            lineItems: filteredLineItems, // Use the filtered list
            id: formData.id || `PO-${Date.now()}`, 
            date: isNewOrder ? (formData.date || new Date().toISOString()) : formData.date, 
            status: finalStatus, 
            statusHistory: newStatusHistory, 
            total: finalTotal, // Use the recalculated total
            signatureDataUrl: formData.signatureDataUrl 
        };
    };

    const handleSaveDraft = async () => {
        if (!formData.contactInfo.companyName) {
            console.log("Order save failed: Please select a contact.");
            return;
        }
        const newOrder = createOrderObject('Draft');
        try {
            await saveOrder(newOrder);
            navigateTo('dashboard');
        } catch (error) {
            // Error is already logged by saveOrder, just log to console here
            console.log(`Failed to save draft: ${error.message}`);
        }
    };
    
    const handleSaveAndSend = async () => {
        if (!formData.contactInfo.companyName || !formData.contactInfo.email) { console.log("Order save failed: Please select a contact with a valid email address."); return; }
        const newOrder = createOrderObject('Sent'); // Order status is 'Sent'
        await saveOrder(newOrder); // Save the order
        
        // Instead of direct mailto and navigate, trigger the EmailModal
        // The EmailModal's onEmailClientOpened callback (passed from App component) will handle navigation.
        setOrderForEmailModal(newOrder); 
    };

    const handlePreviewPdf = () => { const tempOrder = createOrderObject(); generatePdf(tempOrder, allSelectableItems, 'preview'); };
    
    const handleDelete = async () => {
        if (!formData || !formData.id) {
            console.log("Cannot delete: Order data is missing.");
            return;
        }

        const orderId = formData.id;
        const orderStatus = formData.status;
        const companyName = formData.contactInfo?.companyName || "";
        const cleanedOrderId = orderId.replace("PO-", "");
        let orderIdDigitsForConfirmation = "";

        if (cleanedOrderId.length >= 4) {
            orderIdDigitsForConfirmation = cleanedOrderId.slice(-4); // Get last 4 digits
        } else if (cleanedOrderId.length > 0) {
            orderIdDigitsForConfirmation = cleanedOrderId; // Use all available if less than 4
        }


        let confirmationMessage = "Are you sure you want to delete this order? This action cannot be undone.";
        let requiresSpecialConfirmation = false;
        let expectedConfirmationPhrase = "";

        if (orderStatus !== 'Draft') {
            requiresSpecialConfirmation = true;
            if (!companyName || !orderIdDigitsForConfirmation) {
                 console.log("Cannot proceed with deletion: Company name or Order ID is missing/invalid for confirmation string generation.");
                 return;
            }
            expectedConfirmationPhrase = `delete ${companyName} order ${orderIdDigitsForConfirmation}`;
            confirmationMessage = `To delete this order, please type the following exactly:\n\n"${expectedConfirmationPhrase}"`; // Added \n\n for a new line and some spacing
        }

        const userInput = window.prompt(confirmationMessage);

        if (userInput === null) { // User cancelled the prompt
            return;
        }

        let deletePayload = { ...formData, status: "Deleted" };

        if (requiresSpecialConfirmation) {
            if (userInput === expectedConfirmationPhrase) {
                deletePayload.deleteConfirmation = userInput; // Pass to backend
            } else {
                console.log("Deletion cancelled: The confirmation phrase was incorrect.");
                return;
            }
        } else { // For Draft orders, simple confirm is enough (prompt acts as confirm)
            if (userInput === "" && orderStatus === 'Draft' && window.confirm("Are you sure you want to delete this draft? This action cannot be undone.")) {
                 // This path is if prompt was empty but they confirm a second time.
                 // However, the prompt itself serves as the main confirmation for draft.
                 // If prompt is empty for draft, we can assume they don't want to type anything.
            } else if (userInput !== "" && orderStatus === 'Draft') {
                // If they typed something for a draft order, it's not the special confirmation,
                // but we can treat it as a "yes" to the prompt.
            } else if (orderStatus !== 'Draft') { 
                // This case should not be reached if requiresSpecialConfirmation logic is correct.
                console.log("Deletion cancelled.");
                return;
            }
            // For draft, no special deleteConfirmation field needed unless backend strictly requires it (which it doesn't for drafts)
        }
        
        // Proceed with deletion
        try {
            await deleteOrder(orderId, deletePayload); // Pass the full payload for deletion
            navigateTo('dashboard');
        } catch (error) {
            // Error should be handled by saveOrder/deleteOrder and displayed by them or here
            console.error("Error during delete operation:", error);
            console.log(`Failed to delete order: ${error.message || 'Unknown error'}`);
        }
    };

    const handleCancelContactEdit = () => {
        if (initialContactInfoAfterAutofill) {
            setFormData(prev => ({ ...prev, contactInfo: JSON.parse(JSON.stringify(initialContactInfoAfterAutofill)) }));
        }
        setIsEditingAutofilledContact(false);
        // isAutofilledContactActive remains true because we reverted to the autofilled state
    };

    const handleSaveContactEdits = async () => {
        if (!initialContactInfoAfterAutofill || !initialContactInfoAfterAutofill.id) {
            console.log("Cannot save edits: Original contact ID is missing.");
            return;
        }
        const contactIdToUpdate = initialContactInfoAfterAutofill.id;
        const payload = { ...formData.contactInfo }; // Current form data for contact
        // Ensure ID in payload matches, or remove it if backend prefers ID only in URL
        payload.id = contactIdToUpdate; 

        try {
            const response = await fetch(`/api/contacts/${contactIdToUpdate}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            const result = await response.json();
            if (response.ok && result.status === 'success') {
                setInitialContactInfoAfterAutofill(JSON.parse(JSON.stringify(result.contact))); // Update with data from server
                setFormData(prev => ({ ...prev, contactInfo: JSON.parse(JSON.stringify(result.contact)) }));
                setIsEditingAutofilledContact(false);
                if (fetchAndUpdateContacts) fetchAndUpdateContacts(); // Refresh global contact list
                console.log("Contact edits saved successfully.");
            } else {
                console.log(`Failed to save contact edits: ${result.message || 'Unknown error'}`);
            }
        } catch (error) {
            console.error("Error saving contact edits:", error);
            console.log(`Error saving contact edits: ${error.message}`);
        }
    };

    const handleCreateNewContactRecord = async () => {
        const currentContactData = { ...formData.contactInfo };
        // Remove 'id' to ensure a new record is created by the backend
        delete currentContactData.id; 

        if (!currentContactData.companyName) {
            console.log("Company name is required to create a new contact record.");
            return;
        }

        try {
            const response = await fetch('/api/contacts', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(currentContactData)
            });
            const result = await response.json();
            if (response.ok && result.status === 'success' && result.contact) {
                const newContactFromServer = result.contact;
                setFormData(prev => ({ ...prev, contactInfo: JSON.parse(JSON.stringify(newContactFromServer)) }));
                setInitialContactInfoAfterAutofill(JSON.parse(JSON.stringify(newContactFromServer)));
                setIsAutofilledContactActive(true); // Now it's an "autofilled" (newly created) record
                setIsEditingAutofilledContact(false);
                if (fetchAndUpdateContacts) fetchAndUpdateContacts(); // Refresh global contact list
                console.log(`New contact "${newContactFromServer.companyName}" created successfully with ID: ${newContactFromServer.id}`);
            } else {
                console.log(`Failed to create new contact record: ${result.message || 'Unknown error'}`);
            }
        } catch (error) {
            console.error("Error creating new contact record:", error);
            console.log(`Error creating new contact record: ${error.message}`);
        }
    };

    const handleClearAllContactInputs = () => { // Renamed
        setFormData(prev => ({
            ...prev,
            contactInfo: { companyName: '', contactName: '', email: '', phone: '', billingAddress: '', shippingAddress: '' }
        }));
        // If clearing inputs, it's no longer an "autofilled" scenario in its original sense for editing purposes.
        // However, if the user *then* types something identical to a known contact, suggestions should still work.
        // The key is that `isEditingAutofilledContact` should be false.
        setInitialContactInfoAfterAutofill(null); // No specific "initial" state to compare against after clearing.
        setIsAutofilledContactActive(false); // It's effectively a new entry or cleared state.
        setIsEditingAutofilledContact(false);
    };

    return (
        <>
            {showUnsavedChangesModal && (
                <UnsavedChangesModal
                    onCancel={() => setShowUnsavedChangesModal(false)}
                    onDelete={() => {
                        setShowUnsavedChangesModal(false);
                        navigateTo('dashboard');
                    }}
                    onSaveAndClose={() => {
                        setShowUnsavedChangesModal(false);
                        handleSaveDraft();
                    }}
                />
            )}
            {/* EmailModal is now handled at the App level, triggered by setOrderForEmailModal prop */}
            <div className="mb-6"><button onClick={handleReturnToDashboard} className="text-orange-600 hover:text-orange-800 font-semibold">&larr; Back to Dashboard</button><h1 className="text-3xl font-bold text-slate-800 mt-2">{order ? `Order Details: ${formData.display_id || order.id}` : 'New Purchase Order'}</h1></div>
            <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
                <div className="lg:col-span-2 space-y-6">
                    <div className="relative">
                         <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200 mb-6">
                            <Input label="Custom Order ID" value={formData.display_id} onChange={e => setFormData(prev => ({...prev, display_id: e.target.value}))} disabled={!canEdit} />
                        </div>
                        <div className={`bg-white p-6 rounded-lg shadow-sm border ${isEditingAutofilledContact ? 'border-red-500 shadow-red-300/50 ring-2 ring-red-500' : 'border-slate-200'}`}>
                            <h2 className="text-xl font-semibold text-slate-700 border-b pb-3 mb-4">Contact Information</h2>
                            {isEditingAutofilledContact && (
                                <div className="mb-4 p-3 bg-red-50 border border-red-200 rounded-md text-center">
                                    <p className="text-sm font-medium text-red-700">You are editing a contact record.</p>
                                    <div className="mt-3 flex flex-wrap justify-center gap-2">
                                        <button onClick={handleCancelContactEdit} className="px-3 py-1.5 text-xs bg-gray-500 text-white font-semibold rounded-md hover:bg-gray-600">Cancel</button>
                                        <button onClick={handleSaveContactEdits} className="px-3 py-1.5 text-xs bg-green-600 text-white font-semibold rounded-md hover:bg-green-700">Save Edits</button>
                                        <button onClick={handleClearAllContactInputs} className="px-3 py-1.5 text-xs bg-slate-500 text-white font-semibold rounded-md hover:bg-slate-600">Clear All Inputs</button>
                                        <button onClick={handleCreateNewContactRecord} className="px-3 py-1.5 text-xs bg-blue-600 text-white font-semibold rounded-md hover:bg-blue-700">Create New Record</button>
                                    </div>
                                </div>
                            )}
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                <div className="space-y-4">
                                    <Input label="Company Name" value={formData.contactInfo.companyName} onChange={e => handleContactInfoChange('companyName', e.target.value)} disabled={!canEdit} onFocus={handleContactInputFocus} onBlur={handleContactInputBlur} />
                                    <Input label="Contact Name" value={formData.contactInfo.contactName} onChange={e => handleContactInfoChange('contactName', e.target.value)} disabled={!canEdit} onFocus={handleContactInputFocus} onBlur={handleContactInputBlur} />
                                    <Input label="Email" value={formData.contactInfo.email} onChange={e => handleContactInfoChange('email', e.target.value)} disabled={!canEdit} onFocus={handleContactInputFocus} onBlur={handleContactInputBlur} />
                                    <Input label="Phone" value={formData.contactInfo.phone} onChange={e => handleContactInfoChange('phone', e.target.value)} disabled={!canEdit} onFocus={handleContactInputFocus} onBlur={handleContactInputBlur} />
                                </div>
                                <div className="space-y-4">
                                    <Input label="Shipping Address" value={formData.contactInfo.shippingAddress} onChange={e => handleContactInfoChange('shippingAddress', e.target.value)} disabled={!canEdit} onFocus={handleContactInputFocus} onBlur={handleContactInputBlur} />
                                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                        <Input label="City" value={formData.contactInfo.shippingCity} onChange={e => handleContactInfoChange('shippingCity', e.target.value)} disabled={!canEdit} onFocus={handleContactInputFocus} onBlur={handleContactInputBlur} />
                                        <Input label="State" value={formData.contactInfo.shippingState} onChange={e => handleContactInfoChange('shippingState', e.target.value)} disabled={!canEdit} onFocus={handleContactInputFocus} onBlur={handleContactInputBlur} />
                                        <Input label="Zip Code" value={formData.contactInfo.shippingZipCode} onChange={e => handleContactInfoChange('shippingZipCode', e.target.value)} disabled={!canEdit} onFocus={handleContactInputFocus} onBlur={handleContactInputBlur} />
                                    </div>
                                    <label className="block text-sm font-medium text-slate-600 pt-4">Billing Address</label>
                                    <div className="flex items-center">
                                        <input id="sameAsShipping" type="checkbox" checked={sameAsShipping} onChange={handleSameAsShippingChange} disabled={!canEdit} className="h-4 w-4 text-orange-600 border-slate-300 rounded focus:ring-orange-500 disabled:opacity-50" />
                                        <label htmlFor="sameAsShipping" className="ml-2 block text-sm text-slate-700">Same as Shipping Address</label>
                                    </div>
                                    {!sameAsShipping && (
                                        <div className="space-y-4">
                                            <Input label="Billing Address" value={formData.contactInfo.billingAddress} onChange={e => handleContactInfoChange('billingAddress', e.target.value)} disabled={!canEdit} onFocus={handleContactInputFocus} onBlur={handleContactInputBlur} />
                                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                                <Input label="City" value={formData.contactInfo.billingCity} onChange={e => handleContactInfoChange('billingCity', e.target.value)} disabled={!canEdit} onFocus={handleContactInputFocus} onBlur={handleContactInputBlur} />
                                                <Input label="State" value={formData.contactInfo.billingState} onChange={e => handleContactInfoChange('billingState', e.target.value)} disabled={!canEdit} onFocus={handleContactInputFocus} onBlur={handleContactInputBlur} />
                                                <Input label="Zip Code" value={formData.contactInfo.billingZipCode} onChange={e => handleContactInfoChange('billingZipCode', e.target.value)} disabled={!canEdit} onFocus={handleContactInputFocus} onBlur={handleContactInputBlur} />
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                        {contactSuggestions.length > 0 && canEdit && isContactInputActive && (
                            <div className="absolute z-10 w-full mt-1 bg-white border border-slate-300 rounded-lg shadow-lg">
                                <ul className="py-1 max-h-60 overflow-y-auto">
                                    {contactSuggestions.map(contact => (
                                        <li key={contact.id} onClick={() => selectContact(contact)} className="px-4 py-2 hover:bg-orange-100 cursor-pointer">
                                            <p className="font-semibold text-slate-800">{contact.companyName}</p>
                                            <p className="text-sm text-slate-500">{contact.contactName} - {contact.email}</p>
                                        </li>
                                    ))}
                                </ul>
                            </div>
                        )}
                    </div>

                    <OrderLogsSection orderId={formData.id} canEdit={canEdit} allContacts={allContacts} />

                    <div className="bg-white rounded-lg shadow-sm border border-slate-200"><div className="p-6 border-b"><h2 className="text-xl font-semibold text-slate-700 mb-4">Line Items</h2>{canEdit && (<div className="flex gap-2"><input ref={scanInputRef} type="text" value={scanInput} onChange={e => setScanInput(e.target.value)} onKeyDown={e => { if (e.key === 'Enter') { handleScanAddItem(e); } }} placeholder="Scan or Enter Item Code" className="flex-grow block w-full px-3 py-2 bg-white border border-slate-300 rounded-md shadow-sm placeholder-slate-400 focus:outline-none focus:ring-orange-500 focus:border-orange-500 sm:text-sm" /><button onClick={handleScanAddItem} className="px-4 py-2 bg-orange-600 text-white font-semibold rounded-md hover:bg-orange-700 transition-colors">Add</button></div>)}</div><div className="overflow-x-auto"><table className="w-full text-sm text-left text-slate-500"><thead className="text-xs text-slate-700 uppercase bg-slate-100"><tr><th scope="col" className="px-4 py-3">Item</th><th scope="col" className="px-4 py-3">Style</th><th scope="col" className="px-4 py-3 text-center">Qty</th><th scope="col" className="px-4 py-3 text-right">Unit Price</th><th scope="col" className="px-4 py-3 text-right">Total</th>{canEdit && <th scope="col" className="px-2 py-3"></th>}</tr></thead><tbody>{formData.lineItems.map(item => (<tr key={item.id} className="border-b align-middle"><td className="px-4 py-2"><Select value={item.item} onChange={e => handleLineItemChange(item.id, 'item', e.target.value)} disabled={!canEdit}><option value="-- Select Item --">-- Select Item --</option>{Object.entries(allSelectableItems).map(([id, details]) => (<option key={id} value={id}>{details.name}</option>))}</Select></td><td className="px-4 py-2"><Select value={item.style} onChange={e => handleLineItemChange(item.id, 'style', e.target.value)} disabled={!canEdit}>{(allSelectableItems[item.item]?.styles || []).map(name => (<option key={name} value={name}>{name}</option>))}</Select></td><td className="px-4 py-2"><input type="number" min="0" value={item.quantity} onChange={e => handleLineItemChange(item.id, 'quantity', Number(e.target.value))} className="w-16 sm:w-20 text-center bg-white border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-orange-500 focus:border-orange-500 sm:text-sm p-2" disabled={!canEdit} /></td><td className="px-4 py-2 text-right"><PriceInput value={item.price} onChange={newPrice => handleLineItemChange(item.id, 'price', newPrice)} disabled={!canEdit}/></td><td className="px-4 py-2 text-right font-medium text-slate-800">${((item.quantity * item.price) / 100).toFixed(2)}</td>{canEdit && <td className="px-2 py-2 text-center"><button onClick={() => removeLineItem(item.id)} className="text-slate-400 hover:text-red-600 p-1 rounded-full hover:bg-red-100 transition-colors"><TrashIcon /></button></td>}</tr>))}</tbody></table></div>{canEdit && <div className="p-6 border-t"><button onClick={addEmptyLineItem} className="w-full text-center px-4 py-2 bg-orange-100 text-orange-700 font-semibold rounded-md hover:bg-orange-200 transition-colors">+ Add Line Item</button></div>}</div>
                </div>
                <div className="lg:col-span-1 space-y-6">
                    <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200"><h2 className="text-xl font-semibold text-slate-700 border-b pb-3 mb-4">Order Metadata</h2><div className="space-y-4"><Input label="Estimated Shipping Date" type="date" value={formData.estimatedShippingDate} onChange={e => setFormData(p=>({...p, estimatedShippingDate: e.target.value}))} disabled={!canEdit} /><ScentToggle value={formData.scentOption} onChange={val => setFormData(p=>({...p, scentOption: val}))} disabled={!canEdit} /><NameDropToggle value={formData.nameDrop} onChange={val => setFormData(p=>({...p, nameDrop: val}))} disabled={!canEdit} /></div></div>
                    {!isDraft && (<div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200"><h2 className="text-xl font-semibold text-slate-700 mb-4">Update Status</h2><div className="space-y-2"><button onClick={() => handleStatusChange('Paid')} disabled={formData.status !== 'Sent'} className="w-full text-center px-4 py-2 bg-blue-500 text-white font-semibold rounded-md hover:bg-blue-600 disabled:bg-slate-300 disabled:cursor-not-allowed">Mark as Paid</button><button onClick={() => handleStatusChange('Shipped')} disabled={formData.status !== 'Paid'} className="w-full text-center px-4 py-2 bg-green-500 text-white font-semibold rounded-md hover:bg-green-600 disabled:bg-slate-300 disabled:cursor-not-allowed">Mark as Shipped</button></div></div>)}
                    <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h2 className="text-xl font-semibold text-slate-700 mb-3 border-b pb-3">Signature</h2>
                        <SignaturePad 
                            initialDataUrl={formData.signatureDataUrl}
                            onSave={(dataUrl) => setFormData(prev => ({...prev, signatureDataUrl: dataUrl}))}
                            disabled={!canEdit}
                        />
                    </div>
                    <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h2 className="text-xl font-semibold text-slate-700 mb-3">Notes</h2>
                        <ContactMentionTextarea
                            value={formData.notes}
                            onChange={value => setFormData(p => ({...p, notes: value}))}
                            rows={4}
                            disabled={!canEdit}
                            contacts={allContacts}
                            placeholder="Capture order notes and use @handle to mention key contacts"
                            label=""
                        />
                    </div>
                    <div className="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h2 className="text-xl font-semibold text-slate-700 mb-4">Order Summary</h2>
                        <div className="space-y-3">
                            <div className="flex justify-between items-center text-slate-600"><span>Subtotal</span><span className="font-medium">${(orderTotals.subtotal / 100).toFixed(2)}</span></div>
                            {orderTotals.nameDropSurcharge > 0 && (
                                <div className="flex justify-between items-center text-slate-600">
                                    <span>Name Drop Surcharge ({orderTotals.crossItemCount} crosses)</span>
                                    <span className="font-medium">${(orderTotals.nameDropSurcharge / 100).toFixed(2)}</span>
                                </div>
                            )}
                            {orderTotals.estimatedShipping > 0 && (
                                <div className="flex justify-between items-center text-slate-600">
                                    <span>Est. Shipping</span>
                                    <span className="font-medium">${orderTotals.estimatedShipping.toFixed(2)}</span>
                                </div>
                            )}
                            <div className="flex justify-between items-center font-bold text-xl text-slate-800"><span>Total</span><span>${(orderTotals.total / 100).toFixed(2)}</span></div>
                        </div>
                    </div>
                    <div className="space-y-3">
                        {isDraft && <button onClick={handleSaveAndSend} className="w-full text-center px-6 py-3 bg-orange-600 text-white font-bold rounded-md hover:bg-orange-700">Save and Send</button>}
                        {!isDraft && !isEditing && <button onClick={() => setOrderForEmailModal(formData)} className="w-full text-center px-6 py-3 bg-orange-600 text-white font-bold rounded-md hover:bg-orange-700">Resend Email</button>}
                        {isDraft && <button onClick={handleSaveDraft} className="w-full text-center px-6 py-3 bg-slate-600 text-white font-bold rounded-md hover:bg-slate-700">Save as Draft</button>}
                        {isEditing && !isDraft && <button onClick={() => {saveOrder(createOrderObject()); setIsEditing(false);}} className="w-full text-center px-6 py-3 bg-slate-600 text-white font-bold rounded-md hover:bg-slate-700">Save Changes</button>}
                        <button onClick={handlePreviewPdf} className="w-full text-center px-6 py-3 bg-white text-slate-700 font-bold rounded-md hover:bg-slate-100 border border-slate-300">Preview PDF</button>
                        {!isDraft && !isEditing && <button onClick={() => setIsEditing(true)} className="w-full text-center px-6 py-3 bg-blue-100 text-blue-700 font-bold rounded-md hover:bg-blue-200">Edit Order</button>}
                        {/* Always show delete button if order exists (formData.id) */}
                        {formData.id && (
                            <button 
                                onClick={handleDelete} 
                                className="w-full text-center px-6 py-3 bg-red-100 text-red-700 font-bold rounded-md hover:bg-red-200"
                            >
                                {isDraft ? "Delete Draft" : "Delete Order"}
                            </button>
                        )}
                    </div>
                </div>
            </div>
        </>
    );
};

// --- MAIN APP COMPONENT (Router) ---
const App = () => {
    const { useState, useEffect, useCallback } = React;
    const [page, setPage] = useState('dashboard');
    const [orders, setOrders] = useState([]);
    const [activeOrder, setActiveOrder] = useState(null);
    const [isLoading, setIsLoading] = useState(true);
    const [allContacts, setAllContacts] = useState([]);
    const [allSelectableItems, setAllSelectableItems] = useState({});
    const [itemData, setItemData] = useState({});
    const [packageData, setPackageData] = useState({});
    const [orderForEmailModal, setOrderForEmailModal] = useState(null); // State to control EmailModal
    const [showSettingsMenu, setShowSettingsMenu] = useState(false);
    const [appSettings, setAppSettings] = useState({ company_name: "Your Company", default_email_body: "" }); // Added appSettings

    const handleOrderUpdate = (updatedOrderFromServer) => { // Added this function
        setOrders(prevOrders => {
            const index = prevOrders.findIndex(o => o.id === updatedOrderFromServer.id);
            if (index !== -1) {
                const updatedOrders = [...prevOrders];
                updatedOrders[index] = updatedOrderFromServer;
                return updatedOrders;
            }
            // Fallback for safety, though email update should always find the order
            console.warn("Order to update from email not found in existing orders list.");
            return [...prevOrders.filter(o => o.id !== updatedOrderFromServer.id), updatedOrderFromServer];
        });
    };

    const fetchAndUpdateContacts = async () => {
        try {
            const contactsRes = await fetch('/api/contacts');
            const contactsData = await contactsRes.json();
            setAllContacts(contactsData);
        } catch (error) {
            console.error("Failed to re-fetch contacts:", error);
        }
    };

    useEffect(() => {
        const fetchData = async () => {
            setIsLoading(true);
            try {
            const [ordersRes, contactsRes, itemsRes, packagesRes, settingsRes] = await Promise.all([
                fetch('/api/orders'),
                fetch('/api/contacts'),
                fetch('/api/items'),
                fetch('/api/packages'),
                fetch('/api/settings') // Fetch settings
            ]);

            const ordersData   = await ordersRes.json();
            const settingsData = await settingsRes.json(); // Get settings data
            setAppSettings(settingsData); // Set app settings
            const contactsData  = await contactsRes.json();
            const itemsDataArray    = await itemsRes.json(); // Renamed to itemsDataArray
            const packagesData = await packagesRes.json();

            // Transform itemsDataArray to an object keyed by item_code
            const itemsDataById = itemsDataArray.reduce((acc, item) => {
                acc[item.item_code] = item; // Use item_code as the key
                return acc;
            }, {});

            setOrders(ordersData);
            setAllContacts(contactsData);
            // Combine items (now itemsDataById) and packages for the dropdown
            const combinedSelectableItems = { ...itemsDataById }; // Spread the object
            for (const pkgId in packagesData) {
                combinedSelectableItems[pkgId] = { 
                    name: packagesData[pkgId].name, 
                    type: packagesData[pkgId].type, 
                    styles: [] // Packages don't have styles in the same way items do
                };
            }
            setAllSelectableItems(combinedSelectableItems);
            setItemData(itemsDataById); // Store the object version
            setPackageData(packagesData); // Store raw packages data

            // Check for order_id in URL to load an order for editing
            const urlParams = new URLSearchParams(window.location.search);
            const orderIdFromUrl = urlParams.get('order_id');
            if (orderIdFromUrl) {
                const orderToEdit = ordersData.find(o => o.id === orderIdFromUrl);
                if (orderToEdit) {
                    setActiveOrder(orderToEdit);
                    setPage('viewOrder');
                }
            } else {
                const viewParam = urlParams.get('view');
                if (viewParam === 'create') {
                    setPage('createOrder');
                }
            }

            } catch (error) {
            console.error("Failed to fetch data:", error);
            } finally {
            setIsLoading(false);
            }
        };
        fetchData();
    }, []);

    
    const navigateTo = (pageName) => {
        if (pageName === 'settings') {
            window.location.href = '/settings';
            return;
        }
        setPage(pageName);
    };

    const viewOrder = (order) => {
        window.location.href = `/order/${order.id}`;
    };
    
    const saveOrder = async (orderToSave) => {
        try {
            const response = await fetch('/api/orders', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(orderToSave)
            });
            const result = await response.json();
            if (result.status === 'success' && result.order) {
                const savedOrderFromServer = result.order;
                setOrders(prevOrders => {
                    const index = prevOrders.findIndex(o => o.id === savedOrderFromServer.id);
                    if (index !== -1) {
                        // Update existing order
                        const updatedOrders = [...prevOrders];
                        updatedOrders[index] = savedOrderFromServer;
                        return updatedOrders;
                    } else {
                        // Add new order
                        return [savedOrderFromServer, ...prevOrders.filter(o => o.id !== savedOrderFromServer.id)];
                    }
                });
            } else {
                console.error("Failed to save order - server response:", result.message || "Unknown server error");
                throw new Error(result.message || "Failed to save order on server.");
            }
        } catch (error) {
            console.error("Failed to save order - network/fetch error:", error);
            throw error; // Re-throw to be caught by caller
        }
    };
    
    const deleteOrder = async (orderId, deletePayload) => { // deletePayload now comes from handleDelete
        const orderToDelete = orders.find(o => o.id === orderId);
        if (!orderToDelete) {
            console.warn("Order not found for deletion:", orderId);
            throw new Error("Order not found locally. Cannot proceed with deletion.");
        }

        // The deletePayload already has status: "Deleted" and potentially deleteConfirmation
        // It also includes the latest statusHistory from the form's state.
        // We just need to ensure the statusHistory is correctly updated if not already done by createOrderObject logic
        const finalPayload = {
            ...deletePayload, // This comes from handleDelete, based on formData
            status: "Deleted", // Ensure it's set
            statusHistory: [
                ...(deletePayload.statusHistory || orderToDelete.statusHistory || []), // Use payload's history, fallback to existing
                { status: "Deleted", date: new Date().toISOString() }
            ].filter((item, index, self) => // Deduplicate status history just in case
                index === self.findIndex((t) => (
                    t.status === item.status && new Date(t.date).getTime() === new Date(item.date).getTime()
                )) || item.status !== "Deleted" // Keep all non-deleted, allow multiple "Deleted" if dates differ (though unlikely here)
            )
        };
         // Ensure the last entry for "Deleted" is the most recent one if multiple somehow exist
        const deletedEntries = finalPayload.statusHistory.filter(h => h.status === "Deleted");
        if (deletedEntries.length > 1) {
            const latestDeletedEntry = deletedEntries.reduce((latest, current) => 
                new Date(current.date) > new Date(latest.date) ? current : latest
            );
            finalPayload.statusHistory = [
                ...finalPayload.statusHistory.filter(h => h.status !== "Deleted"),
                latestDeletedEntry
            ];
        }


        // saveOrder will handle the API call and local state update
        // It expects the full order object to save/update.
        await saveOrder(finalPayload); 
    };
    
    if (isLoading) {
        return <div className="text-center p-8">Loading...</div>;
    }

    const renderPage = () => {
        switch(page) {
            case 'createOrder': 
                return <OrderForm navigateTo={navigateTo} saveOrder={saveOrder} allContacts={allContacts} allSelectableItems={allSelectableItems} itemData={itemData} packageData={packageData} fetchAndUpdateContacts={fetchAndUpdateContacts} setOrderForEmailModal={setOrderForEmailModal} />;
            case 'viewOrder': 
                // This case is now handled by a separate page, but we keep the OrderForm logic
                // for when the user navigates back to edit from the view page via URL param.
                return <OrderForm order={activeOrder} navigateTo={navigateTo} saveOrder={saveOrder} deleteOrder={deleteOrder} allContacts={allContacts} allSelectableItems={allSelectableItems} itemData={itemData} packageData={packageData} fetchAndUpdateContacts={fetchAndUpdateContacts} setOrderForEmailModal={setOrderForEmailModal} />;
            case 'dashboard':
            default:
                return <Dashboard orders={orders} navigateTo={navigateTo} viewOrder={viewOrder} allContacts={allContacts} allSelectableItems={allSelectableItems} setOrderForEmailModal={setOrderForEmailModal} />;
        }
    }

    const handleLogout = useCallback(async () => {
        try {
            const response = await fetch('/shutdown', { method: 'POST' });
            if (response.ok) {
                // Server acknowledged shutdown, update page content
                document.body.innerHTML = '<div style="text-align: center; padding: 50px; font-family: sans-serif; font-size: 1.2em; color: #333;">Application has been shut down. You can now close this tab.</div>';
                // No automatic window.close() as it's unreliable and can be blocked.
            } else {
                // Server responded, but not with success (e.g., 500 error if shutdown endpoint failed before responding)
                alert('Failed to send shutdown signal to the server (server responded with an error). Please close the tab manually.');
            }
        } catch (error) {
            // Network error or server completely unreachable (possibly already shut down)
            console.error('Error during shutdown attempt:', error);
            alert('Error attempting to shut down the server. Please use Task Manager to stop the task.');
        }
    }, []);

    useEffect(() => {
        window.fireCoastNavigateTo = (target) => {
            if (target === 'createOrder') {
                setPage('createOrder');
            } else if (target === 'dashboard') {
                setPage('dashboard');
            }
        };
        window.fireCoastLogout = handleLogout;
        return () => {
            delete window.fireCoastNavigateTo;
            delete window.fireCoastLogout;
        };
    }, [handleLogout]);

    return (
        <div className="bg-slate-50 min-h-screen font-sans">
            {orderForEmailModal && (
                <EmailModal
                    order={orderForEmailModal}
                    allItems={allSelectableItems}
                    appSettings={appSettings} // Pass appSettings
                    saveOrder={saveOrder}
                    onClose={() => setOrderForEmailModal(null)}
                    onOrderUpdatedAfterEmail={handleOrderUpdate} // Pass the new handler
                    onEmailClientOpened={() => {
                        setOrderForEmailModal(null);
                        navigateTo('dashboard'); 
                    }}
                />
            )}
            <div className="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
                {renderPage()}
            </div>
            {/* Quick access menu for settings and shutdown actions */}
            <div className="fixed bottom-4 left-4 z-50">
                <button
                    onClick={() => setShowSettingsMenu(!showSettingsMenu)}
                    className="p-3 bg-slate-600 text-white rounded-full shadow-lg hover:bg-slate-700 transition-colors focus:outline-none focus:ring-2 focus:ring-slate-500 focus:ring-opacity-75"
                    aria-label="Settings"
                >
                    <CogIcon />
                </button>
                {showSettingsMenu && (
                    <div
                        className="absolute bottom-full left-0 mb-2 w-48 bg-white rounded-md shadow-lg py-1 ring-1 ring-black ring-opacity-5 focus:outline-none"
                        role="menu"
                        aria-orientation="vertical"
                        aria-labelledby="options-menu"
                    >
                        <a
                            href="/admin"
                            onClick={() => setShowSettingsMenu(false)}
                            className="block px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 hover:text-slate-900"
                            role="menuitem"
                        >
                            Admin Dashboard
                        </a>
                        <a
                            href="/settings"
                            onClick={() => setShowSettingsMenu(false)}
                            className="block px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 hover:text-slate-900"
                            role="menuitem"
                        >
                            Settings
                        </a>
                        <button
                            onClick={() => {
                                handleLogout();
                                setShowSettingsMenu(false);
                            }}
                            className="block w-full text-left px-4 py-2 text-sm text-slate-700 hover:bg-slate-100 hover:text-slate-900"
                            role="menuitem"
                        >
                            Log Out
                        </button>
                    </div>
                )}
            </div>
            )}
        </div>
    );
};

const container = document.getElementById('root');
const root = ReactDOM.createRoot(container);
root.render(<App />);
</script>
    {% endraw %}
</body>
</html>
